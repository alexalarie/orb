

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>orb.utils package &mdash; Orb latest documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="_static/logo.ico"/>
  
  
  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Changelog" href="changelog.html" />
    <link rel="prev" title="orb.ext package" href="orb.ext.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> Orb
          

          
            
            <img src="_static/logo_sidebar.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                latest
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="installation.html">ORB installation</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="orb.html">orb package</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="orb.html#subpackages">Subpackages</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="orb.ext.html">orb.ext package</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">orb.utils package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#submodules">Submodules</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-orb.utils.astrometry">orb.utils.astrometry module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-orb.utils.err">orb.utils.err module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-orb.utils.fft">orb.utils.fft module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-orb.utils.filters">orb.utils.filters module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-orb.utils.fit">orb.utils.fit module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-orb.utils.image">orb.utils.image module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-orb.utils.io">orb.utils.io module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-orb.utils.log">orb.utils.log module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-orb.utils.misc">orb.utils.misc module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-orb.utils.parallel">orb.utils.parallel module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-orb.utils.photometry">orb.utils.photometry module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-orb.utils.sim">orb.utils.sim module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-orb.utils.spectrum">orb.utils.spectrum module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-orb.utils.stats">orb.utils.stats module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-orb.utils.validate">orb.utils.validate module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-orb.utils.vector">orb.utils.vector module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-orb.utils.web">orb.utils.web module</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="orb.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="orb.html#module-orb.cgvar">orb.cgvar module</a></li>
<li class="toctree-l2"><a class="reference internal" href="orb.html#module-orb.constants">orb.constants module</a></li>
<li class="toctree-l2"><a class="reference internal" href="orb.html#module-orb.core">orb.core module</a></li>
<li class="toctree-l2"><a class="reference internal" href="orb.html#module-orb.cube">orb.cube module</a></li>
<li class="toctree-l2"><a class="reference internal" href="orb.html#module-orb.cutils">orb.cutils module</a></li>
<li class="toctree-l2"><a class="reference internal" href="orb.html#module-orb.fft">orb.fft module</a></li>
<li class="toctree-l2"><a class="reference internal" href="orb.html#module-orb.fit">orb.fit module</a></li>
<li class="toctree-l2"><a class="reference internal" href="orb.html#module-orb.image">orb.image module</a></li>
<li class="toctree-l2"><a class="reference internal" href="orb.html#module-orb.old">orb.old module</a></li>
<li class="toctree-l2"><a class="reference internal" href="orb.html#module-orb.photometry">orb.image photometry</a></li>
<li class="toctree-l2"><a class="reference internal" href="orb.html#module-orb.sim">orb.sim</a></li>
<li class="toctree-l2"><a class="reference internal" href="orb.html#module-orb">Module contents</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="changelog.html">Changelog</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Orb</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="orb.html">orb package</a> &raquo;</li>
        
      <li>orb.utils package</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/orb.utils.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="orb-utils-package">
<h1>orb.utils package<a class="headerlink" href="#orb-utils-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-orb.utils.astrometry">
<span id="orb-utils-astrometry-module"></span><h2>orb.utils.astrometry module<a class="headerlink" href="#module-orb.utils.astrometry" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="orb.utils.astrometry.Gaussian">
<em class="property">class </em><code class="sig-prename descclassname">orb.utils.astrometry.</code><code class="sig-name descname">Gaussian</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">params</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.Gaussian" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#orb.utils.astrometry.PSF" title="orb.utils.astrometry.PSF"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.utils.astrometry.PSF</span></code></a></p>
<p>Class implementing the gaussian profile</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The Gaussian profile used here is:
<span class="math notranslate nohighlight">\(f(x,y) = H + A \times \exp(\frac{-r^2}{2 W^2})\)</span></p>
<p>and,
<span class="math notranslate nohighlight">\(r = (x - dx)^2 + (y - dy)^2\)</span></p>
<p>The total flux F under the 2D profile is:
<span class="math notranslate nohighlight">\(F = 2 \pi A W^2\)</span></p>
</div>
<dl class="py method">
<dt id="orb.utils.astrometry.Gaussian.array2d">
<code class="sig-name descname">array2d</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">nx</span></em>, <em class="sig-param"><span class="n">ny</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.Gaussian.array2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a 2D profile given the size of the returned
array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nx</strong> – Length of the returned array along x axis</p></li>
<li><p><strong>ny</strong> – Length of the returned array along y axis</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.utils.astrometry.Gaussian.flux">
<code class="sig-name descname">flux</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.Gaussian.flux" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the total flux under the 2D profile.</p>
<p>The total flux F under a 2D profile is :
<span class="math notranslate nohighlight">\(F = 2 \pi A W^2\)</span></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Under a 1d profile the flux is <span class="math notranslate nohighlight">\(F = \sqrt{2\pi}A W\)</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="orb.utils.astrometry.Gaussian.flux_error">
<code class="sig-name descname">flux_error</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">amplitude_err</span></em>, <em class="sig-param"><span class="n">width_err</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.Gaussian.flux_error" title="Permalink to this definition">¶</a></dt>
<dd><p>Return flux error.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>amplitude_err</strong> – estimation of the amplitude error</p></li>
<li><p><strong>width_err</strong> – estimation of the width error</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="orb.utils.astrometry.Gaussian.input_params">
<code class="sig-name descname">input_params</code><em class="property"> = ['height', 'amplitude', 'x', 'y', 'fwhm']</em><a class="headerlink" href="#orb.utils.astrometry.Gaussian.input_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Keys of the input parameters</p>
</dd></dl>

<dl class="py attribute">
<dt id="orb.utils.astrometry.Gaussian.params">
<code class="sig-name descname">params</code><em class="property"> = {}</em><a class="headerlink" href="#orb.utils.astrometry.Gaussian.params" title="Permalink to this definition">¶</a></dt>
<dd><p>dictionary containing the parameters of the profile</p>
</dd></dl>

<dl class="py attribute">
<dt id="orb.utils.astrometry.Gaussian.width">
<code class="sig-name descname">width</code><em class="property"> = None</em><a class="headerlink" href="#orb.utils.astrometry.Gaussian.width" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt id="orb.utils.astrometry.Moffat">
<em class="property">class </em><code class="sig-prename descclassname">orb.utils.astrometry.</code><code class="sig-name descname">Moffat</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">params</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.Moffat" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#orb.utils.astrometry.PSF" title="orb.utils.astrometry.PSF"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.utils.astrometry.PSF</span></code></a></p>
<p>Class implementing the Moffat profile.</p>
<p>This profile is useful to fit stars on CCD arrays.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The Moffat profile has been first proposed by Moffat
(1969) A&amp;A. The exact form of the equation used has been derived
from Trujillo et al. (2001) MNRAS, 977. The PSF:</p>
<p><span class="math notranslate nohighlight">\(f(x,y) = H + A \times [1+(\frac{r}{\alpha})^2]^{-\beta}\)</span></p>
<p>with,
<span class="math notranslate nohighlight">\(\alpha = \frac{\text{FWHM}}{2\sqrt{2^{1/\beta} - 1}}\)</span></p>
<p>and,
<span class="math notranslate nohighlight">\(r = (x - dx)^2 + (y - dy)^2\)</span></p>
<p>The total flux F under the 2D profile is thus:
<span class="math notranslate nohighlight">\(F = A \times \frac{\pi \alpha^2}{\beta - 1}\)</span></p>
</div>
<dl class="py attribute">
<dt id="orb.utils.astrometry.Moffat.alpha">
<code class="sig-name descname">alpha</code><em class="property"> = None</em><a class="headerlink" href="#orb.utils.astrometry.Moffat.alpha" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="orb.utils.astrometry.Moffat.array2d">
<code class="sig-name descname">array2d</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">nx</span></em>, <em class="sig-param"><span class="n">ny</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.Moffat.array2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a 2D profile given the size of the returned
array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nx</strong> – Length of the returned array along x axis</p></li>
<li><p><strong>ny</strong> – Length of the returned array along y axis</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.utils.astrometry.Moffat.flux">
<code class="sig-name descname">flux</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.Moffat.flux" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the total flux under the 2D profile.</p>
</dd></dl>

<dl class="py method">
<dt id="orb.utils.astrometry.Moffat.flux_error">
<code class="sig-name descname">flux_error</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">amplitude_err</span></em>, <em class="sig-param"><span class="n">width_err</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.Moffat.flux_error" title="Permalink to this definition">¶</a></dt>
<dd><p>Return flux error.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>amplitude_err</strong> – estimation of the amplitude error</p></li>
<li><p><strong>width_err</strong> – estimation of the width error</p></li>
</ul>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Not implemented yet!</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="orb.utils.astrometry.Moffat.input_params">
<code class="sig-name descname">input_params</code><em class="property"> = ['height', 'amplitude', 'x', 'y', 'fwhm', 'beta']</em><a class="headerlink" href="#orb.utils.astrometry.Moffat.input_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Keys of the input parameters</p>
</dd></dl>

<dl class="py attribute">
<dt id="orb.utils.astrometry.Moffat.params">
<code class="sig-name descname">params</code><em class="property"> = {}</em><a class="headerlink" href="#orb.utils.astrometry.Moffat.params" title="Permalink to this definition">¶</a></dt>
<dd><p>dictionary containing the parameters of the profile</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="orb.utils.astrometry.PSF">
<em class="property">class </em><code class="sig-prename descclassname">orb.utils.astrometry.</code><code class="sig-name descname">PSF</code><a class="headerlink" href="#orb.utils.astrometry.PSF" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>General class of inheritance for point spread functions (PSFs)</p>
<dl class="py method">
<dt id="orb.utils.astrometry.PSF.array2d">
<code class="sig-name descname">array2d</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">nx</span></em>, <em class="sig-param"><span class="n">ny</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.PSF.array2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a 2D profile given the size of the returned
array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nx</strong> – Length of the returned array along x axis</p></li>
<li><p><strong>ny</strong> – Length of the returned array along y axis</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="orb.utils.astrometry.PSF.params">
<code class="sig-name descname">params</code><em class="property"> = None</em><a class="headerlink" href="#orb.utils.astrometry.PSF.params" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="orb.utils.astrometry.PSF.varray2d">
<code class="sig-name descname">varray2d</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">nx</span></em>, <em class="sig-param"><span class="n">ny</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.PSF.varray2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a vectorized 2D profile given the size of the returned
array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nx</strong> – Length of the returned array along x axis</p></li>
<li><p><strong>ny</strong> – Length of the returned array along y axis</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="orb.utils.astrometry.aperture_photometry">
<code class="sig-prename descclassname">orb.utils.astrometry.</code><code class="sig-name descname">aperture_photometry</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">star_box</span></em>, <em class="sig-param"><span class="n">fwhm_guess</span></em>, <em class="sig-param"><span class="n">background_guess</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">background_guess_err</span><span class="o">=</span><span class="default_value">0.0</span></em>, <em class="sig-param"><span class="n">aper_coeff</span><span class="o">=</span><span class="default_value">3.0</span></em>, <em class="sig-param"><span class="n">warn</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">x_guess</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">y_guess</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">return_surfaces</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">aperture_surface</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">annulus_surface</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.aperture_photometry" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the aperture photometry of a star centered in a star box.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>star_box</strong> – Star box</p></li>
<li><p><strong>fwhm_guess</strong> – Guessed FWHM. Used to get the aperture radius.</p></li>
<li><p><strong>background_guess</strong> – (Optional) If not None, this guess is
used instead of the background determination in an annulus
around the star (default None).</p></li>
<li><p><strong>background_guess_err</strong> – (Optional) Error on the background
guess. Used to compute the aperture photometry error (default 0.).</p></li>
<li><p><strong>aper_coeff</strong> – (Optional) Aperture coefficient. The aperture
radius is Rap = aper_coeff * FWHM. Better when between 1.5 to
reduce the variation of the collected photons with varying FWHM
and 3. to account for the flux in the wings (default 3., better
for Moffat stars with a high SNR).</p></li>
<li><p><strong>warn</strong> – (Optional) If True, print a warning when the background cannot
be well estimated (default True).</p></li>
<li><p><strong>x_guess</strong> – (Optional) position of the star along x axis. If
None, star is assumed to lie at the very center of the frame
(default None).</p></li>
<li><p><strong>y_guess</strong> – (Optional) position of the star along y axis. If
None, star is assumed to lie at the very center of the frame
(default None).</p></li>
<li><p><strong>return_surfaces</strong> – (Optional) If True returns also the
aperture_surface and annulus_surface computed. Useful if
multiple stars with the same FWHM must be done (default False).</p></li>
<li><p><strong>aperture_surface</strong> – (Optional) Pre-computed
aperture_surface. Accelerate the process for multiple stars with
the same FWHM but must be used with caution. aper_coeff is of no
use if aperture_surface if given (default None). See
<a class="reference internal" href="#orb.utils.astrometry.multi_aperture_photometry" title="orb.utils.astrometry.multi_aperture_photometry"><code class="xref py py-meth docutils literal notranslate"><span class="pre">orb.utils.astrometry.multi_aperture_photometry()</span></code></a>.</p></li>
<li><p><strong>annulus_surface</strong> – (Optional) Pre-computed
annulus_surface. Accelerate the process for multiple stars with
the same FWHM but must be used with caution. aper_coeff is of no
use if annulus_surface if given (default None). See
<a class="reference internal" href="#orb.utils.astrometry.multi_aperture_photometry" title="orb.utils.astrometry.multi_aperture_photometry"><code class="xref py py-meth docutils literal notranslate"><span class="pre">orb.utils.astrometry.multi_aperture_photometry()</span></code></a>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A Tuple (flux, flux_error, aperture surface,
bad_estimation_flag). If the estimation is bad,
bad_estimation_flat is set to 1, else it is set to 0.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Best aperture for maximum S/N: 1. FWHM (Howell 1989,
Howell 1992). But that works only when the PSF is well sampled
which is not always the case so a higher aperture coefficient
may be better. More over, to get exact photometry the result
must be corrected by aperture growth curve for the ‘missing
light’. A coefficient of 1.27 FWHM corresponds to 3 sigma and
collects more than 99% of the light if the star is a pure
Gaussian. A coefficient of 3 for Moffat stars reduces the
variations of the proportion of collected photons when the FWHM
is changing and seems to be the best.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Best radius for sky background annulus is determined
from this rule of thumb: The number of pixels to estimate the
background must be al least 3 times the number of pixel in the
aperture (Merline &amp; Howell 1995). Choosing the aperture radius
coefficient(Cap) as Rap = Cap * FWHM and the inner radius
coefficient (Cin) as Rin = Cin * FWHM, gives the outer radius
coefficient (Cout): Cout = sqrt(3*Cap^2 + Cin^2)</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The star MUST be at the center (+/- 1 pixel) of the
star box.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#orb.utils.astrometry.multi_aperture_photometry" title="orb.utils.astrometry.multi_aperture_photometry"><code class="xref py py-meth docutils literal notranslate"><span class="pre">orb.utils.astrometry.multi_aperture_photometry()</span></code></a></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.astrometry.brute_force_guess">
<code class="sig-prename descclassname">orb.utils.astrometry.</code><code class="sig-name descname">brute_force_guess</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">image</span></em>, <em class="sig-param"><span class="n">star_list</span></em>, <em class="sig-param"><span class="n">x_range</span></em>, <em class="sig-param"><span class="n">y_range</span></em>, <em class="sig-param"><span class="n">r_range</span></em>, <em class="sig-param"><span class="n">rc</span></em>, <em class="sig-param"><span class="n">zoom_factor</span></em>, <em class="sig-param"><span class="n">box_size</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">init_wcs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">out_wcs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">raise_border_error</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.brute_force_guess" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine a precise alignment guess by brute force.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>star_list</strong> – List of star position. Must be given in pixels.</p></li>
<li><p><strong>x_range</strong> – range of x values to check</p></li>
<li><p><strong>y_range</strong> – range of y values to check</p></li>
<li><p><strong>r_range</strong> – range of angle values to check</p></li>
<li><p><strong>rc</strong> – rotation center (rc, ry). If a WCS is given the
rotation center is obtained from the wcs itself and must be set to
None.</p></li>
<li><p><strong>zoom_factor</strong> – zoom_factor</p></li>
<li><p><strong>verbose</strong> – (Optional) If True, print some informations
(default True).</p></li>
<li><p><strong>init_wcs</strong> – (Optional) WCS instance (can contain an SIP
distortion model, default None). Must be the SIP of the frame in
which the star position have computed.</p></li>
<li><p><strong>out_wcs</strong> – (Optional)  WCS instance (can contain an SIP
distortion model, default None). Must be the SIP of the frame in
which the stars are looked for.</p></li>
<li><p><strong>raise_border_error</strong> – (Optional) if True raise an exception
if the returned guess is on the border of the brute force grid
(defaut True).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.astrometry.compute_alignment_vectors">
<code class="sig-prename descclassname">orb.utils.astrometry.</code><code class="sig-name descname">compute_alignment_vectors</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fit_results</span></em>, <em class="sig-param"><span class="n">min_coeff</span><span class="o">=</span><span class="default_value">0.2</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.compute_alignment_vectors" title="Permalink to this definition">¶</a></dt>
<dd><p>compute alignement vectors from a list of fit results as returned
by fit_stars_in_cube.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fit_results</strong> – fit results.</p></li>
<li><p><strong>min_coeff</strong> – The minimum proportion of stars correctly fitted
to assume a good enough calculated disalignment (default 0.2).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.astrometry.compute_radec_pm">
<code class="sig-prename descclassname">orb.utils.astrometry.</code><code class="sig-name descname">compute_radec_pm</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ra_deg</span></em>, <em class="sig-param"><span class="n">dec_deg</span></em>, <em class="sig-param"><span class="n">pm_ra_mas</span></em>, <em class="sig-param"><span class="n">pm_dec_mas</span></em>, <em class="sig-param"><span class="n">yr</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.compute_radec_pm" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute RA/DEC in degrees with proper motion values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ra_deg</strong> – RA in degrees</p></li>
<li><p><strong>dec_deg</strong> – DEC in degrees</p></li>
<li><p><strong>pm_ra_mas</strong> – Proper motion along RA axis in mas/yr</p></li>
<li><p><strong>pm_dec_mas</strong> – Proper motion along DEC axis in mas/yr</p></li>
<li><p><strong>yr</strong> – Number of years</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.astrometry.create_wcs">
<code class="sig-prename descclassname">orb.utils.astrometry.</code><code class="sig-name descname">create_wcs</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">target_x</span></em>, <em class="sig-param"><span class="n">target_y</span></em>, <em class="sig-param"><span class="n">deltax</span></em>, <em class="sig-param"><span class="n">deltay</span></em>, <em class="sig-param"><span class="n">target_ra</span></em>, <em class="sig-param"><span class="n">target_dec</span></em>, <em class="sig-param"><span class="n">rotation</span></em>, <em class="sig-param"><span class="n">sip</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.create_wcs" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a WCS with an optional SIP distortion model.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>wcs</strong> – Original WCS. If None, a 2 axis WCS is created instead.</p></li>
<li><p><strong>target_x</strong> – Target X position in pixels</p></li>
<li><p><strong>target_y</strong> – Target Y position in pixels</p></li>
<li><p><strong>deltax</strong> – Plate scale in arcdeg / pixel along X axis (don’t forget to
divide by 3600 if originally in arcsec by pixels)</p></li>
<li><p><strong>deltax</strong> – Plate scale in arcdeg / pixel along Y axis (don’t forget to
divide by 3600 if originally in arcsec by pixels)</p></li>
<li><p><strong>target_ra</strong> – Target RA</p></li>
<li><p><strong>target_dec</strong> – Target DEC</p></li>
<li><p><strong>rotation</strong> – Rotation angle</p></li>
<li><p><strong>sip</strong> – (Optional) astropy.WCS instance containing a valid SIP.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.astrometry.dec2deg">
<code class="sig-prename descclassname">orb.utils.astrometry.</code><code class="sig-name descname">dec2deg</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dec</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.dec2deg" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert DEC in sexagesimal format to degrees.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>dec</strong> – DEC in sexagesimal format</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.astrometry.deg2dec">
<code class="sig-prename descclassname">orb.utils.astrometry.</code><code class="sig-name descname">deg2dec</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">deg</span></em>, <em class="sig-param"><span class="n">string</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.deg2dec" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert DEC in degrees to sexagesimal.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>deg</strong> – DEC in degrees</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.astrometry.deg2ra">
<code class="sig-prename descclassname">orb.utils.astrometry.</code><code class="sig-name descname">deg2ra</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">deg</span></em>, <em class="sig-param"><span class="n">string</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.deg2ra" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert RA in degrees to sexagesimal.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>deg</strong> – RA in degrees</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.astrometry.df2list">
<code class="sig-prename descclassname">orb.utils.astrometry.</code><code class="sig-name descname">df2list</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sources</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.df2list" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a sources pandas.DataFrame instance to a list of positions</p>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.astrometry.fit2df">
<code class="sig-prename descclassname">orb.utils.astrometry.</code><code class="sig-name descname">fit2df</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fit</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.fit2df" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert fit results to a pandas.DataFrame instance</p>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.astrometry.fit_sip">
<code class="sig-prename descclassname">orb.utils.astrometry.</code><code class="sig-name descname">fit_sip</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">scale</span></em>, <em class="sig-param"><span class="n">star_list1</span></em>, <em class="sig-param"><span class="n">star_list2</span></em>, <em class="sig-param"><span class="n">params</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">init_sip</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">err</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">sip_order</span><span class="o">=</span><span class="default_value">4</span></em>, <em class="sig-param"><span class="n">crpix</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">crval</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">plot</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.fit_sip" title="Permalink to this definition">¶</a></dt>
<dd><p>FIT the distortion correction polynomial to match two lists
of stars (the list of stars 2 is distorded to match the list
of stars 1).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>scale</strong> – Plate scale of the image in arcseconds (can be a
tuple (scalex, scaley) or a single float)</p></li>
<li><p><strong>star_list1</strong> – list of stars 1</p></li>
<li><p><strong>star_list2</strong> – list of stars 2</p></li>
<li><p><strong>params</strong> – (Optional) Transformation parameter to go from
the list of stars 1 to the list of stars 2. Must be a tuple
[dx, dy, dr, da, db, rcx, rcy, zoom_factor] (default None).</p></li>
<li><p><strong>init_sip</strong> – (Optional) Initial SIP (an astropy.wcs.WCS object,
default None)</p></li>
<li><p><strong>err</strong> – (Optional) error on the star positions of the star
list 2 (default None).</p></li>
<li><p><strong>sip_order</strong> – (Optional) SIP order (default 3).</p></li>
<li><p><strong>crpix</strong> – (Optional) If an initial wcs is not given (init_sip
set to None) this header value must be given.</p></li>
<li><p><strong>crval</strong> – (Optional) If an initial wcs is not given (init_sip
set to None) this header value must be given.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.astrometry.fit_star">
<code class="sig-prename descclassname">orb.utils.astrometry.</code><code class="sig-name descname">fit_star</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">star_box</span></em>, <em class="sig-param"><span class="n">profile_name</span><span class="o">=</span><span class="default_value">'gaussian'</span></em>, <em class="sig-param"><span class="n">fwhm_pix</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">amp</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">beta</span><span class="o">=</span><span class="default_value">3.5</span></em>, <em class="sig-param"><span class="n">height</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">pos</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">fix_height</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">fix_amp</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">fix_beta</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">fix_fwhm</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">fix_pos</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">fit_tol</span><span class="o">=</span><span class="default_value">0.001</span></em>, <em class="sig-param"><span class="n">check</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">fwhm_min</span><span class="o">=</span><span class="default_value">0.5</span></em>, <em class="sig-param"><span class="n">check_reject</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">ron</span><span class="o">=</span><span class="default_value">10.0</span></em>, <em class="sig-param"><span class="n">dcl</span><span class="o">=</span><span class="default_value">0.0</span></em>, <em class="sig-param"><span class="n">estimate_local_noise</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">precise_guess</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">saturation</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.fit_star" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit a single star</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>star_box</strong> – The box where the star has to be fitted.</p></li>
<li><p><strong>profile_name</strong> – (Optional) Name of the PSF profile to use to
fit stars. May be ‘gaussian’ or ‘moffat’ (default ‘gaussian’).</p></li>
<li><p><strong>amp</strong> – (Optional) Amplitude guess, replace the value of the
automatic estimation (default None).</p></li>
<li><p><strong>fwhm_pix</strong> – (Optional) Estimate of the FWHM in pixels. If
None given FWHM is estimated to half the box size (default
None).</p></li>
<li><p><strong>beta</strong> – (Optional) Beta parameter of the moffat psf. Used
only if the fitted profile is a Moffat psf (default 3.5).</p></li>
<li><p><strong>height</strong> – (Optional) Height guess, replace the value of the
automatic estimation (default None).</p></li>
<li><p><strong>pos</strong> – (Optional) Position guess as a tuple (x,y), replace
the value of the automatic estimation (default None).</p></li>
<li><p><strong>fix_amp</strong> – (Optional) Fix amplitude parameter to its
estimation (default False)</p></li>
<li><p><strong>fix_height</strong> – (Optional) Fix height parameter to its
estimation (default False)</p></li>
<li><p><strong>fix_beta</strong> – (Optional) Fix beta to the given value (default
True).</p></li>
<li><p><strong>fix_fwhm</strong> – (Optional) Fix FWHM to its estimation (default
False).</p></li>
<li><p><strong>fix_pos</strong> – (Optional) Fix position parameters (x,y) at their
estimated value (default False).</p></li>
<li><p><strong>fit_tol</strong> – (Optional) Tolerance on the paramaters fit (the
lower the better but the longer too) (default 1e-2).</p></li>
<li><p><strong>check</strong> – (Optional) If True, check fit results for oddities
(default True).</p></li>
<li><p><strong>fwhm_min</strong> – (Optional) Minimum valid FWHM [in pixel] of the
fitted star (default 0.5)</p></li>
<li><p><strong>check_reject</strong> – (Optional) [Debug] If True, print the reason
why a fit is rejected (default False).</p></li>
<li><p><strong>ron</strong> – (Optional) Readout noise in ADU/pixel (default
10.). estimate_local_noise must be set to False for this noise
to be taken into account.</p></li>
<li><p><strong>dcl</strong> – (Optional) Dark current level in ADU/pixel (default
0.). estimate_local_noise must be set to False for this noise to
be taken into account.</p></li>
<li><p><strong>estimate_local_noise</strong> – (Optional) If True, the level of
noise is computed from the background pixels around the
stars. ron and dcl are thus not used (default True).</p></li>
<li><p><strong>precise_guess</strong> – (Optional) If True, the fit guess will be
more precise but this can lead to errors if the stars positions
are not already well known (default False).</p></li>
<li><p><strong>saturation</strong> – (Optional) If not None, all pixels above the
saturation level are removed from the fit (default None).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.astrometry.fit_stars_in_frame">
<code class="sig-prename descclassname">orb.utils.astrometry.</code><code class="sig-name descname">fit_stars_in_frame</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">frame</span></em>, <em class="sig-param"><span class="n">star_list</span></em>, <em class="sig-param"><span class="n">box_size</span></em>, <em class="sig-param"><span class="n">profile_name</span><span class="o">=</span><span class="default_value">'gaussian'</span></em>, <em class="sig-param"><span class="n">scale</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">fwhm_pix</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">beta</span><span class="o">=</span><span class="default_value">3.5</span></em>, <em class="sig-param"><span class="n">fit_tol</span><span class="o">=</span><span class="default_value">0.01</span></em>, <em class="sig-param"><span class="n">fwhm_min</span><span class="o">=</span><span class="default_value">0.5</span></em>, <em class="sig-param"><span class="n">fix_height</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">fix_aperture_fwhm_pix</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">fix_beta</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">fix_fwhm</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">readout_noise</span><span class="o">=</span><span class="default_value">10.0</span></em>, <em class="sig-param"><span class="n">dark_current_level</span><span class="o">=</span><span class="default_value">0.0</span></em>, <em class="sig-param"><span class="n">local_background</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">no_aperture_photometry</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">precise_guess</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">aper_coeff</span><span class="o">=</span><span class="default_value">3.0</span></em>, <em class="sig-param"><span class="n">blur</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">no_fit</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">estimate_local_noise</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">multi_fit</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">enable_zoom</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">enable_rotation</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">saturation</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">fix_pos</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">nozero</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">silent</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">sip</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">background_value</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.fit_stars_in_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit stars in a frame.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>2 fitting modes are possible:</p>
<ul class="simple">
<li><p>Individual fit mode [multi_fit=False]: Stars are all fit
independantly.</p></li>
<li><p>Multi fit mode [multi_fit=True]: Stars are fitted all together
considering that the position pattern is well known, the same
shift in x and y will be applied. Optionally the pattern can be
rotated and zoomed. The FWHM is also considered to be the
same. This option is far more robust and precise for alignment
purpose.</p></li>
</ul>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>frame</strong> – The frame containing the stars to fit.</p></li>
<li><p><strong>star_list</strong> – A list of star positions as an array of shape
(star_nb, 2)</p></li>
<li><p><strong>box_size</strong> – The size of the box created around a star to fit
its parameter.</p></li>
<li><p><strong>profile_name</strong> – (Optional) Name of the PSF profile to use to
fit stars. May be ‘gaussian’ or ‘moffat’ (default ‘gaussian’).</p></li>
<li><p><strong>fwhm_pix</strong> – (Optional) Estimate of the FWHM in pixels. If
None given FWHM is estimated to half the box size (default
None).</p></li>
<li><p><strong>scale</strong> – (Optional) Scale of the frame in arcsec/pixel. If
given the fwhm in arcseconds is also computed (keyword:
‘fwhm_arc’) with the fit parameters (default None).</p></li>
<li><p><strong>beta</strong> – (Optional) Beta parameter of the moffat psf. Used
only if the fitted profile is a Moffat psf (default 3.5).</p></li>
<li><p><strong>fix_height</strong> – (Optional) Fix height parameter to its
estimation. If None, set by default to True in individual fit
mode [multi_fit=False] and False in multi fit mode
[multi_fit=True] (default None).</p></li>
<li><p><strong>fix_beta</strong> – (Optional) Fix beta to the given value (default
True).</p></li>
<li><p><strong>fix_fwhm</strong> – (Optional) Fix FWHM to the given value or the
estimated value (default False).</p></li>
<li><p><strong>fix_pos</strong> – (Optional) Fix x,y positions of the stars to the
given value.</p></li>
<li><p><strong>fit_tol</strong> – (Optional) Tolerance on the paramaters fit (the
lower the better but the longer too) (default 1e-2).</p></li>
<li><p><strong>nozero</strong> – (Optional) If True do not fit any star which box
(the pixels around it) contains a zero. Valid only in individual
fit mode [multi_fit=False] (default False).</p></li>
<li><p><strong>fwhm_min</strong> – (Optional) Minimum valid FWHM of the fitted star
(default 0.5)</p></li>
<li><p><strong>silent</strong> – (Optional) If True no messages are printed (default
True).</p></li>
<li><p><strong>local_background</strong> – (Optional) If True, height is estimated
localy, i.e. around the star. If False, the sky background is
determined in the whole frame. In individual fit mode
[multi_fit=False] height will be the same for all the stars, and
the fix_height option is thus automatically set to True. In
multi fit mode [multi_fit=True] height is considered as a
covarying parameter for all the stars but it won’t be fixed
(default True).</p></li>
<li><p><strong>fix_aperture_fwhm_pix</strong> – (Optional) If a positive float. FWHM
used to scale aperture size is not computed from the mean FWHM
in the frame but fixed to the given float (default None).</p></li>
<li><p><strong>no_aperture_photometry</strong> – (Optional) If True, aperture
photometry will not be done after profile fitting (default
False).</p></li>
<li><p><strong>precise_guess</strong> – (Optional) If True, the fit guess will be
more precise but this can lead to errors if the stars positions
are not already well known. Valid only in individual fit mode
[multi_fit=False] (default False).</p></li>
<li><p><strong>readout_noise</strong> – (Optional) Readout noise in ADU/pixel (can
be computed from bias frames: std(master_bias_frame)) (default
10.)</p></li>
<li><p><strong>dark_current_level</strong> – (Optional) Dark current level in
ADU/pixel (can be computed from dark frames:
median(master_dark_frame)) (default 0.)</p></li>
<li><p><strong>aper_coeff</strong> – (Optional) Aperture coefficient. The aperture
radius is Rap = aper_coeff * FWHM. Better when between 1.5 to
reduce the variation of the collected photons with varying FWHM
and 3. to account for the flux in the wings (default 3., better
for star with a high SNR).</p></li>
<li><p><strong>blur</strong> – (Optional) If True, blur frame (low pass filtering)
before fitting stars. It can be used to enhance the quality of
the fitted flux of undersampled data. Note that the error on
star position can be greater on blurred frame. This option must
not be used for alignment purpose (default False).</p></li>
<li><p><strong>no_fit</strong> – (Optional) If True, no fit is done. Only the
aperture photometry. Star positions in the star list must thus
be precise (default False).</p></li>
<li><p><strong>multi_fit</strong> – (Optional) If True all stars are fitted at the
same time. More robust for alignment purpose. The difference of
position between the stars in the star list must be precisely
known because the overall shift only is estimated (default
False).</p></li>
<li><p><strong>enable_zoom</strong> – (Optional) If True, the stars position pattern
can be zoomed to better adjust it to the real frame. Valid only
in multi fit mode [multi_fit=True] (default False).</p></li>
<li><p><strong>enable_rotation</strong> – (Optional) If True, the stars position
pattern can be rotated to better adjust it to the real frame
Valid only in multi fit mode [multi_fit=True] (default False).</p></li>
<li><p><strong>estimate_local_noise</strong> – (Optional) If True, the level of
noise is computed from the background pixels around the
stars. readout_noise and dark_current_level are thus not used
(default True).</p></li>
<li><p><strong>saturation</strong> – (Optional) If not None, all pixels above the
saturation level are removed from the fit (default None).</p></li>
<li><p><strong>sip</strong> – (Optional) A pywcs.WCS instance containing SIP
distorsion correction (default None).</p></li>
<li><p><strong>background_value</strong> – (Optional) If not None, this background
value is used in the fit functions and will be fixed for fit and
aperture photometry. Note also that in this case
local_background is automatically set to False (default None).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Parameters of a 2D fit of the stars positions.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-meth docutils literal notranslate"><span class="pre">astrometry.Astrometry.load_star_list()</span></code> to load
a predefined list of stars or
<code class="xref py py-meth docutils literal notranslate"><span class="pre">astrometry.Astrometry.detect_stars()</span></code> to automatically
create it.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-meth docutils literal notranslate"><span class="pre">utils.astrometry.fit_star()</span></code> and
<a class="reference internal" href="orb.html#orb.cutils.multi_fit_stars" title="orb.cutils.multi_fit_stars"><code class="xref py py-meth docutils literal notranslate"><span class="pre">orb.cutils.multi_fit_stars()</span></code></a></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.astrometry.fit_wcs">
<code class="sig-prename descclassname">orb.utils.astrometry.</code><code class="sig-name descname">fit_wcs</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">star_list_pix</span></em>, <em class="sig-param"><span class="n">star_list_deg</span></em>, <em class="sig-param"><span class="n">wcs</span></em>, <em class="sig-param"><span class="n">fitsip</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.fit_wcs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="orb.utils.astrometry.get_cd">
<code class="sig-prename descclassname">orb.utils.astrometry.</code><code class="sig-name descname">get_cd</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">wcs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.get_cd" title="Permalink to this definition">¶</a></dt>
<dd><p>Return CD matrix from a header with PC matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>wcs</strong> – astropy.wcs.WCS instance.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>CD matrix</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.astrometry.get_profile">
<code class="sig-prename descclassname">orb.utils.astrometry.</code><code class="sig-name descname">get_profile</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">profile_name</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.get_profile" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the PSF profile class corresponding to the given profile name.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>name</strong> (<em>profile</em>) – The name of the PSF profile. Must be ‘moffat’
or ‘gaussian’.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.astrometry.get_wcs_parameters">
<code class="sig-prename descclassname">orb.utils.astrometry.</code><code class="sig-name descname">get_wcs_parameters</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">wcs</span></em>, <em class="sig-param"><span class="n">fix_rc</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.get_wcs_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Return comprehensive parameters from a simple WCS as created
with orb.utils.astrometry.create_wcs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>wcs</strong> – An astropy.wcs.WCS instance created with
orb.utils.astrometry.create_wcs.</p></li>
<li><p><strong>fix_rc</strong> – Fix the rotation center of the returned parameters
to a given value. Must be atuple (target_x, target_y)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>target_x, target_y, deltax, deltay, target_ra,
target_dec, rotation</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.astrometry.guess">
<code class="sig-prename descclassname">orb.utils.astrometry.</code><code class="sig-name descname">guess</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">star_box</span></em>, <em class="sig-param"><span class="n">pos</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">height</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">precise_pos</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.guess" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an estimation of the star parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>star_box</strong> – Sub-part of an image surrounding a star. The
center of the star must be placed near the center of the
box. The dimensions of the box must be greater than 3 times
the FWHM of the star.</p></li>
<li><p><strong>pos</strong> – (Optional) Position guess as a tuple (x,y). Used to
estimate amplitude (default None).</p></li>
<li><p><strong>height</strong> – (Optional) Guess of the background level. Used to
estimate amplitude (default None).</p></li>
<li><p><strong>precise_pos</strong> – (Optional) If True, position is estimated from
the marginal distribution of the PSF. Return a far better
estimation if and only if the star is well centered in the box,
i.e. if and only if the position of the star is already
known. This can lead to errors when trying to find the star in
the box, in this case precise_pos must be set to False (default
False).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>[height,amplitude,x,y,width]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.astrometry.histogram_registration">
<code class="sig-prename descclassname">orb.utils.astrometry.</code><code class="sig-name descname">histogram_registration</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">star_list1</span></em>, <em class="sig-param"><span class="n">star_list2</span></em>, <em class="sig-param"><span class="n">dimx</span></em>, <em class="sig-param"><span class="n">dimy</span></em>, <em class="sig-param"><span class="n">xy_bins</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.histogram_registration" title="Permalink to this definition">¶</a></dt>
<dd><p>Fast histogram registration of an image based on the comparison
of two star lists: one created from the real star position in the
image and the other from, e.g. a catalog.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>star_list1</strong> – first list of stars</p></li>
<li><p><strong>star_list2</strong> – second list of stars</p></li>
<li><p><strong>dimx</strong> – X dimension of the image in pixels</p></li>
<li><p><strong>dimy</strong> – Y dimension of the image inp ixels</p></li>
<li><p><strong>xy_bins</strong> – number of bins along X and Y</p></li>
</ul>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This kind of registration is very sensitive to the
angle between each list. It is better to use it on a range of
angles (steps of 0.5 degree) to make sure the best correlation
is found.</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.astrometry.load_star_list">
<code class="sig-prename descclassname">orb.utils.astrometry.</code><code class="sig-name descname">load_star_list</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">star_list</span></em>, <em class="sig-param"><span class="n">remove_nans</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.load_star_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Load a list of stars coordinates from an hdffile or a pandas DataFrame or a numpy.ndarray</p>
<dl class="field-list simple">
<dt class="field-odd">Star_list</dt>
<dd class="field-odd"><p>can be a np.ndarray of shape (n, 2) or a path to a star list</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p><strong>remove_nans</strong> – If True, Nans are removed from the output star list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.astrometry.mag">
<code class="sig-prename descclassname">orb.utils.astrometry.</code><code class="sig-name descname">mag</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">flux</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.mag" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Return the instrumental magnitude of a given flux (magnitude 0</dt><dd><p>is set to 1 e-)</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>flux</strong> – Flux in e-</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.astrometry.match_star_lists">
<code class="sig-prename descclassname">orb.utils.astrometry.</code><code class="sig-name descname">match_star_lists</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">wcs</span></em>, <em class="sig-param"><span class="n">sl1deg</span></em>, <em class="sig-param"><span class="n">sl2pix</span></em>, <em class="sig-param"><span class="n">rc</span></em>, <em class="sig-param"><span class="n">xyrange</span><span class="o">=</span><span class="default_value">500, 50</span></em>, <em class="sig-param"><span class="n">rrange</span><span class="o">=</span><span class="default_value">6, 1</span></em>, <em class="sig-param"><span class="n">zrange</span><span class="o">=</span><span class="default_value">0.03, 0.015</span></em>, <em class="sig-param"><span class="n">nsteps</span><span class="o">=</span><span class="default_value">7</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.match_star_lists" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="orb.utils.astrometry.multi_aperture_photometry">
<code class="sig-prename descclassname">orb.utils.astrometry.</code><code class="sig-name descname">multi_aperture_photometry</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">frame</span></em>, <em class="sig-param"><span class="n">pos_list</span></em>, <em class="sig-param"><span class="n">fwhm_guess_pix</span></em>, <em class="sig-param"><span class="n">aper_coeff</span><span class="o">=</span><span class="default_value">3.0</span></em>, <em class="sig-param"><span class="n">detect_fwhm</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">silent</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.multi_aperture_photometry" title="Permalink to this definition">¶</a></dt>
<dd><p>Aperture photometry of multiple sources in a frame.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>frame</strong> – Frame</p></li>
<li><p><strong>pos_list</strong> – List of the positions of the sources</p></li>
<li><p><strong>fwhm_guess_pix</strong> – Initial guess on the FWHM of the sources.</p></li>
<li><p><strong>aper_coeff</strong> – (Optional) Aperture coefficient used for
photometry (default 3.).</p></li>
<li><p><strong>detect_fwhm</strong> – (Optional) If True FWHM is automatically
computed from a fit on the sources. Sources must be stars or
bright point sources. If most of the sources are stars this
might work well enough (default False).</p></li>
<li><p><strong>silent</strong> – (Optional) Silent function if True (default False).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.astrometry.pc2cd">
<code class="sig-prename descclassname">orb.utils.astrometry.</code><code class="sig-name descname">pc2cd</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">hdr</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.pc2cd" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert header PC definition to CD definition</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>hdr</strong> – A FITS header</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>converted FITS header</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.astrometry.pix2world">
<code class="sig-prename descclassname">orb.utils.astrometry.</code><code class="sig-name descname">pix2world</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">hdr</span></em>, <em class="sig-param"><span class="n">dimx</span></em>, <em class="sig-param"><span class="n">dimy</span></em>, <em class="sig-param"><span class="n">star_list_pix</span></em>, <em class="sig-param"><span class="n">dxmap</span></em>, <em class="sig-param"><span class="n">dymap</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.pix2world" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert pixel positions to RA/DEC coordinates.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>hdr</strong> – pyfits.Header instance</p></li>
<li><p><strong>dimx</strong> – Image dimension along X</p></li>
<li><p><strong>dimy</strong> – Image dimension along Y</p></li>
<li><p><strong>star_list_pix</strong> – List of star coordinates in pixels</p></li>
<li><p><strong>dxmap</strong> – Distortion error map along X axis returned by
orb.astrometry.Astrometry.register().</p></li>
<li><p><strong>dymap</strong> – Distortion error map along Y axis returned by
orb.astrometry.Astrometry.register().</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>it is much more effficient to pass a list of coordinates
than run the function for each couple of coordinates you want to
transform.</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.astrometry.ra2deg">
<code class="sig-prename descclassname">orb.utils.astrometry.</code><code class="sig-name descname">ra2deg</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ra</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.ra2deg" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert RA in sexagesimal format to degrees.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>ra</strong> – RA in sexagesimal format</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.astrometry.radial_profile">
<code class="sig-prename descclassname">orb.utils.astrometry.</code><code class="sig-name descname">radial_profile</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">xc</span></em>, <em class="sig-param"><span class="n">yc</span></em>, <em class="sig-param"><span class="n">rmax</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.radial_profile" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the average radial profile on a region of a 2D array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> – A 2D array</p></li>
<li><p><strong>xc</strong> – Center of the profile along x axis</p></li>
<li><p><strong>yc</strong> – Center of the profile along y axis</p></li>
<li><p><strong>rmax</strong> – Radius of the profile</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>(R axis, V axis). A tuple of 2 vectors giving the radius
axis and the corresponding values axis.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.astrometry.realign_images">
<code class="sig-prename descclassname">orb.utils.astrometry.</code><code class="sig-name descname">realign_images</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">_cube</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.realign_images" title="Permalink to this definition">¶</a></dt>
<dd><p>Realign images of a small cube of images</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>_cube</strong> – A 3 dimensional np.ndarray.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This procedure is robust but very slow. Do not use it
to realign a large number of images.</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.astrometry.sky_background_level">
<code class="sig-prename descclassname">orb.utils.astrometry.</code><code class="sig-name descname">sky_background_level</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">im</span></em>, <em class="sig-param"><span class="n">smooth_coeff</span><span class="o">=</span><span class="default_value">0.1</span></em>, <em class="sig-param"><span class="n">return_mode</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">bins</span><span class="o">=</span><span class="default_value">25</span></em>, <em class="sig-param"><span class="n">return_error</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.sky_background_level" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the level of the sky background based on the maximum of
the histogram of the pixels distribution in the image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>im</strong> – Image.</p></li>
<li><p><strong>smooth_coeff</strong> – (Optional) the smoothing degree, i.e. the
number of smoothing points is defined by smooth_coeff *
size(histogram) (default 0.05). If smooth_coeff &lt;= 0. no
smoothing is applied.</p></li>
<li><p><strong>return_mode</strong> – (Optional) If True the returned value is the
mode (an entire value for a distribution of integers). If False,
return the mean of a sigmacut realized around the mode (a
fractional value, generally more precise).</p></li>
<li><p><strong>bins</strong> – (Optional) Number of bins for the histogram (default
20).</p></li>
<li><p><strong>return_error</strong> – (Optional) If True, the error on the
estimation is returned (default False).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.astrometry.transform_star_position_A_to_B">
<code class="sig-prename descclassname">orb.utils.astrometry.</code><code class="sig-name descname">transform_star_position_A_to_B</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">star_list_A</span></em>, <em class="sig-param"><span class="n">params</span></em>, <em class="sig-param"><span class="n">rc</span></em>, <em class="sig-param"><span class="n">zoom_factor</span></em>, <em class="sig-param"><span class="n">sip_A</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">sip_B</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.transform_star_position_A_to_B" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform star positions in camera A to the positions in camera
B given the transformation parameters.</p>
<p>Optionally SIP distorsion parameters can be given.</p>
<p>The transformation steps are:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">dist_pix_camA</span> <span class="o">-&gt;</span> <span class="n">perf_pix_camA</span> <span class="o">-&gt;</span> <span class="n">geometric</span> <span class="n">transformation_A2B</span>
<span class="o">-&gt;</span> <span class="n">perf_pix_camB</span> <span class="o">-&gt;</span> <span class="n">dist_pix_camB</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>star_list_A</strong> – List of star coordinates in the cube A.</p></li>
<li><p><strong>params</strong> – Transformation parameters [dx, dy, dr, da, db].</p></li>
<li><p><strong>rc</strong> – Rotation center coordinates.</p></li>
<li><p><strong>zoom_factor</strong> – Zooming factor between the two cameras. Can be
a couple (zx, zy).</p></li>
<li><p><strong>sip_A</strong> – (Optional) pywcs.WCS instance containing SIP
parameters of the frame A (default None).</p></li>
<li><p><strong>sip_B</strong> – (Optional) pywcs.WCS instance containing SIP
parameters of the frame B (default None).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.astrometry.transform_wcs">
<code class="sig-prename descclassname">orb.utils.astrometry.</code><code class="sig-name descname">transform_wcs</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">wcs</span></em>, <em class="sig-param"><span class="n">params</span></em>, <em class="sig-param"><span class="n">rc</span></em>, <em class="sig-param"><span class="n">zoom_factor</span></em>, <em class="sig-param"><span class="n">sip</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">wcs_params</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.transform_wcs" title="Permalink to this definition">¶</a></dt>
<dd><p>Gometric transformation of a wcs</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>wcs</strong> – wcs.</p></li>
<li><p><strong>params</strong> – Transformation parameters [dx, dy, dr, da, db].</p></li>
<li><p><strong>rc</strong> – Rotation center coordinates.</p></li>
<li><p><strong>zoom_factor</strong> – Zooming factor between the two cameras. Can be
a couple (zx, zy).</p></li>
<li><p><strong>sip</strong> – (Optional) pywcs.WCS instance containing SIP
parameters of the output wcs (default None).</p></li>
<li><p><strong>wcs_params</strong> – If already computed, accelerates the
process. Must be obtained with compute_wcs_parameters(wcs).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.astrometry.world2pix">
<code class="sig-prename descclassname">orb.utils.astrometry.</code><code class="sig-name descname">world2pix</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">hdr</span></em>, <em class="sig-param"><span class="n">dimx</span></em>, <em class="sig-param"><span class="n">dimy</span></em>, <em class="sig-param"><span class="n">star_list_deg</span></em>, <em class="sig-param"><span class="n">dxmap</span></em>, <em class="sig-param"><span class="n">dymap</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.world2pix" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert RA/DEC coordinates to pixel positions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>hdr</strong> – pyfits.Header instance</p></li>
<li><p><strong>dimx</strong> – Image dimension along X</p></li>
<li><p><strong>dimy</strong> – Image dimension along Y</p></li>
<li><p><strong>star_list_deg</strong> – List of star coordinates in degrees</p></li>
<li><p><strong>dxmap</strong> – Distortion error map along X axis returned by
orb.astrometry.Astrometry.register().</p></li>
<li><p><strong>dymap</strong> – Distortion error map along Y axis returned by
orb.astrometry.Astrometry.register().</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>it is much more effficient to pass a list of coordinates
than run the function for each couple of coordinates you want to
transform.</p>
</div>
</dd></dl>

</div>
<div class="section" id="module-orb.utils.err">
<span id="orb-utils-err-module"></span><h2>orb.utils.err module<a class="headerlink" href="#module-orb.utils.err" title="Permalink to this headline">¶</a></h2>
<dl class="py exception">
<dt id="orb.utils.err.FitError">
<em class="property">exception </em><code class="sig-prename descclassname">orb.utils.err.</code><code class="sig-name descname">FitError</code><a class="headerlink" href="#orb.utils.err.FitError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#orb.utils.err.ORBError" title="orb.utils.err.ORBError"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.utils.err.ORBError</span></code></a></p>
</dd></dl>

<dl class="py exception">
<dt id="orb.utils.err.FitInitError">
<em class="property">exception </em><code class="sig-prename descclassname">orb.utils.err.</code><code class="sig-name descname">FitInitError</code><a class="headerlink" href="#orb.utils.err.FitInitError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#orb.utils.err.ORBError" title="orb.utils.err.ORBError"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.utils.err.ORBError</span></code></a></p>
</dd></dl>

<dl class="py exception">
<dt id="orb.utils.err.FitInputError">
<em class="property">exception </em><code class="sig-prename descclassname">orb.utils.err.</code><code class="sig-name descname">FitInputError</code><a class="headerlink" href="#orb.utils.err.FitInputError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#orb.utils.err.ORBError" title="orb.utils.err.ORBError"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.utils.err.ORBError</span></code></a></p>
</dd></dl>

<dl class="py exception">
<dt id="orb.utils.err.ORBError">
<em class="property">exception </em><code class="sig-prename descclassname">orb.utils.err.</code><code class="sig-name descname">ORBError</code><a class="headerlink" href="#orb.utils.err.ORBError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">RuntimeError</span></code></p>
</dd></dl>

<dl class="py exception">
<dt id="orb.utils.err.ValidationError">
<em class="property">exception </em><code class="sig-prename descclassname">orb.utils.err.</code><code class="sig-name descname">ValidationError</code><a class="headerlink" href="#orb.utils.err.ValidationError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#orb.utils.err.ORBError" title="orb.utils.err.ORBError"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.utils.err.ORBError</span></code></a></p>
</dd></dl>

</div>
<div class="section" id="module-orb.utils.fft">
<span id="orb-utils-fft-module"></span><h2>orb.utils.fft module<a class="headerlink" href="#module-orb.utils.fft" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="orb.utils.fft.apod2sigma">
<code class="sig-prename descclassname">orb.utils.fft.</code><code class="sig-name descname">apod2sigma</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">apod</span></em>, <em class="sig-param"><span class="n">fwhm</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.apod2sigma" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the broadening of the gaussian-sinc function in the
spectrum for a given apodization level. Unit is that of the fwhm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>apod</strong> – Apodization level (must be &gt;= 1.)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.fft.apod2width">
<code class="sig-prename descclassname">orb.utils.fft.</code><code class="sig-name descname">apod2width</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">apod</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.apod2width" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the width of the gaussian window for a given apodization level.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>apod</strong> – Apodization level (must be &gt;= 1.)</p>
</dd>
</dl>
<p>The apodization level is the broadening factor of the line (an
apodization level of 2 mean that the line fwhm will be 2 times
wider).</p>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.fft.border_cut_window">
<code class="sig-prename descclassname">orb.utils.fft.</code><code class="sig-name descname">border_cut_window</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n</span></em>, <em class="sig-param"><span class="n">coeff</span><span class="o">=</span><span class="default_value">0.2</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.border_cut_window" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a window function with only the edges cut by a nice
gaussian shape function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> – Window length</p></li>
<li><p><strong>coeff</strong> – Border size in percentage of the total length.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.fft.cube_raw_fft">
<code class="sig-prename descclassname">orb.utils.fft.</code><code class="sig-name descname">cube_raw_fft</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">apod</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.cube_raw_fft" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the raw FFT of a cube (the last axis
beeing the interferogram axis)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> – Interferogram cube</p></li>
<li><p><strong>apod</strong> – (Optional) Apodization function used. See
<code class="xref py py-meth docutils literal notranslate"><span class="pre">utils.gaussian_window()</span></code> (default None)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.fft.gaussian_window">
<code class="sig-prename descclassname">orb.utils.fft.</code><code class="sig-name descname">gaussian_window</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">coeff</span></em>, <em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.gaussian_window" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a Gaussian apodization function for a given broadening
factor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>coeff</strong> – FWHM relative to the sinc function. Must be a float &gt; 1.</p></li>
<li><p><strong>x</strong> – Must be an axis defined between -1 and 1 inclusively.
x = np.linspace(-1., 1., n) for a symmetrical window.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.fft.indft">
<code class="sig-prename descclassname">orb.utils.fft.</code><code class="sig-name descname">indft</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.indft" title="Permalink to this definition">¶</a></dt>
<dd><p>Inverse Non-uniform Discret Fourier Transform.</p>
<p>Compute the irregularly sampled interferogram from a regularly
sampled spectrum.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> – regularly sampled spectrum.</p></li>
<li><p><strong>x</strong> – positions of the interferogram samples. If x =
range(size(a)), this function is equivalent to an idft or a
ifft. Note that the ifft is of course much faster to
compute. This vector may have any length.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.fft.interf_mean_energy">
<code class="sig-prename descclassname">orb.utils.fft.</code><code class="sig-name descname">interf_mean_energy</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">interf</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.interf_mean_energy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the mean energy of an interferogram by step.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>interf</strong> – an interferogram</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The mean of the interferogram is substracted to
compute only the modulation energy. This is the modulation
energy which must be conserved in the resulting spectrum. Note
that the interferogram transformation function (see
<code class="xref py py-meth docutils literal notranslate"><span class="pre">utils.transform_interferogram()</span></code>) remove the mean of the
interferogram before computing its FFT.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>NaNs are set to 0.</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.fft.learner95_window">
<code class="sig-prename descclassname">orb.utils.fft.</code><code class="sig-name descname">learner95_window</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.learner95_window" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the apodization function described in Learner et al.,
J. Opt. Soc. Am. A, 12, (1995).</p>
<p>This function is closely related to the minimum four-term
Blackman-Harris window.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> – Must be an axis defnined between -1 and 1 inclusively.
x = np.linspace(-1., 1., n) for a symmetrical window.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.fft.ndft">
<code class="sig-prename descclassname">orb.utils.fft.</code><code class="sig-name descname">ndft</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">xk</span></em>, <em class="sig-param"><span class="n">vj</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.ndft" title="Permalink to this definition">¶</a></dt>
<dd><p>Non-uniform Discret Fourier Tranform</p>
<p>Compute the spectrum from an interferogram. Note that the axis can
be irregularly sampled.</p>
<p>If the spectral axis (output axis) is irregular the result is
exact. But there is no magic: if the input axis (interferogram
sampling) is irregular the output spectrum is not exact because
the projection basis is not orthonormal.</p>
<p>If the interferogram is the addition of multiple regularly sampled
scans with a opd shift between each scan, the result will be good
as long as there are not too much scans added one after the
other. But if the interferogram steps are randomly distributed, it
will be better to use a classic FFT because the resulting noise
will be much lower.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> – 1D interferogram</p></li>
<li><p><strong>xk</strong> – 1D sampling steps of the interferogram. Must have the
same size as a and must be relative to the real step length,
i.e. if the sampling is uniform xk = np.arange(a.size).</p></li>
<li><p><strong>vj</strong> – 1D frequency sampling of the output spectrum.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.fft.next_power_of_two">
<code class="sig-prename descclassname">orb.utils.fft.</code><code class="sig-name descname">next_power_of_two</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.next_power_of_two" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the next power of two greater than n.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>n</strong> – The number from which the next power of two has to be
computed. Can be an array of numbers.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.fft.norton_beer_window">
<code class="sig-prename descclassname">orb.utils.fft.</code><code class="sig-name descname">norton_beer_window</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fwhm</span><span class="o">=</span><span class="default_value">'1.6'</span></em>, <em class="sig-param"><span class="n">n</span><span class="o">=</span><span class="default_value">1000</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.norton_beer_window" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an extended Norton-Beer window function (see <a class="reference internal" href="#nay2007" id="id1"><span>[NAY2007]</span></a>).</p>
<p>Returned window is symmetrical.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fwhm</strong> – FWHM relative to the sinc function. Must be: 1.1,
1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9 or 2.0. (default ‘1.6’)</p></li>
<li><p><strong>n</strong> – Number of points (default 1000)</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Coefficients of the extended Norton-Beer functions
apodizing functions <a class="reference internal" href="#nay2007" id="id2"><span>[NAY2007]</span></a> :</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 8%" />
<col style="width: 15%" />
<col style="width: 17%" />
<col style="width: 15%" />
<col style="width: 15%" />
<col style="width: 15%" />
<col style="width: 15%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>FWHM</p></td>
<td><p>C0</p></td>
<td><p>C1</p></td>
<td><p>C2</p></td>
<td><p>C4</p></td>
<td><p>C6</p></td>
<td><p>C8</p></td>
</tr>
<tr class="row-even"><td><p>1.1</p></td>
<td><p>0.701551</p></td>
<td><p>-0.639244</p></td>
<td><p>0.937693</p></td>
<td><p>0.000000</p></td>
<td><p>0.000000</p></td>
<td><p>0.000000</p></td>
</tr>
<tr class="row-odd"><td><p>1.2</p></td>
<td><p>0.396430</p></td>
<td><p>-0.150902</p></td>
<td><p>0.754472</p></td>
<td><p>0.000000</p></td>
<td><p>0.000000</p></td>
<td><p>0.000000</p></td>
</tr>
<tr class="row-even"><td><p>1.3</p></td>
<td><p>0.237413</p></td>
<td><p>-0.065285</p></td>
<td><p>0.827872</p></td>
<td><p>0.000000</p></td>
<td><p>0.000000</p></td>
<td><p>0.000000</p></td>
</tr>
<tr class="row-odd"><td><p>1.4</p></td>
<td><p>0.153945</p></td>
<td><p>-0.141765</p></td>
<td><p>0.987820</p></td>
<td><p>0.000000</p></td>
<td><p>0.000000</p></td>
<td><p>0.000000</p></td>
</tr>
<tr class="row-even"><td><p>1.5</p></td>
<td><p>0.077112</p></td>
<td><p>0.000000</p></td>
<td><p>0.703371</p></td>
<td><p>0.219517</p></td>
<td><p>0.000000</p></td>
<td><p>0.000000</p></td>
</tr>
<tr class="row-odd"><td><p>1.6</p></td>
<td><p>0.039234</p></td>
<td><p>0.000000</p></td>
<td><p>0.630268</p></td>
<td><p>0.234934</p></td>
<td><p>0.095563</p></td>
<td><p>0.000000</p></td>
</tr>
<tr class="row-even"><td><p>1.7</p></td>
<td><p>0.020078</p></td>
<td><p>0.000000</p></td>
<td><p>0.480667</p></td>
<td><p>0.386409</p></td>
<td><p>0.112845</p></td>
<td><p>0.000000</p></td>
</tr>
<tr class="row-odd"><td><p>1.8</p></td>
<td><p>0.010172</p></td>
<td><p>0.000000</p></td>
<td><p>0.344429</p></td>
<td><p>0.451817</p></td>
<td><p>0.193580</p></td>
<td><p>0.000000</p></td>
</tr>
<tr class="row-even"><td><p>1.9</p></td>
<td><p>0.004773</p></td>
<td><p>0.000000</p></td>
<td><p>0.232473</p></td>
<td><p>0.464562</p></td>
<td><p>0.298191</p></td>
<td><p>0.000000</p></td>
</tr>
<tr class="row-odd"><td><p>2.0</p></td>
<td><p>0.002267</p></td>
<td><p>0.000000</p></td>
<td><p>0.140412</p></td>
<td><p>0.487172</p></td>
<td><p>0.256200</p></td>
<td><p>0.113948</p></td>
</tr>
</tbody>
</table>
</div>
<dl class="citation">
<dt class="label" id="nay2007"><span class="brackets">NAY2007</span><span class="fn-backref">(<a href="#id1">1</a>,<a href="#id2">2</a>)</span></dt>
<dd><p>Naylor, D. A., &amp; Tahic, M. K. (2007). Apodizing
functions for Fourier transform spectroscopy. Journal of the
Optical Society of America A.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.fft.raw_fft">
<code class="sig-prename descclassname">orb.utils.fft.</code><code class="sig-name descname">raw_fft</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">apod</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">inverse</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">return_complex</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">return_phase</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.raw_fft" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the raw FFT of a vector.</p>
<p>Return the absolute value of the complex vector by default.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> – Interferogram.</p></li>
<li><p><strong>apod</strong> – (Optional) Apodization function used. See
<code class="xref py py-meth docutils literal notranslate"><span class="pre">utils.norton_beer_window()</span></code> (default None)</p></li>
<li><p><strong>inverse</strong> – (Optional) If True compute the inverse FFT
(default False).</p></li>
<li><p><strong>return_complex</strong> – (Optional) If True, the complex vector is
returned (default False).</p></li>
<li><p><strong>return_phase</strong> – (Optional) If True, the phase is
returned.(default False)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.fft.sigma2apod">
<code class="sig-prename descclassname">orb.utils.fft.</code><code class="sig-name descname">sigma2apod</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sigma</span></em>, <em class="sig-param"><span class="n">fwhm</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.sigma2apod" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the inverse of apod2sigma.</p>
<p>As the inverse is at least complicated to compute. This is done via
minimization.</p>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.fft.spectrum_mean_energy">
<code class="sig-prename descclassname">orb.utils.fft.</code><code class="sig-name descname">spectrum_mean_energy</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">spectrum</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.spectrum_mean_energy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the mean energy of a spectrum by channel.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>spectrum</strong> – a 1D spectrum</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.fft.width2apod">
<code class="sig-prename descclassname">orb.utils.fft.</code><code class="sig-name descname">width2apod</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">width</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.width2apod" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the inverse of apod2width.</p>
<p>As the inverse is at least complicated to compute. This is done via
minimization.</p>
</dd></dl>

</div>
<div class="section" id="module-orb.utils.filters">
<span id="orb-utils-filters-module"></span><h2>orb.utils.filters module<a class="headerlink" href="#module-orb.utils.filters" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="orb.utils.filters.compute_weights">
<code class="sig-prename descclassname">orb.utils.filters.</code><code class="sig-name descname">compute_weights</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">calib</span></em>, <em class="sig-param"><span class="n">nm_laser</span></em>, <em class="sig-param"><span class="n">step_nb</span></em>, <em class="sig-param"><span class="n">step</span></em>, <em class="sig-param"><span class="n">order</span></em>, <em class="sig-param"><span class="n">range_border_coeff</span></em>, <em class="sig-param"><span class="n">filter_min_cm1</span></em>, <em class="sig-param"><span class="n">filter_max_cm1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.filters.compute_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute weights for a fit based on a spectrum with a given
filter bandpass</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>calib</strong> – Calibration laser observed wavelength</p></li>
<li><p><strong>nm_laser</strong> – Calibration laser theoretical wavelength</p></li>
<li><p><strong>step_nb</strong> – Vector length</p></li>
<li><p><strong>step</strong> – Step size (in nm)</p></li>
<li><p><strong>order</strong> – Folding order</p></li>
<li><p><strong>range_border_coeff</strong> – Percentage of the vector size
considered as bad borders near the filter edges (must be between
0.2 and 0.).</p></li>
<li><p><strong>filter_min_cm1</strong> – Minimum wavenumber of the filter in cm-1</p></li>
<li><p><strong>filter_max_cm1</strong> – Maximum wavenumber of the filter in cm-1</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-orb.utils.fit">
<span id="orb-utils-fit-module"></span><h2>orb.utils.fit module<a class="headerlink" href="#module-orb.utils.fit" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="orb.utils.fit.gvardict2pickdict">
<code class="sig-prename descclassname">orb.utils.fit.</code><code class="sig-name descname">gvardict2pickdict</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">gvardict</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fit.gvardict2pickdict" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a dictionary containing gvars into a nice pickable
dictionary with couples of _mean / _sdev keys.</p>
<p>Use the pickdict2gvardict to rerturn to the original dictionary.</p>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.fit.paramslist2pick">
<code class="sig-prename descclassname">orb.utils.fit.</code><code class="sig-name descname">paramslist2pick</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">paramslist</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fit.paramslist2pick" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="orb.utils.fit.pick2paramslist">
<code class="sig-prename descclassname">orb.utils.fit.</code><code class="sig-name descname">pick2paramslist</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">picklist</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fit.pick2paramslist" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="orb.utils.fit.pickdict2gvardict">
<code class="sig-prename descclassname">orb.utils.fit.</code><code class="sig-name descname">pickdict2gvardict</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pickdict</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fit.pickdict2gvardict" title="Permalink to this definition">¶</a></dt>
<dd><p>Invert gvardict2pickdict.</p>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.fit.sigma2vel">
<code class="sig-prename descclassname">orb.utils.fit.</code><code class="sig-name descname">sigma2vel</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sigma</span></em>, <em class="sig-param"><span class="n">lines</span></em>, <em class="sig-param"><span class="n">axis_step</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fit.sigma2vel" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a broadening in channels to a velocity in km/s
:param sigma: broadening in channels
:param lines: line position in the unit of axis_step
:param axis_step: axis step size</p>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.fit.vel2sigma">
<code class="sig-prename descclassname">orb.utils.fit.</code><code class="sig-name descname">vel2sigma</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">vel</span></em>, <em class="sig-param"><span class="n">lines</span></em>, <em class="sig-param"><span class="n">axis_step</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fit.vel2sigma" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a velocity in km/s to a broadening in channels.
:param vel: velocity in km/s
:param lines: line position in the unit of axis_step
:param axis_step: axis step size</p>
</dd></dl>

</div>
<div class="section" id="module-orb.utils.image">
<span id="orb-utils-image-module"></span><h2>orb.utils.image module<a class="headerlink" href="#module-orb.utils.image" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="orb.utils.image.bf_laser_aligner">
<code class="sig-prename descclassname">orb.utils.image.</code><code class="sig-name descname">bf_laser_aligner</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">im1</span></em>, <em class="sig-param"><span class="n">im2</span></em>, <em class="sig-param"><span class="n">init_dx</span></em>, <em class="sig-param"><span class="n">init_dy</span></em>, <em class="sig-param"><span class="n">init_angle</span></em>, <em class="sig-param"><span class="n">zf</span></em>, <em class="sig-param"><span class="n">binning</span><span class="o">=</span><span class="default_value">4</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.bf_laser_aligner" title="Permalink to this definition">¶</a></dt>
<dd><p>Align two complementary laser frames (i.e. cam1 and cam2) with
a brute force algorithm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>im1</strong> – frame 1</p></li>
<li><p><strong>im2</strong> – frame 2</p></li>
<li><p><strong>init_dx</strong> – Initial alignement parameter along X axis</p></li>
<li><p><strong>init_dy</strong> – Initial alignement parameter along Y axis</p></li>
<li><p><strong>init_angle</strong> – Initial angle</p></li>
<li><p><strong>zf</strong> – Zoom factor</p></li>
<li><p><strong>binning</strong> – Binning of the data for the first pass</p></li>
</ul>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This function returns parameters much different that
the alignement parameters we get from stars… I don’t know why
!</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.image.bilinear_interpolation">
<code class="sig-prename descclassname">orb.utils.image.</code><code class="sig-name descname">bilinear_interpolation</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">c</span></em>, <em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.bilinear_interpolation" title="Permalink to this definition">¶</a></dt>
<dd><p>Bilinear interpolation in a 2x2xN cube</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>c</strong> – 2x2xN cube</p></li>
<li><p><strong>x</strong> – position in the cube along x between 0 and 1</p></li>
<li><p><strong>y</strong> – position in the cube along y between 0 and 1</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.image.bin_image">
<code class="sig-prename descclassname">orb.utils.image.</code><code class="sig-name descname">bin_image</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">binning</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.bin_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Return mean binned image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image</strong> – 2d array to bin.</p></li>
<li><p><strong>binning</strong> – binning (must be an integer &gt;= 1).</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Only the complete sets of rows or columns are binned
so that depending on the bin size and the image size the
last columns or rows can be ignored. This ensures that the
binning surface is the same for every pixel in the binned
array.</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.image.check_frames">
<code class="sig-prename descclassname">orb.utils.image.</code><code class="sig-name descname">check_frames</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">frames</span></em>, <em class="sig-param"><span class="n">sigma_reject</span><span class="o">=</span><span class="default_value">2.5</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.check_frames" title="Permalink to this definition">¶</a></dt>
<dd><p>Check and reject deviating frames based on their median level.</p>
<p>Frames with a too deviant median level are discarded. This
function is used by <code class="xref py py-meth docutils literal notranslate"><span class="pre">utils.create_master_frame()</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>frames</strong> – Set of frames to check</p></li>
<li><p><strong>sigma_reject</strong> – (Optional) Rejection coefficient (default 2.5)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.image.compute_binning">
<code class="sig-prename descclassname">orb.utils.image.</code><code class="sig-name descname">compute_binning</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">image_shape</span></em>, <em class="sig-param"><span class="n">detector_shape</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.compute_binning" title="Permalink to this definition">¶</a></dt>
<dd><p>Return binning along both axis given the image shape and the
detector shape.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image_size</strong> – Tuple [x,y] giving the image shape</p></li>
<li><p><strong>detector_shape</strong> – Tuple [x,y] giving the detector shape
(i.e. maximum numbers of pixels along the x and y axis.)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.image.correct_cosmic_rays">
<code class="sig-prename descclassname">orb.utils.image.</code><code class="sig-name descname">correct_cosmic_rays</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">frame</span></em>, <em class="sig-param"><span class="n">cr_map</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.correct_cosmic_rays" title="Permalink to this definition">¶</a></dt>
<dd><p>correct cosmic rays in an image</p>
<p>CRs are replaced by a weighted average of the neighbouring
region. Weights are calculated from a 2d gaussian kernel.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>frame</strong> – image</p></li>
<li><p><strong>cr_map</strong> – cosmic ray map (1 = CR, 0 = NO_CR). must be of
boolean type.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.image.correct_hot_pixels">
<code class="sig-prename descclassname">orb.utils.image.</code><code class="sig-name descname">correct_hot_pixels</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">im</span></em>, <em class="sig-param"><span class="n">hp_map</span></em>, <em class="sig-param"><span class="n">box_size</span><span class="o">=</span><span class="default_value">3</span></em>, <em class="sig-param"><span class="n">std_filter_coeff</span><span class="o">=</span><span class="default_value">1.5</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.correct_hot_pixels" title="Permalink to this definition">¶</a></dt>
<dd><p>Correct hot pixels in an image given a map of their position.</p>
<p>The algorithm used replaces a hot pixel value by the median of the
pixels in a box around it. Pixels values which are not too much
different from the values around are not modified.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>im</strong> – Image to correct</p></li>
<li><p><strong>hp_map</strong> – Hot pixels map (1 for hot pixels, 0 for normal
pixel)</p></li>
<li><p><strong>box_size</strong> – (Optional) Size of the correction box (default
3).</p></li>
<li><p><strong>std_filter_coeff</strong> – (Optional) Coefficient on the std used to
check if the value of a hot pixel must be changed (default 1.5).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.image.correct_map2d">
<code class="sig-prename descclassname">orb.utils.image.</code><code class="sig-name descname">correct_map2d</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">map2d</span></em>, <em class="sig-param"><span class="n">bad_value</span><span class="o">=</span><span class="default_value">nan</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.correct_map2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Correct a map of values by interpolation along columns.</p>
<p>The bad value must be specified.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>map2d</strong> – The map to correct</p></li>
<li><p><strong>bad_value</strong> – (Optional) Value considered as bad (default
np.nan).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.image.create_master_frame">
<code class="sig-prename descclassname">orb.utils.image.</code><code class="sig-name descname">create_master_frame</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">frames</span></em>, <em class="sig-param"><span class="n">combine</span><span class="o">=</span><span class="default_value">'average'</span></em>, <em class="sig-param"><span class="n">reject</span><span class="o">=</span><span class="default_value">'avsigclip'</span></em>, <em class="sig-param"><span class="n">sigma</span><span class="o">=</span><span class="default_value">3.0</span></em>, <em class="sig-param"><span class="n">silent</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">check</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.create_master_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a master frame from a set a frames.</p>
<p>This method has been inspired by the <strong>IRAF</strong> function
combine.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>frames</strong> – Frames to combine.</p></li>
<li><p><strong>reject</strong> – (Optional) Rejection operation. Can be ‘sigclip’,
‘minmax’, ‘avsigclip’ (default ‘avsigclip’)</p></li>
<li><p><strong>combine</strong> – (Optional) Combining operation. Can be
‘average’ or ‘median’ (default ‘average’)</p></li>
<li><p><strong>sigma</strong> – (Optional) Sigma factor for pixel rejection
(default 3.).</p></li>
<li><p><strong>silent</strong> – (Optional) If True no information message are
displayed.</p></li>
<li><p><strong>check</strong> – (Optional) If True deviating frames are rejected
before combination (default True).</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Rejection operations:</p>
<ul class="simple">
<li><p><strong>sigclip</strong>: A Sigma Clipping algorithm is applied for
each pixel. Min and max values are rejected to estimate
the mean and the standard deviation at each pixel. Then
all values over (median + sigma * std) or below (median -
sigma * std) are rejected. Those steps are repeated (this
time not excluding the extreme values) while no other
value is rejected or the minimum number of values to keep
is reached. Work best with at least 10 frames.</p></li>
<li><p><strong>avsigclip</strong>: Average Sigma Clipping algorithm is the
same as Sigma Clipping algorithm but the standard
deviation at each pixel is estimated using an averaged
value of the std over the lines. This work best than sigma
clipping for a small number of frames. This algorithm is a
little more time consuming than the others. Works best with
at least 5 frames.</p></li>
<li><p><strong>minmax</strong>: Minimum and maximum values at each pixel are
rejected.</p></li>
</ul>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>No rejection operation can be performed with less
than 3 frames.</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.image.crop_pixel_positions">
<code class="sig-prename descclassname">orb.utils.image.</code><code class="sig-name descname">crop_pixel_positions</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pixs</span></em>, <em class="sig-param"><span class="n">xmin</span></em>, <em class="sig-param"><span class="n">xmax</span></em>, <em class="sig-param"><span class="n">ymin</span></em>, <em class="sig-param"><span class="n">ymax</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.crop_pixel_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Returned a croped list of pixels position</p>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.image.extract_elliptical_profile">
<code class="sig-prename descclassname">orb.utils.image.</code><code class="sig-name descname">extract_elliptical_profile</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">im</span></em>, <em class="sig-param"><span class="n">x0</span></em>, <em class="sig-param"><span class="n">y0</span></em>, <em class="sig-param"><span class="n">rX</span></em>, <em class="sig-param"><span class="n">rY</span></em>, <em class="sig-param"><span class="n">theta</span></em>, <em class="sig-param"><span class="n">n</span><span class="o">=</span><span class="default_value">20</span></em>, <em class="sig-param"><span class="n">percentile</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.extract_elliptical_profile" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract the elliptical profile of a source</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>im</strong> – Image</p></li>
<li><p><strong>x0</strong> – X position of the center</p></li>
<li><p><strong>theta</strong> – Angle of the ellipse (in deg)</p></li>
<li><p><strong>rX</strong> – Radius of the X axis</p></li>
<li><p><strong>rY</strong> – Radius of the Y axis</p></li>
<li><p><strong>n</strong> – (Optional) Number of divisions (default 20)</p></li>
<li><p><strong>percentile</strong> – (Optional) percentile instead of std. Return
(r, lmedian, [lmin, lmax]). Remember that the 1-sigma percentile
is 15.865 for a gaussian distribution (default None).</p></li>
</ul>
</dd>
<dt class="field-even">Parma y0</dt>
<dd class="field-even"><p>Y position of the center</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a tuple (r, l, lerr) where r is the list of radiuses
along rX, l the mean luminosity in the ellipse portion
corresponding to the radius, lerr the standard deviation of the
luminosity in the same portion of the ellipse.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.image.fit_calibration_laser_map">
<code class="sig-prename descclassname">orb.utils.image.</code><code class="sig-name descname">fit_calibration_laser_map</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">calib_laser_map</span></em>, <em class="sig-param"><span class="n">calib_laser_nm</span></em>, <em class="sig-param"><span class="n">pixel_size</span><span class="o">=</span><span class="default_value">15.0</span></em>, <em class="sig-param"><span class="n">binning</span><span class="o">=</span><span class="default_value">4</span></em>, <em class="sig-param"><span class="n">mirror_distance_guess</span><span class="o">=</span><span class="default_value">240000.0</span></em>, <em class="sig-param"><span class="n">return_model_fit</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.fit_calibration_laser_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit a calibration laser map.</p>
<p>Fit an opto-mechanical model first and uses Zernike polynomials to
fit the residual wavefront error.</p>
<p>The model is based on optical parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>calib_laser_map</strong> – Reference calibration laser map.</p></li>
<li><p><strong>calib_laser_nm</strong> – Wavelength of the calibration laser in nm.</p></li>
<li><p><strong>pixel_size</strong> – (Optional) Size of the CCD pixels in um
(default 15).</p></li>
<li><p><strong>binning</strong> – (Optional) Maps are binned to accelerate the
process. Set the binning factor (default 4).</p></li>
<li><p><strong>mirror_distance_guess</strong> – (Optional) Guess on the mirror
distance in um (default 2.2e5).</p></li>
<li><p><strong>return_model_fit</strong> – (Optional) If True the optical model fit
is also returned (i.e. without the wavefront modeling with Zernike
polynomials) (default False).</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Zernike polynomial fit routine has been written by Tim
van Werkhoven (<a class="reference external" href="mailto:werkhoven&#37;&#52;&#48;strw&#46;leidenuniv&#46;nl">werkhoven<span>&#64;</span>strw<span>&#46;</span>leidenuniv<span>&#46;</span>nl</a>) as a part of
libtim. It can be found in ORB module in ./ext/zern.py.</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.image.fit_map">
<code class="sig-prename descclassname">orb.utils.image.</code><code class="sig-name descname">fit_map</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data_map</span></em>, <em class="sig-param"><span class="n">err_map</span></em>, <em class="sig-param"><span class="n">smooth_deg</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.fit_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit map with low order polynomials</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data_map</strong> – data map</p></li>
<li><p><strong>err_map</strong> – error map</p></li>
<li><p><strong>smooth_deg</strong> – Degree of fit smoothing (beware of high
smoothing degrees)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a tuple: (fitted data map, residual map, fit RMS error)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.image.fit_map_theta">
<code class="sig-prename descclassname">orb.utils.image.</code><code class="sig-name descname">fit_map_theta</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data_map</span></em>, <em class="sig-param"><span class="n">err_map</span></em>, <em class="sig-param"><span class="n">theta_map</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.fit_map_theta" title="Permalink to this definition">¶</a></dt>
<dd><p>fit any data map with respect to theta. Given the corresponding theta map.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data_map</strong> – Data map to fit</p></li>
<li><p><strong>err_map</strong> – Uncertainty on the data map</p></li>
<li><p><strong>theta_map</strong> – Theta map (in degree)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.image.fit_map_zernike">
<code class="sig-prename descclassname">orb.utils.image.</code><code class="sig-name descname">fit_map_zernike</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data_map</span></em>, <em class="sig-param"><span class="n">weights_map</span></em>, <em class="sig-param"><span class="n">nmodes</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.fit_map_zernike" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit a map with Zernike polynomials.</p>
<p>Bad values must be set to NaN (not 0.)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data_map</strong> – Data map to fit</p></li>
<li><p><strong>weights_map</strong> – weights map (high weight value stands for high
precision data)</p></li>
<li><p><strong>nmodes</strong> – Number of zernike modes to use for fitting.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>(fitted data map, error map, fit error)</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Zernike polynomial fit routine has been written by Tim
van Werkhoven (<a class="reference external" href="mailto:werkhoven&#37;&#52;&#48;strw&#46;leidenuniv&#46;nl">werkhoven<span>&#64;</span>strw<span>&#46;</span>leidenuniv<span>&#46;</span>nl</a>) as a part of
libtim. It can be found in ORB module in ./ext/zern.py.</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.image.fit_phase_map">
<code class="sig-prename descclassname">orb.utils.image.</code><code class="sig-name descname">fit_phase_map</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data_map</span></em>, <em class="sig-param"><span class="n">err_map</span></em>, <em class="sig-param"><span class="n">theta_map</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.fit_phase_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit an order 0 phase map with a simple cos(theta) model</p>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.image.get_box_coords">
<code class="sig-prename descclassname">orb.utils.image.</code><code class="sig-name descname">get_box_coords</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ix</span></em>, <em class="sig-param"><span class="n">iy</span></em>, <em class="sig-param"><span class="n">box_size</span></em>, <em class="sig-param"><span class="n">x_lim_min</span></em>, <em class="sig-param"><span class="n">x_lim_max</span></em>, <em class="sig-param"><span class="n">y_lim_min</span></em>, <em class="sig-param"><span class="n">y_lim_max</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.get_box_coords" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the coordinates of a box given the center of the box,
its size and the limits of the range along x and y axes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ix</strong> – center of the box along x axis</p></li>
<li><p><strong>iy</strong> – center of the box along y axis</p></li>
<li><p><strong>box_size</strong> – Size of the box. The final size of the box will
generally be the same if box_size is odd. Note that the final
size of the box cannot be guaranteed.</p></li>
<li><p><strong>x_lim_min</strong> – Minimum limit of the range along x.</p></li>
<li><p><strong>x_lim_max</strong> – Maximum limit of the range along x.</p></li>
<li><p><strong>y_lim_min</strong> – Minimum limit of the range along y.</p></li>
<li><p><strong>y_lim_max</strong> – Maximum limit of the range along y.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>x_min, x_max, y_min, y_max</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.image.get_quadrant_dims">
<code class="sig-prename descclassname">orb.utils.image.</code><code class="sig-name descname">get_quadrant_dims</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">quad_number</span></em>, <em class="sig-param"><span class="n">dimx</span></em>, <em class="sig-param"><span class="n">dimy</span></em>, <em class="sig-param"><span class="n">div_nb</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.get_quadrant_dims" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the indices of a quadrant along x and y axes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>quad_number</strong> – Quadrant number</p></li>
<li><p><strong>dimx</strong> – X axis dimension.</p></li>
<li><p><strong>dimy</strong> – Y axis dimension.</p></li>
<li><p><strong>div_nb</strong> – Number of divisions along x and y axes. (e.g. if
div_nb = 3, the number of quadrant is 9 ; if div_nb = 4, the
number of quadrant is 16)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.image.high_pass_diff_image_filter">
<code class="sig-prename descclassname">orb.utils.image.</code><code class="sig-name descname">high_pass_diff_image_filter</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">im</span></em>, <em class="sig-param"><span class="n">deg</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.high_pass_diff_image_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a high pass filtered image using the method of low pass
diffrence filtering given by Mighell (1999).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>im</strong> – Image to filter</p></li>
<li><p><strong>deg</strong> – (Optional) Radius of the kernel of the low pass
filter. Must be &gt; 0 (default 1).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.image.high_pass_image_filter">
<code class="sig-prename descclassname">orb.utils.image.</code><code class="sig-name descname">high_pass_image_filter</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">im</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.high_pass_image_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a high pass filtered image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>im</strong> – Image to filter</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.image.in_ellipse">
<code class="sig-prename descclassname">orb.utils.image.</code><code class="sig-name descname">in_ellipse</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">x0</span></em>, <em class="sig-param"><span class="n">y0</span></em>, <em class="sig-param"><span class="n">rX</span></em>, <em class="sig-param"><span class="n">rY</span></em>, <em class="sig-param"><span class="n">theta</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.in_ellipse" title="Permalink to this definition">¶</a></dt>
<dd><p>Tell whether a pixel is in the ellipse or not.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> – X position of the point</p></li>
<li><p><strong>y</strong> – Y position of the point</p></li>
<li><p><strong>x0</strong> – X position of the center</p></li>
<li><p><strong>theta</strong> – Angle of the ellipse (in deg)</p></li>
<li><p><strong>rX</strong> – Radius of the X axis</p></li>
<li><p><strong>rY</strong> – Radius of the Y axis</p></li>
</ul>
</dd>
<dt class="field-even">Parma y0</dt>
<dd class="field-even"><p>Y position of the center</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.image.interpolate_map">
<code class="sig-prename descclassname">orb.utils.image.</code><code class="sig-name descname">interpolate_map</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">m</span></em>, <em class="sig-param"><span class="n">dimx</span></em>, <em class="sig-param"><span class="n">dimy</span></em>, <em class="sig-param"><span class="n">deg</span><span class="o">=</span><span class="default_value">3</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.interpolate_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolate 2D data map.</p>
<p>This function is robust to Nans.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The interpolation process is much longer if Nans are
present in the map.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>m</strong> – Map</p></li>
<li><p><strong>dimx</strong> – X dimension of the result</p></li>
<li><p><strong>dimy</strong> – Y dimension of the result</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.image.low_pass_image_filter">
<code class="sig-prename descclassname">orb.utils.image.</code><code class="sig-name descname">low_pass_image_filter</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">im</span></em>, <em class="sig-param"><span class="n">deg</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.low_pass_image_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a low pass filtered image using a gaussian kernel.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>im</strong> – Image to filter</p></li>
<li><p><strong>deg</strong> – Radius of the kernel. Must be &gt; 0.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.image.nanbin_image">
<code class="sig-prename descclassname">orb.utils.image.</code><code class="sig-name descname">nanbin_image</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">im</span></em>, <em class="sig-param"><span class="n">binning</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.nanbin_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Mean image (or cube) binning robust to NaNs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>im</strong> – Image or cube to bin</p></li>
<li><p><strong>binning</strong> – Binning factor (must be an integer)</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>adapted from <a class="reference external" href="https://stackoverflow.com/questions/6163334/binning-data-in-python-with-scipy-numpy">https://stackoverflow.com/questions/6163334/binning-data-in-python-with-scipy-numpy</a>.</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.image.on_ellipse">
<code class="sig-prename descclassname">orb.utils.image.</code><code class="sig-name descname">on_ellipse</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">x0</span></em>, <em class="sig-param"><span class="n">y0</span></em>, <em class="sig-param"><span class="n">rX</span></em>, <em class="sig-param"><span class="n">rY</span></em>, <em class="sig-param"><span class="n">theta</span></em>, <em class="sig-param"><span class="n">e</span><span class="o">=</span><span class="default_value">0.5</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.on_ellipse" title="Permalink to this definition">¶</a></dt>
<dd><p>Tell whether a pixel is on the ellipse or not.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> – X position of the point</p></li>
<li><p><strong>y</strong> – Y position of the point</p></li>
<li><p><strong>x0</strong> – X position of the center</p></li>
<li><p><strong>theta</strong> – Angle of the ellipse (in deg)</p></li>
<li><p><strong>rX</strong> – Radius of the X axis</p></li>
<li><p><strong>rY</strong> – Radius of the Y axis</p></li>
<li><p><strong>e</strong> – (Optional) Precision in pixels (default 0.5).</p></li>
</ul>
</dd>
<dt class="field-even">Parma y0</dt>
<dd class="field-even"><p>Y position of the center</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.image.polar_map2d">
<code class="sig-prename descclassname">orb.utils.image.</code><code class="sig-name descname">polar_map2d</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">f</span></em>, <em class="sig-param"><span class="n">n</span></em>, <em class="sig-param"><span class="n">corner</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">circle</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.polar_map2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Map a function over a square matrix in polar coordinates. The
origin is placed at the center of the map by default.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>f</strong> – The function to map.</p></li>
<li><p><strong>n</strong> – Matrix size. Can be a couple of integers (nx, ny).</p></li>
<li><p><strong>corner</strong> – (Optional) If True, the origin of the coordinates
becomes the corner (0,0) of the map (default False)</p></li>
<li><p><strong>circle</strong> – (Optional) If False and if the matrix is not
squared, the coordinates are those of an ellipsis of the same
shape as the matrix (default True).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.image.pp_create_master_frame">
<code class="sig-prename descclassname">orb.utils.image.</code><code class="sig-name descname">pp_create_master_frame</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">frames</span></em>, <em class="sig-param"><span class="n">combine</span><span class="o">=</span><span class="default_value">'average'</span></em>, <em class="sig-param"><span class="n">reject</span><span class="o">=</span><span class="default_value">'avsigclip'</span></em>, <em class="sig-param"><span class="n">sigma</span><span class="o">=</span><span class="default_value">3.0</span></em>, <em class="sig-param"><span class="n">ncpus</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.pp_create_master_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Run a parallelized version of <code class="xref py py-meth docutils literal notranslate"><span class="pre">utils.create_master_frame()</span></code>.</p>
<p>Use it only for big data set because it can be much slower for a
small data set (&lt; 500 x 500 x 10).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>frames</strong> – Frames to combine.</p></li>
<li><p><strong>reject</strong> – (Optional) Rejection operation. Can be ‘sigclip’,
‘minmax’, ‘avsigclip’ (default ‘avsigclip’)</p></li>
<li><p><strong>combine</strong> – (Optional) Combining operation. Can be
‘average’ or ‘median’ (default ‘average’)</p></li>
<li><p><strong>sigma</strong> – (Optional) Sigma factor for pixel rejection
(default 3.).</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-meth docutils literal notranslate"><span class="pre">utils.create_master_frame()</span></code></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.image.shift_frame">
<code class="sig-prename descclassname">orb.utils.image.</code><code class="sig-name descname">shift_frame</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">frame</span></em>, <em class="sig-param"><span class="n">dx</span></em>, <em class="sig-param"><span class="n">dy</span></em>, <em class="sig-param"><span class="n">x_min</span></em>, <em class="sig-param"><span class="n">x_max</span></em>, <em class="sig-param"><span class="n">y_min</span></em>, <em class="sig-param"><span class="n">y_max</span></em>, <em class="sig-param"><span class="n">order</span></em>, <em class="sig-param"><span class="n">fill_value</span><span class="o">=</span><span class="default_value">nan</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.shift_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a shifted frame wit the same dimensions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>frame</strong> – Two dimensions array to be shifted</p></li>
<li><p><strong>dx</strong> – Shift value along the axis 0</p></li>
<li><p><strong>dy</strong> – Shift value along the axis 1</p></li>
<li><p><strong>x_max</strong><strong>, </strong><strong>y_min</strong><strong>, </strong><strong>y_max</strong> (<em>x_min</em><em>,</em>) – Boundaries of the region to be
shifted.</p></li>
<li><p><strong>order</strong> – interpolation order.</p></li>
<li><p><strong>(</strong><strong>Optional</strong><strong>)</strong> (<em>fill_value</em>) – Value of the extrapolated points
(default np.nan).</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To avoid spline interpolation defects around
stars use order 1 (linear interpolation).</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.image.simulate_calibration_laser_map">
<code class="sig-prename descclassname">orb.utils.image.</code><code class="sig-name descname">simulate_calibration_laser_map</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">nx</span></em>, <em class="sig-param"><span class="n">ny</span></em>, <em class="sig-param"><span class="n">pixel_size</span></em>, <em class="sig-param"><span class="n">mirror_distance</span></em>, <em class="sig-param"><span class="n">theta_cx</span></em>, <em class="sig-param"><span class="n">theta_cy</span></em>, <em class="sig-param"><span class="n">phi_x</span></em>, <em class="sig-param"><span class="n">phi_y</span></em>, <em class="sig-param"><span class="n">phi_r</span></em>, <em class="sig-param"><span class="n">calib_laser_nm</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.simulate_calibration_laser_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Simulate a calibration laser map from optical and mechanical
parameters</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nx</strong> – Number of pixels along X</p></li>
<li><p><strong>ny</strong> – Number of pixels along Y</p></li>
<li><p><strong>pixel_size</strong> – Size of a pixel in microns</p></li>
<li><p><strong>mirror_distance</strong> – Distance to the mirror in microns on the
optical axis.</p></li>
<li><p><strong>theta_cx</strong> – Angle from the optical axis to the mirror
center in degrees along X axis (in degrees)</p></li>
<li><p><strong>theta_cy</strong> – Angle from the optical axis to the mirror
center in degrees along Y axis (in degrees)</p></li>
<li><p><strong>phi_x</strong> – Tilt of the mirror along X in degrees</p></li>
<li><p><strong>phi_y</strong> – Tilt of the mirror along Y in degrees</p></li>
<li><p><strong>phi_r</strong> – Rotation angle of the camera in degrees</p></li>
<li><p><strong>calib_laser_nm</strong> – Calibration laser wavelength in nm</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.image.simulate_theta_map">
<code class="sig-prename descclassname">orb.utils.image.</code><code class="sig-name descname">simulate_theta_map</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">nx</span></em>, <em class="sig-param"><span class="n">ny</span></em>, <em class="sig-param"><span class="n">pixel_size</span></em>, <em class="sig-param"><span class="n">mirror_distance</span></em>, <em class="sig-param"><span class="n">theta_cx</span></em>, <em class="sig-param"><span class="n">theta_cy</span></em>, <em class="sig-param"><span class="n">phi_x</span></em>, <em class="sig-param"><span class="n">phi_y</span></em>, <em class="sig-param"><span class="n">phi_r</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.simulate_theta_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Simulate incident angle (theta) map from optical and mechanical
parameters</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nx</strong> – Number of pixels along X</p></li>
<li><p><strong>ny</strong> – Number of pixels along Y</p></li>
<li><p><strong>pixel_size</strong> – Size of a pixel in microns</p></li>
<li><p><strong>mirror_distance</strong> – Distance to the mirror in microns on the
optical axis.</p></li>
<li><p><strong>theta_cx</strong> – Angle from the optical axis to the mirror
center in degrees along X axis (in degrees)</p></li>
<li><p><strong>theta_cy</strong> – Angle from the optical axis to the mirror
center in degrees along Y axis (in degrees)</p></li>
<li><p><strong>phi_x</strong> – Tilt of the mirror along X in degrees</p></li>
<li><p><strong>phi_y</strong> – Tilt of the mirror along Y in degrees</p></li>
<li><p><strong>phi_r</strong> – Rotation angle of the camera in degrees</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.image.tilt_calibration_laser_map">
<code class="sig-prename descclassname">orb.utils.image.</code><code class="sig-name descname">tilt_calibration_laser_map</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cmap</span></em>, <em class="sig-param"><span class="n">calib_laser_nm</span></em>, <em class="sig-param"><span class="n">phi_x</span></em>, <em class="sig-param"><span class="n">phi_y</span></em>, <em class="sig-param"><span class="n">phi_r</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.tilt_calibration_laser_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Tilt and rotate a calibration laser map.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cmap</strong> – calibration laser map.</p></li>
<li><p><strong>calib_laser_nm</strong> – Calibration laser wavelength in nm.</p></li>
<li><p><strong>phi_x</strong> – tilt angle along X axis (degrees).</p></li>
<li><p><strong>phi_y</strong> – tilt angle along Y axis (degrees).</p></li>
<li><p><strong>phi_r</strong> – Rotation angle (degrees).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.image.transform_frame">
<code class="sig-prename descclassname">orb.utils.image.</code><code class="sig-name descname">transform_frame</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">frame</span></em>, <em class="sig-param"><span class="n">x_min</span></em>, <em class="sig-param"><span class="n">x_max</span></em>, <em class="sig-param"><span class="n">y_min</span></em>, <em class="sig-param"><span class="n">y_max</span></em>, <em class="sig-param"><span class="n">d</span></em>, <em class="sig-param"><span class="n">rc</span></em>, <em class="sig-param"><span class="n">zoom_factor</span></em>, <em class="sig-param"><span class="n">interp_order</span></em>, <em class="sig-param"><span class="n">mask</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">fill_value</span><span class="o">=</span><span class="default_value">nan</span></em>, <em class="sig-param"><span class="n">sip_A</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">sip_B</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.transform_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform one frame or a part of it using transformation
coefficients.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>frame</strong> – Frame to transform</p></li>
<li><p><strong>x_min</strong> – Lower x boundary of the transformed section (can be
a tuple in order to get multiple sections)</p></li>
<li><p><strong>x_max</strong> – Upper x boundary of the transformed section (can be
a tuple in order to get multiple sections)</p></li>
<li><p><strong>y_min</strong> – Lower y boundary of the transformed section (can be
a tuple in order to get multiple sections)</p></li>
<li><p><strong>y_max</strong> – Upper y boundary of the transformed section (can be
a tuple in order to get multiple sections)</p></li>
<li><p><strong>d</strong> – Transformation coefficients [dx, dy, dr, da, db]</p></li>
<li><p><strong>rc</strong> – Rotation center of the frame [rc_x, rc_y]</p></li>
<li><p><strong>zoom_factor</strong> – Zoom on the image. Can be a couple (zx, zy).</p></li>
<li><p><strong>interp_order</strong> – Interpolation order</p></li>
<li><p><strong>mask</strong> – (Optional) If a mask frame is passed it is
transformed also (default None).</p></li>
<li><p><strong>fill_value</strong> – (Optional) Fill value for extrapolated points
(default np.nan).</p></li>
<li><p><strong>sip_A</strong> – (Optional) pywcs.WCS() instance containing SIP parameters of
the output image (default None).</p></li>
<li><p><strong>sip_B</strong> – (Optional) pywcs.WCS() instance containing SIP parameters of
the input image (default None).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.image.unwrap_phase_map0">
<code class="sig-prename descclassname">orb.utils.image.</code><code class="sig-name descname">unwrap_phase_map0</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">phase_map</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.unwrap_phase_map0" title="Permalink to this definition">¶</a></dt>
<dd><p>Phase is defined modulo pi/2. The Unwrapping is a
reconstruction of the phase so that the distance between two
neighbour pixels is always less than pi/4. Then the real
phase pattern can be recovered and fitted easily.</p>
<p>The idea is the same as with np.unwrap() but in 2D, on a
possibly very noisy map, where a naive 2d unwrapping cannot
be done.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>phase_map</strong> – Order 0 phase map.</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-orb.utils.io">
<span id="orb-utils-io-module"></span><h2>orb.utils.io module<a class="headerlink" href="#module-orb.utils.io" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="orb.utils.io.array2dict">
<code class="sig-prename descclassname">orb.utils.io.</code><code class="sig-name descname">array2dict</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.io.array2dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert an array read from an hdf5 file to a dict.
:param data: array of params returned by dict2array</p>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.io.cast">
<code class="sig-prename descclassname">orb.utils.io.</code><code class="sig-name descname">cast</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">t_str</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.io.cast" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="orb.utils.io.cast2hdf5">
<code class="sig-prename descclassname">orb.utils.io.</code><code class="sig-name descname">cast2hdf5</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">val</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.io.cast2hdf5" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="orb.utils.io.cast_storing_dtype">
<code class="sig-prename descclassname">orb.utils.io.</code><code class="sig-name descname">cast_storing_dtype</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">arr</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.io.cast_storing_dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="orb.utils.io.dict2array">
<code class="sig-prename descclassname">orb.utils.io.</code><code class="sig-name descname">dict2array</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.io.dict2array" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a dictionary to an array that can be written in an hdf5 file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>data</strong> – Must be a dict instance</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.io.dict2header">
<code class="sig-prename descclassname">orb.utils.io.</code><code class="sig-name descname">dict2header</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">params</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.io.dict2header" title="Permalink to this definition">¶</a></dt>
<dd><p>convert a dict to a pyfits.Header() instance</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>this is a destructive process, illegal values are</p>
</div>
<p>removed from the header.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>params</strong> – a dict instance</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.io.get_hdu_data_index">
<code class="sig-prename descclassname">orb.utils.io.</code><code class="sig-name descname">get_hdu_data_index</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">hdul</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.io.get_hdu_data_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of the first header data unit (HDU) containing data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>hdul</strong> – A pyfits.HDU instance</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.io.get_sitelle_slice">
<code class="sig-prename descclassname">orb.utils.io.</code><code class="sig-name descname">get_sitelle_slice</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">slice_str</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.io.get_sitelle_slice" title="Permalink to this definition">¶</a></dt>
<dd><p>Strip a string containing SITELLE like slice coordinates.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>slice_str</strong> – Slice string.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.io.get_storing_dtype">
<code class="sig-prename descclassname">orb.utils.io.</code><code class="sig-name descname">get_storing_dtype</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">arr</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.io.get_storing_dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="orb.utils.io.header_fits2hdf5">
<code class="sig-prename descclassname">orb.utils.io.</code><code class="sig-name descname">header_fits2hdf5</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fits_header</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.io.header_fits2hdf5" title="Permalink to this definition">¶</a></dt>
<dd><p>convert a pyfits.Header() instance to a header for an hdf5 file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>fits_header</strong> – Header of the FITS file</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.io.header_hdf52fits">
<code class="sig-prename descclassname">orb.utils.io.</code><code class="sig-name descname">header_hdf52fits</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">hdf5_header</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.io.header_hdf52fits" title="Permalink to this definition">¶</a></dt>
<dd><p>convert an hdf5 header to a pyfits.Header() instance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>hdf5_header</strong> – Header of the HDF5 file</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.io.load_dflist">
<code class="sig-prename descclassname">orb.utils.io.</code><code class="sig-name descname">load_dflist</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">path</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.io.load_dflist" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a list of dataframes</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>path</strong> – path to the output file</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.io.open_file">
<code class="sig-prename descclassname">orb.utils.io.</code><code class="sig-name descname">open_file</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">file_name</span></em>, <em class="sig-param"><span class="n">mode</span><span class="o">=</span><span class="default_value">'r'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.io.open_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Open a file in write mode (by default) and return a file
object.</p>
<p>Create the file if it doesn’t exist (only in write mode).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file_name</strong> – Path to the file, can be either
relative or absolute.</p></li>
<li><p><strong>mode</strong> – (Optional) Can be ‘w’ for write mode, ‘r’ for
read mode and ‘a’ for append mode.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.io.open_hdf5">
<code class="sig-prename descclassname">orb.utils.io.</code><code class="sig-name descname">open_hdf5</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">file_path</span></em>, <em class="sig-param"><span class="n">mode</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.io.open_hdf5" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a <code class="xref py py-class docutils literal notranslate"><span class="pre">h5py.File</span></code> instance with some
informations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file_path</strong> – Path to the hdf5 file.</p></li>
<li><p><strong>mode</strong> – Opening mode. Can be ‘r’, ‘r+’, ‘w’, ‘w-‘, ‘x’,
‘a’.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Please refer to <a class="reference external" href="http://www.h5py.org/">http://www.h5py.org/</a>.</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.io.read_fits">
<code class="sig-prename descclassname">orb.utils.io.</code><code class="sig-name descname">read_fits</code><span class="sig-paren">(</span><em class="sig-param">fits_path</em>, <em class="sig-param">no_error=False</em>, <em class="sig-param">nan_filter=False</em>, <em class="sig-param">return_header=False</em>, <em class="sig-param">return_hdu_only=False</em>, <em class="sig-param">return_mask=False</em>, <em class="sig-param">silent=False</em>, <em class="sig-param">delete_after=False</em>, <em class="sig-param">data_index=None</em>, <em class="sig-param">image_mode='classic'</em>, <em class="sig-param">chip_index=None</em>, <em class="sig-param">binning=None</em>, <em class="sig-param">fix_header=True</em>, <em class="sig-param">dtype=&lt;class 'float'&gt;</em>, <em class="sig-param">mask_path=None</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.io.read_fits" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a FITS data file and returns its data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fits_path</strong> – Path to the file, can be either
relative or absolut.</p></li>
<li><p><strong>no_error</strong> – (Optional) If True this function will only
display a warning message if the file does not exist (so it
does not raise an exception) (default False)</p></li>
<li><p><strong>nan_filter</strong> – (Optional) If True replace NaN by zeros
(default False)</p></li>
<li><p><strong>return_header</strong> – (Optional) If True return a tuple (data,
header) (default False).</p></li>
<li><p><strong>return_hdu_only</strong> – (Optional) If True return FITS header
data unit only. No data will be returned (default False).</p></li>
<li><p><strong>return_mask</strong> – (Optional) If True return only the mask
corresponding to the data file (default False).</p></li>
<li><p><strong>silent</strong> – (Optional) If True no message is displayed
except if an error is raised (default False).</p></li>
<li><p><strong>delete_after</strong> – (Optional) If True delete file after
reading (default False).</p></li>
<li><p><strong>data_index</strong> – (Optional) Index of data in the header data
unit (Default None).</p></li>
<li><p><strong>image_mode</strong> – (Optional) Can be ‘sitelle’, ‘spiomm’ or
‘classic’. In ‘sitelle’ mode, the parameter
chip_index must also be set to 0 or 1. In this mode only
one of both SITELLE quadrants is returned. In ‘classic’ mode
the whole frame is returned (default ‘classic’).</p></li>
<li><p><strong>chip_index</strong> – (Optional) Index of the chip of the
SITELLE image. Used only if image_mode is set to ‘sitelle’
In this case, must be 1 or 2. Else must be None (default
None).</p></li>
<li><p><strong>binning</strong> – (Optional) If not None, returned data is
binned by this amount (must be an integer &gt;= 1)</p></li>
<li><p><strong>fix_header</strong> – (Optional) If True, fits header is
fixed to avoid errors due to header inconsistencies
(e.g. WCS errors) (default True).</p></li>
<li><p><strong>dtype</strong> – (Optional) Data is converted to
the given dtype (e.g. np.float32, default float).</p></li>
<li><p><strong>mask_path</strong> – (Optional) Path to the corresponding mask image.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Please refer to
<a class="reference external" href="http://www.stsci.edu/institute/software_hardware/pyfits/">http://www.stsci.edu/institute/software_hardware/pyfits/</a> for
more information on PyFITS module. And
<a class="reference external" href="http://fits.gsfc.nasa.gov/">http://fits.gsfc.nasa.gov/</a> for more information on FITS
files.</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.io.read_hdf5">
<code class="sig-prename descclassname">orb.utils.io.</code><code class="sig-name descname">read_hdf5</code><span class="sig-paren">(</span><em class="sig-param">file_path</em>, <em class="sig-param">return_header=False</em>, <em class="sig-param">dtype=&lt;class 'float'&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.io.read_hdf5" title="Permalink to this definition">¶</a></dt>
<dd><p>Read an HDF5 data file created with
<code class="xref py py-meth docutils literal notranslate"><span class="pre">core.Tools.write_hdf5()</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file_path</strong> – Path to the file, can be either
relative or absolute.</p></li>
<li><p><strong>return_header</strong> – (Optional) If True return a tuple (data,
header) (default False).</p></li>
<li><p><strong>dtype</strong> – (Optional) Data is converted to the given type
(e.g. np.float32, default float).</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Please refer to <a class="reference external" href="http://www.h5py.org/">http://www.h5py.org/</a>.</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.io.read_sitelle_chip">
<code class="sig-prename descclassname">orb.utils.io.</code><code class="sig-name descname">read_sitelle_chip</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">hdu</span></em>, <em class="sig-param"><span class="n">chip_index</span></em>, <em class="sig-param"><span class="n">substract_bias</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.io.read_sitelle_chip" title="Permalink to this definition">¶</a></dt>
<dd><p>Return chip data of a SITELLE FITS image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>hdu</strong> – pyfits.HDU Instance of the SITELLE image</p></li>
<li><p><strong>chip_index</strong> – Index of the chip to read. Must be 1 or 2.</p></li>
<li><p><strong>substract_bias</strong> – If True bias is automatically
substracted by using the overscan area (default True).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.io.read_spiomm_data">
<code class="sig-prename descclassname">orb.utils.io.</code><code class="sig-name descname">read_spiomm_data</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">hdu</span></em>, <em class="sig-param"><span class="n">image_path</span></em>, <em class="sig-param"><span class="n">substract_bias</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.io.read_spiomm_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Return data of an SpIOMM FITS image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>hdu</strong> – pyfits.HDU Instance of the SpIOMM image</p></li>
<li><p><strong>image_path</strong> – Image path</p></li>
<li><p><strong>substract_bias</strong> – If True bias is automatically
substracted by using the associated bias frame as an
overscan frame. Mean bias level is thus computed along the y
axis of the bias frame (default True).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.io.read_votable">
<code class="sig-prename descclassname">orb.utils.io.</code><code class="sig-name descname">read_votable</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">votable_file</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.io.read_votable" title="Permalink to this definition">¶</a></dt>
<dd><p>read a votable and transfer it as as pandas dataframe.</p>
<p>taken from <a class="reference external" href="https://gist.github.com/icshih/52ca49eb218a2d5b660ee4a653301b2b">https://gist.github.com/icshih/52ca49eb218a2d5b660ee4a653301b2b</a></p>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.io.save_dflist">
<code class="sig-prename descclassname">orb.utils.io.</code><code class="sig-name descname">save_dflist</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dflist</span></em>, <em class="sig-param"><span class="n">path</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.io.save_dflist" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a list of dataframes</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dflist</strong> – list of pandas dataframes</p></li>
<li><p><strong>path</strong> – path to the output file</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.io.save_starlist">
<code class="sig-prename descclassname">orb.utils.io.</code><code class="sig-name descname">save_starlist</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">path</span></em>, <em class="sig-param"><span class="n">starlist</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.io.save_starlist" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a star list as a two columnfile X, Y readable by ds9</p>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.io.write_fits">
<code class="sig-prename descclassname">orb.utils.io.</code><code class="sig-name descname">write_fits</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fits_path</span></em>, <em class="sig-param"><span class="n">fits_data</span></em>, <em class="sig-param"><span class="n">fits_header</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">silent</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">overwrite</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">mask</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">replace</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">record_stats</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">mask_path</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.io.write_fits" title="Permalink to this definition">¶</a></dt>
<dd><p>Write data in FITS format. If the file doesn’t exist create
it with its directories.</p>
<p>If the file already exists add a number to its name before the
extension (unless ‘overwrite’ option is set to True).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fits_path</strong> – Path to the file, can be either
relative or absolut.</p></li>
<li><p><strong>fits_data</strong> – Data to be written in the file.</p></li>
<li><p><strong>fits_header</strong> – (Optional) Optional keywords to update or
create. It can be a pyfits.Header() instance or a list of
tuples [(KEYWORD_1, VALUE_1, COMMENT_1), (KEYWORD_2,
VALUE_2, COMMENT_2), …]. Standard keywords like SIMPLE,
BITPIX, NAXIS, EXTEND does not have to be passed.</p></li>
<li><p><strong>silent</strong> – (Optional) If True turn this function won’t
display any message (default False)</p></li>
<li><p><strong>overwrite</strong> – (Optional) If True overwrite the output file
if it exists (default True).</p></li>
<li><p><strong>mask</strong> – (Optional) It not None must be an array with the
same size as the given data but filled with ones and
zeros. Bad values (NaN or Inf) are converted to 1 and the
array is converted to 8 bit unsigned integers (uint8). This
array will be written to the disk with the same path
terminated by ‘_mask’. The header of the mask FITS file will
be the same as the original data (default None).</p></li>
<li><p><strong>replace</strong> – (Optional) If True and if the file already
exist, new data replace old data in the existing file. NaN
values do not replace old values. Other values replace old
values. New array MUST have the same size as the existing
array. Note that if replace is True, overwrite is
automatically set to True.</p></li>
<li><p><strong>record_stats</strong> – (Optional) If True, record mean and
median of data. Useful if they often have to be computed
(default False).</p></li>
<li><p><strong>mask_path</strong> – (Optional) Path to the corresponding mask image.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>float64 data is converted to float32 data to avoid
too big files with unnecessary precision</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Please refer to
<a class="reference external" href="http://www.stsci.edu/institute/software_hardware/pyfits/">http://www.stsci.edu/institute/software_hardware/pyfits/</a> for
more information on PyFITS module and
<a class="reference external" href="http://fits.gsfc.nasa.gov/">http://fits.gsfc.nasa.gov/</a> for more information on FITS
files.</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.io.write_hdf5">
<code class="sig-prename descclassname">orb.utils.io.</code><code class="sig-name descname">write_hdf5</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">file_path</span></em>, <em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">header</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">silent</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">overwrite</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">max_hdu_check</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">compress</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.io.write_hdf5" title="Permalink to this definition">¶</a></dt>
<dd><p>Write data in HDF5 format.</p>
<p>A header can be added to the data. This method is useful to
handle an HDF5 data file like a FITS file. It implements most
of the functionality of the method
<code class="xref py py-meth docutils literal notranslate"><span class="pre">core.Tools.write_fits()</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The output HDF5 file can contain mutiple data header
units (HDU). Each HDU is in a specific group named ‘hdu*’, *
being the index of the HDU. The first HDU is named
HDU0. Each HDU contains one data group (HDU*/data) which
contains a numpy.ndarray and one header group
(HDU*/header). Each subgroup of a header group is a keyword
and its associated value, comment and type.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file_path</strong> – Path to the HDF5 file to create</p></li>
<li><p><strong>data</strong> – A numpy array (numpy.ndarray instance) of numeric
values. If a list of arrays is given, each array will be
placed in a specific HDU. The header keyword must also be
set to a list of headers of the same length.</p></li>
<li><p><strong>header</strong> – (Optional) Optional keywords to update or
create. It can be a pyfits.Header() instance or a list of
tuples [(KEYWORD_1, VALUE_1, COMMENT_1), (KEYWORD_2,
VALUE_2, COMMENT_2), …]. Standard keywords like SIMPLE,
BITPIX, NAXIS, EXTEND does not have to be passed (default
None). It can also be a list of headers if a list of arrays
has been passed to the option ‘data’.</p></li>
<li><p><strong>max_hdu_check</strong> – (Optional): When True, if the input data
is a list (interpreted as a list of data unit), check if
it’s length is not too long to make sure that the input list
is not a single data array that has not been converted to a
numpy.ndarray format. If the number of HDU to create is
indeed very long this can be set to False (default True).</p></li>
<li><p><strong>silent</strong> – (Optional) If True turn this function won’t
display any message (default False)</p></li>
<li><p><strong>overwrite</strong> – (Optional) If True overwrite the output file
if it exists (default True).</p></li>
<li><p><strong>compress</strong> – (Optional) If True data is compressed using
the SZIP library (see
<a class="reference external" href="https://www.hdfgroup.org/doc_resource/SZIP/">https://www.hdfgroup.org/doc_resource/SZIP/</a>). SZIP library
must be installed (default False).</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Please refer to <a class="reference external" href="http://www.h5py.org/">http://www.h5py.org/</a>.</p>
</div>
</dd></dl>

</div>
<div class="section" id="module-orb.utils.log">
<span id="orb-utils-log-module"></span><h2>orb.utils.log module<a class="headerlink" href="#module-orb.utils.log" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="orb.utils.log.print_caller_traceback">
<code class="sig-prename descclassname">orb.utils.log.</code><code class="sig-name descname">print_caller_traceback</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.log.print_caller_traceback" title="Permalink to this definition">¶</a></dt>
<dd><p>Print the traceback of the calling function.</p>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.log.setup_socket_logging">
<code class="sig-prename descclassname">orb.utils.log.</code><code class="sig-name descname">setup_socket_logging</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.log.setup_socket_logging" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-orb.utils.misc">
<span id="orb-utils-misc-module"></span><h2>orb.utils.misc module<a class="headerlink" href="#module-orb.utils.misc" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="orb.utils.misc.aggregate_pixels">
<code class="sig-prename descclassname">orb.utils.misc.</code><code class="sig-name descname">aggregate_pixels</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pixel_list</span></em>, <em class="sig-param"><span class="n">radius</span><span class="o">=</span><span class="default_value">1.42</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.misc.aggregate_pixels" title="Permalink to this definition">¶</a></dt>
<dd><p>Aggregate neighbouring pixels into a set of sources. Two
neighbours are found if there distance is smaller than a given
radius (in pixels).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pixel_list</strong> – A list of pixel position as returned by a
function like numpy.nonzero.</p></li>
<li><p><strong>radius</strong> – (Optional) Max separation between two pixels of the
same source (default 1.42).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A list of pixel list. Each item of the list corresponds
to a source and each source is itself a list of pixel positions
(x,y).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.misc.compute_obs_params">
<code class="sig-prename descclassname">orb.utils.misc.</code><code class="sig-name descname">compute_obs_params</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">nm_min_filter</span></em>, <em class="sig-param"><span class="n">nm_max_filter</span></em>, <em class="sig-param"><span class="n">theta_min</span><span class="o">=</span><span class="default_value">5.01</span></em>, <em class="sig-param"><span class="n">theta_max</span><span class="o">=</span><span class="default_value">11.28</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.misc.compute_obs_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute observation parameters (order, step size) given the
filter bandpass.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nm_min_filter</strong> – Min wavelength of the filter in nm.</p></li>
<li><p><strong>nm_max_filter</strong> – Max wavelength of the filter in nm.</p></li>
<li><p><strong>theta_min</strong> – (Optional) Min angle of the detector (default
5.01).</p></li>
<li><p><strong>theta_max</strong> – (Optional) Max angle of the detector (default
11.28).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A tuple (order, step size, max wavelength)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.misc.convert_camera_parameter">
<code class="sig-prename descclassname">orb.utils.misc.</code><code class="sig-name descname">convert_camera_parameter</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">param</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.misc.convert_camera_parameter" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert camera parameter to an integer value</p>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.misc.correct_bad_frames_vector">
<code class="sig-prename descclassname">orb.utils.misc.</code><code class="sig-name descname">correct_bad_frames_vector</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">bad_frames_vector</span></em>, <em class="sig-param"><span class="n">dimz</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.misc.correct_bad_frames_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove bad indexes of the bad frame vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bad_frames_vector</strong> – The vector of indexes to correct</p></li>
<li><p><strong>dimz</strong> – Dimension of the cube along the 3rd axis.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.misc.find">
<code class="sig-prename descclassname">orb.utils.misc.</code><code class="sig-name descname">find</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pattern</span></em>, <em class="sig-param"><span class="n">path</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.misc.find" title="Permalink to this definition">¶</a></dt>
<dd><p>Find a file from a pattern at a given path
<a class="reference external" href="https://stackoverflow.com/questions/1724693/find-a-file-in-python">https://stackoverflow.com/questions/1724693/find-a-file-in-python</a></p>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.misc.get_axis_from_hdr">
<code class="sig-prename descclassname">orb.utils.misc.</code><code class="sig-name descname">get_axis_from_hdr</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">hdr</span></em>, <em class="sig-param"><span class="n">axis_index</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.misc.get_axis_from_hdr" title="Permalink to this definition">¶</a></dt>
<dd><p>Return axis from a classic FITS header</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>hdr</strong> – FITS header</p></li>
<li><p><strong>axis_index</strong> – (Optional) Index of the axis to retrieve
(default 1)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.misc.get_cfht_odometer">
<code class="sig-prename descclassname">orb.utils.misc.</code><code class="sig-name descname">get_cfht_odometer</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">path</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.misc.get_cfht_odometer" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the odometer of a cfht FITS file from its path.</p>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.misc.get_mask_from_ds9_region_file">
<code class="sig-prename descclassname">orb.utils.misc.</code><code class="sig-name descname">get_mask_from_ds9_region_file</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">reg_path</span></em>, <em class="sig-param"><span class="n">x_range</span></em>, <em class="sig-param"><span class="n">y_range</span></em>, <em class="sig-param"><span class="n">integrate</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">header</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.misc.get_mask_from_ds9_region_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a mask from a ds9 region file or from a ds9-like region
string.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reg_path</strong> – Path to a ds9 region file or ds9-like region string</p></li>
<li><p><strong>x_range</strong> – Range of x image coordinates
considered as valid. Pixels outside this range are
rejected..</p></li>
<li><p><strong>y_range</strong> – Range of y image coordinates
considered as valid. Pixels outside this range are
rejected.</p></li>
<li><p><strong>integrate</strong> – (Optional) If True, all pixels are integrated
into one mask, else a list of region masks is returned (default
True)</p></li>
<li><p><strong>header</strong> – (Optional) Header containing the WCS transformation
if the region file is in celestial coordinates (default None).</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The returned array can be used like a list of
indices returned by e.g. numpy.nonzero().</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Coordinates can be celestial or image coordinates
(x,y). if coordinates are celestial a header must be passed to
the function.</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.misc.read_instrument_value_from_file">
<code class="sig-prename descclassname">orb.utils.misc.</code><code class="sig-name descname">read_instrument_value_from_file</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">path</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.misc.read_instrument_value_from_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the instrument value form an hdf5/fits file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>path</strong> – path to an hdf5/fits file.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.misc.restore_error_settings">
<code class="sig-prename descclassname">orb.utils.misc.</code><code class="sig-name descname">restore_error_settings</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">old_settings</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.misc.restore_error_settings" title="Permalink to this definition">¶</a></dt>
<dd><p>Restore old floating point error settings of numpy.</p>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.misc.sort_image_list">
<code class="sig-prename descclassname">orb.utils.misc.</code><code class="sig-name descname">sort_image_list</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">file_list</span></em>, <em class="sig-param"><span class="n">image_mode</span></em>, <em class="sig-param"><span class="n">cube</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.misc.sort_image_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Sort a list of fits files.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file_list</strong> – A list of file names</p></li>
<li><p><strong>image_mode</strong> – Image mode, can be ‘sitelle’ or ‘spiomm’.</p></li>
<li><p><strong>cube</strong> – If True, image list is considered as a cube
list. Headers are used to get the right order based on step
number instead of file path (default True).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-orb.utils.parallel">
<span id="orb-utils-parallel-module"></span><h2>orb.utils.parallel module<a class="headerlink" href="#module-orb.utils.parallel" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="orb.utils.parallel.Job">
<em class="property">class </em><code class="sig-prename descclassname">orb.utils.parallel.</code><code class="sig-name descname">Job</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">job</span></em>, <em class="sig-param"><span class="n">timeout</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.parallel.Job" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
</dd></dl>

<dl class="py class">
<dt id="orb.utils.parallel.JobServer">
<em class="property">class </em><code class="sig-prename descclassname">orb.utils.parallel.</code><code class="sig-name descname">JobServer</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ncpus</span></em>, <em class="sig-param"><span class="n">timeout</span><span class="o">=</span><span class="default_value">100</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.parallel.JobServer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py method">
<dt id="orb.utils.parallel.JobServer.submit">
<code class="sig-name descname">submit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">func</span></em>, <em class="sig-param"><span class="n">args</span><span class="o">=</span><span class="default_value">()</span></em>, <em class="sig-param"><span class="n">modules</span><span class="o">=</span><span class="default_value">()</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.parallel.JobServer.submit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt id="orb.utils.parallel.RayJob">
<em class="property">class </em><code class="sig-prename descclassname">orb.utils.parallel.</code><code class="sig-name descname">RayJob</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">job</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.parallel.RayJob" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
</dd></dl>

<dl class="py class">
<dt id="orb.utils.parallel.RayJobServer">
<em class="property">class </em><code class="sig-prename descclassname">orb.utils.parallel.</code><code class="sig-name descname">RayJobServer</code><a class="headerlink" href="#orb.utils.parallel.RayJobServer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py method">
<dt id="orb.utils.parallel.RayJobServer.submit">
<code class="sig-name descname">submit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">func</span></em>, <em class="sig-param"><span class="n">args</span><span class="o">=</span><span class="default_value">()</span></em>, <em class="sig-param"><span class="n">modules</span><span class="o">=</span><span class="default_value">()</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.parallel.RayJobServer.submit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt id="orb.utils.parallel.apply_async">
<code class="sig-prename descclassname">orb.utils.parallel.</code><code class="sig-name descname">apply_async</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pool</span></em>, <em class="sig-param"><span class="n">fun</span></em>, <em class="sig-param"><span class="n">args</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.parallel.apply_async" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="orb.utils.parallel.close_pp_server">
<code class="sig-prename descclassname">orb.utils.parallel.</code><code class="sig-name descname">close_pp_server</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">js</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.parallel.close_pp_server" title="Permalink to this definition">¶</a></dt>
<dd><p>Destroy the parallel python job server to avoid too much
opened files.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>js</strong> – job server.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Please refer to <a class="reference external" href="http://www.parallelpython.com/">http://www.parallelpython.com/</a> for
sources and information on Parallel Python software.</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.parallel.get_ncpus">
<code class="sig-prename descclassname">orb.utils.parallel.</code><code class="sig-name descname">get_ncpus</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ncpus</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.parallel.get_ncpus" title="Permalink to this definition">¶</a></dt>
<dd><p>Return ncpus considering the target ncpus and the hard limits setting</p>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.parallel.get_stats_str">
<code class="sig-prename descclassname">orb.utils.parallel.</code><code class="sig-name descname">get_stats_str</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">js</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.parallel.get_stats_str" title="Permalink to this definition">¶</a></dt>
<dd><p>Return job server statistics as a string</p>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.parallel.init_pp_server">
<code class="sig-prename descclassname">orb.utils.parallel.</code><code class="sig-name descname">init_pp_server</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ncpus</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">silent</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">use_ray</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">timeout</span><span class="o">=</span><span class="default_value">100</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.parallel.init_pp_server" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a server for parallel processing.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ncpus</strong> – (Optional) Number of cpus to use. 0 means use all
available cpus (default 0)</p></li>
<li><p><strong>silent</strong> – (Optional) If silent no message is printed
(Default False).</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Please refer to <a class="reference external" href="http://www.parallelpython.com/">http://www.parallelpython.com/</a> for
sources and information on Parallel Python software</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.parallel.run_dill_encoded">
<code class="sig-prename descclassname">orb.utils.parallel.</code><code class="sig-name descname">run_dill_encoded</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">payload</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.parallel.run_dill_encoded" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="orb.utils.parallel.timed_process">
<code class="sig-prename descclassname">orb.utils.parallel.</code><code class="sig-name descname">timed_process</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">func</span></em>, <em class="sig-param"><span class="n">timeout</span></em>, <em class="sig-param"><span class="n">args</span><span class="o">=</span><span class="default_value">[]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.parallel.timed_process" title="Permalink to this definition">¶</a></dt>
<dd><p>Run a timed process which terminates after timeout seconds if it
does not return before.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>func</strong> – Timed func which will be terminated after timeout
seconds. must be func(<a href="#id3"><span class="problematic" id="id4">*</span></a>args, returned_dict). The
results of the function must be put in returned_dict.</p></li>
<li><p><strong>timeout</strong> – Timeout in s.</p></li>
<li><p><strong>args</strong> – arguments of the function</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>returned_dict</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>from <a class="reference external" href="https://stackoverflow.com/questions/492519/timeout-on-a-function-call">https://stackoverflow.com/questions/492519/timeout-on-a-function-call</a></p>
</div>
</dd></dl>

</div>
<div class="section" id="module-orb.utils.photometry">
<span id="orb-utils-photometry-module"></span><h2>orb.utils.photometry module<a class="headerlink" href="#module-orb.utils.photometry" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="orb.utils.photometry.ABmag2flambda">
<code class="sig-prename descclassname">orb.utils.photometry.</code><code class="sig-name descname">ABmag2flambda</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ABmag</span></em>, <em class="sig-param"><span class="n">lam</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.ABmag2flambda" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert AB magnitude to flux in erg/cm2/s/A</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ABmag</strong> – A magnitude in the AB magnitude system</p></li>
<li><p><strong>lam</strong> – Wavelength in angstrom</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.photometry.ABmag2fnu">
<code class="sig-prename descclassname">orb.utils.photometry.</code><code class="sig-name descname">ABmag2fnu</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ABmag</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.ABmag2fnu" title="Permalink to this definition">¶</a></dt>
<dd><p>Return flux in erg/cm2/s/Hz from AB magnitude (Oke, ApJS, 27,
21, 1974)</p>
<p>ABmag = -2.5 * log10(f_nu) - 48.60
f_nu = 10^(-0.4 * (ABmag + 48.60))</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>ABmag</strong> – A magnitude in the AB magnitude system</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Definition of the zero-point can change and be
e.g. 48.59 for Oke standard stars (Hamuy et al., PASP, 104, 533,
1992). This is the case for Spectrophotometric Standards given
on the ESO website (<a class="reference external" href="https://www.eso.org/sci/observing/tools/standards/spectra/okestandards.html">https://www.eso.org/sci/observing/tools/standards/spectra/okestandards.html</a>). Here the HST definition is used.</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.photometry.compute_equivalent_bandwidth">
<code class="sig-prename descclassname">orb.utils.photometry.</code><code class="sig-name descname">compute_equivalent_bandwidth</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">nm_axis</span></em>, <em class="sig-param"><span class="n">filter_transmission</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.compute_equivalent_bandwidth" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the equivalent bandwidth of a given filter.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nm_axis</strong> – Filter transmission axis in nm.</p></li>
<li><p><strong>filter_transmission</strong> – Filter transmission curve</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.photometry.compute_flux_calibration_vector">
<code class="sig-prename descclassname">orb.utils.photometry.</code><code class="sig-name descname">compute_flux_calibration_vector</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">re_spectrum</span></em>, <em class="sig-param"><span class="n">th_spectrum</span></em>, <em class="sig-param"><span class="n">std_step</span></em>, <em class="sig-param"><span class="n">std_order</span></em>, <em class="sig-param"><span class="n">std_exp_time</span></em>, <em class="sig-param"><span class="n">std_corr</span></em>, <em class="sig-param"><span class="n">filter_min_pix</span></em>, <em class="sig-param"><span class="n">filter_max_pix</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.compute_flux_calibration_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the flux calibration vector from an observed spectrum
and the standard spectrum.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>re_spectrum</strong> – Observed spectrum in wavenumber.</p></li>
<li><p><strong>th_spectrum</strong> – standard spectrum (in erg/cm2/s/A) in wavenumber.</p></li>
<li><p><strong>std_step</strong> – Standard step size (in nm)</p></li>
<li><p><strong>std_order</strong> – Standard folding order</p></li>
<li><p><strong>std_exp_time</strong> – Standard Exposition time</p></li>
<li><p><strong>std_corr</strong> – Standard Correction coeff.</p></li>
<li><p><strong>filter_min_pix</strong> – Filter min position in pixels</p></li>
<li><p><strong>filter_max_pix</strong> – Filter max position in pixels</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.photometry.compute_mean_photon_energy">
<code class="sig-prename descclassname">orb.utils.photometry.</code><code class="sig-name descname">compute_mean_photon_energy</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">nm_axis</span></em>, <em class="sig-param"><span class="n">filter_transmission</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.compute_mean_photon_energy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return mean energy of the photons passing thourgh a given
filter (in erg).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nm_axis</strong> – Filter transmission axis in nm.</p></li>
<li><p><strong>filter_transmission</strong> – Filter transmission curve</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.photometry.compute_mean_star_flux">
<code class="sig-prename descclassname">orb.utils.photometry.</code><code class="sig-name descname">compute_mean_star_flux</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">star_spectrum</span></em>, <em class="sig-param"><span class="n">filter_transmission</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.compute_mean_star_flux" title="Permalink to this definition">¶</a></dt>
<dd><p>Return mean star flux given a spectrum and the filter. Both
files must be given along the same wavelength/wavenumber axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>star_spectrum</strong> – Spectrum of the star</p></li>
<li><p><strong>filter_transmission</strong> – Filter transmission curve</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.photometry.compute_optimal_texp">
<code class="sig-prename descclassname">orb.utils.photometry.</code><code class="sig-name descname">compute_optimal_texp</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">star_flux</span></em>, <em class="sig-param"><span class="n">seeing</span></em>, <em class="sig-param"><span class="n">plate_scale</span></em>, <em class="sig-param"><span class="n">saturation</span><span class="o">=</span><span class="default_value">30000</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.compute_optimal_texp" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the optimal exposure time given the total flux of the
star in ADU/s.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>star_flux</strong> – Total star flux in ADU/s</p></li>
<li><p><strong>seeing</strong> – Star FWHM in arcsec</p></li>
<li><p><strong>plate_scale</strong> – Size of 1 pixel in arcsec.</p></li>
<li><p><strong>saturation</strong> – (Optional) Saturation value (default 30000).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.photometry.compute_photon_energy">
<code class="sig-prename descclassname">orb.utils.photometry.</code><code class="sig-name descname">compute_photon_energy</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">nm_axis</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.compute_photon_energy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the photon energy (in erg) computed for all the wavelength along
a given wavelength axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>nm_axis</strong> – Wavelength axis in nm</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.photometry.compute_star_central_pixel_value">
<code class="sig-prename descclassname">orb.utils.photometry.</code><code class="sig-name descname">compute_star_central_pixel_value</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">seeing</span></em>, <em class="sig-param"><span class="n">plate_scale</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.compute_star_central_pixel_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the relative value of the pixel containing the greatest
proportion of the flux (central pixel) of Gaussian star.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>seeing</strong> – Star FWHM in arcsec</p></li>
<li><p><strong>plate_scale</strong> – Size of the pixels in arcsec.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.photometry.convert_cm1_flux2fluxdensity">
<code class="sig-prename descclassname">orb.utils.photometry.</code><code class="sig-name descname">convert_cm1_flux2fluxdensity</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">cm1_axis</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.convert_cm1_flux2fluxdensity" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a spectrum in X/s to X/s/A (X may be ADU or erg/cm^2)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> – spectrum</p></li>
<li><p><strong>cm1_axis</strong> – Axis of the spectrum in cm-1</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.photometry.ext2trans">
<code class="sig-prename descclassname">orb.utils.photometry.</code><code class="sig-name descname">ext2trans</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ext</span></em>, <em class="sig-param"><span class="n">airmass</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.ext2trans" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert extinction to transmission</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ext</strong> – extinction</p></li>
<li><p><strong>airmass</strong> – airmass</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.photometry.fit_std_spectrum">
<code class="sig-prename descclassname">orb.utils.photometry.</code><code class="sig-name descname">fit_std_spectrum</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">real_spectrum</span></em>, <em class="sig-param"><span class="n">std_spectrum</span></em>, <em class="sig-param"><span class="n">polydeg</span><span class="o">=</span><span class="default_value">2</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.fit_std_spectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit a real spectrum multiplied by a polynomial over a standard
spectrum.</p>
<p>Return the polynomial which can be used directly as a calibration
curve.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>real_spectrum</strong> – Observed spectrum</p></li>
<li><p><strong>std_spectrum</strong> – Standard spectrum</p></li>
<li><p><strong>polydeg</strong> – Degree of the polynomial</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.photometry.flambda2ABmag">
<code class="sig-prename descclassname">orb.utils.photometry.</code><code class="sig-name descname">flambda2ABmag</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">flambda</span></em>, <em class="sig-param"><span class="n">lam</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.flambda2ABmag" title="Permalink to this definition">¶</a></dt>
<dd><p>Return AB magnitude from flux in erg/cm2/s/A</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>flambda</strong> – Flux in erg/cm2/s/A. Can be an array.</p></li>
<li><p><strong>lambda</strong> – Wavelength in A of the Flux. If flambda is an array
lambda must have the same shape.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.photometry.fnu2flambda">
<code class="sig-prename descclassname">orb.utils.photometry.</code><code class="sig-name descname">fnu2flambda</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fnu</span></em>, <em class="sig-param"><span class="n">nu</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.fnu2flambda" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a flux in erg/cm2/s/Hz to a flux in erg/cm2/s/A</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fnu</strong> – Flux in erg/cm2/s/Hz</p></li>
<li><p><strong>nu</strong> – frequency in Hz</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.photometry.lambda2nu">
<code class="sig-prename descclassname">orb.utils.photometry.</code><code class="sig-name descname">lambda2nu</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">lam</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.lambda2nu" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert lambda in Ang to nu in Hz</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>lam</strong> – Wavelength in angstrom</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.photometry.modulation_efficiency_opd_jitter">
<code class="sig-prename descclassname">orb.utils.photometry.</code><code class="sig-name descname">modulation_efficiency_opd_jitter</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cm1</span></em>, <em class="sig-param"><span class="n">opd_jitter</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.modulation_efficiency_opd_jitter" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the ME given the OPD jitter</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cm1</strong> – wavenumber in cm-1</p></li>
<li><p><strong>opd_jitter</strong> – OPD jitter in nm (standard deviation)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.photometry.modulation_efficiency_wavefront_error">
<code class="sig-prename descclassname">orb.utils.photometry.</code><code class="sig-name descname">modulation_efficiency_wavefront_error</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cm1</span></em>, <em class="sig-param"><span class="n">wferr</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.modulation_efficiency_wavefront_error" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the ME given the OPD jitter</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cm1</strong> – wavenumber in cm-1</p></li>
<li><p><strong>wferr</strong> – wavefront error ratio (e.g. 1/30.)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-orb.utils.sim">
<span id="orb-utils-sim-module"></span><h2>orb.utils.sim module<a class="headerlink" href="#module-orb.utils.sim" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="orb.utils.sim.fft">
<code class="sig-prename descclassname">orb.utils.sim.</code><code class="sig-name descname">fft</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">interf</span></em>, <em class="sig-param"><span class="n">zp_coeff</span><span class="o">=</span><span class="default_value">2</span></em>, <em class="sig-param"><span class="n">apod</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">phase</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.sim.fft" title="Permalink to this definition">¶</a></dt>
<dd><p>Basic Fourier Transform with zero-padding.</p>
<p>Useful to compute a quick assumption-less FFT.</p>
<p>ZPD is assumed to be on the first sample of the interferogram</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>interf</strong> – interferogram</p></li>
<li><p><strong>zp_coeff</strong> – Zero-padding coefficient (2 by default)</p></li>
<li><p><strong>apod</strong> – Apodization function</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>axis, complex interferogram FFT</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.sim.line_interf">
<code class="sig-prename descclassname">orb.utils.sim.</code><code class="sig-name descname">line_interf</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sigma</span></em>, <em class="sig-param"><span class="n">step_nb</span></em>, <em class="sig-param"><span class="n">phi</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">symm</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">jitter</span><span class="o">=</span><span class="default_value">0.0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.sim.line_interf" title="Permalink to this definition">¶</a></dt>
<dd><p>Simulate a simple line interferogram (a cosine)</p>
<p>ZPD is on the first sample of the returned interferogram.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sigma</strong> – line frequency (must be &lt; step_nb/2)</p></li>
<li><p><strong>step_nb</strong> – Length of the interferogram</p></li>
<li><p><strong>phi</strong> – (Optional) Phase of the line (in radians) (default 0).</p></li>
<li><p><strong>symm</strong> – (Optional) If True, returned spectrum is symmetric,
it has two times more steps - 1. Zpd position is equal to
step_nb - 0.5.</p></li>
<li><p><strong>jitter</strong> – (Optional) Std of an OPD jitter. Must be a float
between 0 and 1 (jitter distribution is normal, default 0.).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.sim.step_interf">
<code class="sig-prename descclassname">orb.utils.sim.</code><code class="sig-name descname">step_interf</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sigma_min</span></em>, <em class="sig-param"><span class="n">sigma_max</span></em>, <em class="sig-param"><span class="n">step_nb</span></em>, <em class="sig-param"><span class="n">symm</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.sim.step_interf" title="Permalink to this definition">¶</a></dt>
<dd><p>Simulate a step interferogram</p>
<p>ZPD is on the first sample of the returned interferogram.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sigma_ax</strong> – max frequency of the step (must be &lt; step_nb/2)</p></li>
<li><p><strong>step_nb</strong> – Length of the interferogram</p></li>
<li><p><strong>symm</strong> – (Optional) If True, returned spectrum is symmetric,
it has two times more steps - 1. Zpd position is equal to
step_nb - 0.5.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>results are much better with a symmetric interferogram
but ZPD is not on the first sample and the spectrum must thus be
phase corrected.</p>
</div>
</dd></dl>

</div>
<div class="section" id="module-orb.utils.spectrum">
<span id="orb-utils-spectrum-module"></span><h2>orb.utils.spectrum module<a class="headerlink" href="#module-orb.utils.spectrum" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="orb.utils.spectrum.amp_ratio_from_flux_ratio">
<code class="sig-prename descclassname">orb.utils.spectrum.</code><code class="sig-name descname">amp_ratio_from_flux_ratio</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">line0_cm1</span></em>, <em class="sig-param"><span class="n">line1_cm1</span></em>, <em class="sig-param"><span class="n">flux_ratio</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.amp_ratio_from_flux_ratio" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Return the amplitude ratio (amp(line0) / amp(line1)) from the flux</dt><dd><p>ratio (at constant fwhm and broadening).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>line0</strong> – Wavenumber of the line 0 (in cm-1).</p></li>
<li><p><strong>line1</strong> – Wavenumber of the line 1 (in cm-1).</p></li>
<li><p><strong>flux_ratio</strong> – Flux ratio: flux(line0) / flux(line1).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.spectrum.cm12nm">
<code class="sig-prename descclassname">orb.utils.spectrum.</code><code class="sig-name descname">cm12nm</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cm1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.cm12nm" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a wavenumber in cm-1 to a wavelength in nm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>cm1</strong> – wavenumber in cm-1</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.spectrum.cm12pix">
<code class="sig-prename descclassname">orb.utils.spectrum.</code><code class="sig-name descname">cm12pix</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cm1_axis</span></em>, <em class="sig-param"><span class="n">cm1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.cm12pix" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a wavenumber in cm-1 to a pixel position given an axis
in cm-1.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cm1_axis</strong> – Axis in cm-1</p></li>
<li><p><strong>cm1</strong> – Wavenumber in cm-1</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.spectrum.compute_line_fwhm">
<code class="sig-prename descclassname">orb.utils.spectrum.</code><code class="sig-name descname">compute_line_fwhm</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">step_nb</span></em>, <em class="sig-param"><span class="n">step</span></em>, <em class="sig-param"><span class="n">order</span></em>, <em class="sig-param"><span class="n">apod_coeff</span><span class="o">=</span><span class="default_value">1.0</span></em>, <em class="sig-param"><span class="n">corr</span><span class="o">=</span><span class="default_value">1.0</span></em>, <em class="sig-param"><span class="n">wavenumber</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.compute_line_fwhm" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the expected FWHM (in nm or in cm-1) of a line given the
observation parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>step_nb</strong> – Number of steps from the zpd to the longest side
of the interferogram.</p></li>
<li><p><strong>step</strong> – Step size in nm</p></li>
<li><p><strong>order</strong> – Folding order</p></li>
<li><p><strong>apod_coeff</strong> – (Optional) Apodization coefficient. 1. stands
for no apodization and gives the FWHM of the central lobe of the
sinc (default 1.)</p></li>
<li><p><strong>corr</strong> – (Optional) Coefficient of correction (default 1.)</p></li>
<li><p><strong>wavenumber</strong> – (Optional) If True the result is returned in cm-1,
else it is returned in nm.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.spectrum.compute_line_fwhm_pix">
<code class="sig-prename descclassname">orb.utils.spectrum.</code><code class="sig-name descname">compute_line_fwhm_pix</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">oversampling_ratio</span><span class="o">=</span><span class="default_value">1.0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.compute_line_fwhm_pix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the expected FWHM of an unapodized sinc line in pixels.</p>
<dl class="field-list simple">
<dt class="field-odd">Oversampling_ratio</dt>
<dd class="field-odd"><p>Ratio of the real number of steps of the
spectrum vs step_nb (must be &gt; 1.) For a two sided interferogram
the oversampling ratio is 2.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.spectrum.compute_mean_shift">
<code class="sig-prename descclassname">orb.utils.spectrum.</code><code class="sig-name descname">compute_mean_shift</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">velocity</span></em>, <em class="sig-param"><span class="n">step_nb</span></em>, <em class="sig-param"><span class="n">step</span></em>, <em class="sig-param"><span class="n">order</span></em>, <em class="sig-param"><span class="n">wavenumber</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.compute_mean_shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the mean shift at the central wavelength of the band
defined by step and order parameters given its velocity in nm or
in cm-1.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>velocity</strong> – Line velocity in km.s-1</p></li>
<li><p><strong>step_nb</strong> – Number of steps</p></li>
<li><p><strong>step</strong> – Step size in nm</p></li>
<li><p><strong>order</strong> – Folding order</p></li>
<li><p><strong>wavenumber</strong> – (Optional) If True the result is returned in cm-1,
else it is returned in nm.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.spectrum.compute_radial_velocity">
<code class="sig-prename descclassname">orb.utils.spectrum.</code><code class="sig-name descname">compute_radial_velocity</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">line</span></em>, <em class="sig-param"><span class="n">rest_line</span></em>, <em class="sig-param"><span class="n">wavenumber</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">relativistic</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.compute_radial_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Return relativistic radial velocity in km.s-1</p>
<p>V [km.s-1] = c [km.s-1]* (Lambda^2 / Lambda_0^2 - 1) / (Lambda^2 / Lambda_0^2 + 1)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>line</strong> – Emission line wavelength/wavenumber (can be a numpy
array)</p></li>
<li><p><strong>rest_line</strong> – Rest-frame wavelength/wavenumber (can be a numpy
array but must have the same size as line)</p></li>
<li><p><strong>wavenumber</strong> – (Optional) If True the result is returned in cm-1,
else it is returned in nm.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.spectrum.compute_resolution">
<code class="sig-prename descclassname">orb.utils.spectrum.</code><code class="sig-name descname">compute_resolution</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">step_nb</span></em>, <em class="sig-param"><span class="n">step</span></em>, <em class="sig-param"><span class="n">order</span></em>, <em class="sig-param"><span class="n">corr</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">sigma</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.compute_resolution" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the theoretical resolution of a given scan</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>step_nb</strong> – Number of steps of the longest side of the
interferogram.</p></li>
<li><p><strong>step</strong> – Step size (in nm)</p></li>
<li><p><strong>order</strong> – Folding order</p></li>
<li><p><strong>corr</strong> – Correction coefficient for the incident angle.</p></li>
<li><p><strong>sigma</strong> – Wavenumber at which the resolution is computed. If
None given, the central wavenumber in the bandpass is used. Note
that, when the incident angle changes, the bandpass is shifted
so that the computed resolution is the same at any inceident
angle if sigma is not fixed.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.spectrum.compute_step_nb">
<code class="sig-prename descclassname">orb.utils.spectrum.</code><code class="sig-name descname">compute_step_nb</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">resolution</span></em>, <em class="sig-param"><span class="n">step</span></em>, <em class="sig-param"><span class="n">order</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.compute_step_nb" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of steps on the longest side of the
interferogram given the resolution and the observation
parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>resolution</strong> – Resolution</p></li>
<li><p><strong>step</strong> – Step size (in nm)</p></li>
<li><p><strong>order</strong> – Folding order</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.spectrum.corr2theta">
<code class="sig-prename descclassname">orb.utils.spectrum.</code><code class="sig-name descname">corr2theta</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">corr</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.corr2theta" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the correction coefficient to an incident angle.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>corr</strong> – Correction coefficient</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.spectrum.create_cm1_axis">
<code class="sig-prename descclassname">orb.utils.spectrum.</code><code class="sig-name descname">create_cm1_axis</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n</span></em>, <em class="sig-param"><span class="n">step</span></em>, <em class="sig-param"><span class="n">order</span></em>, <em class="sig-param"><span class="n">corr</span><span class="o">=</span><span class="default_value">1.0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.create_cm1_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a regular wavenumber axis in cm-1.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> – Number of steps on the axis</p></li>
<li><p><strong>step</strong> – Step size in nm</p></li>
<li><p><strong>order</strong> – Folding order</p></li>
<li><p><strong>corr</strong> – (Optional) Coefficient of correction (default 1.)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.spectrum.create_nm_axis">
<code class="sig-prename descclassname">orb.utils.spectrum.</code><code class="sig-name descname">create_nm_axis</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n</span></em>, <em class="sig-param"><span class="n">step</span></em>, <em class="sig-param"><span class="n">order</span></em>, <em class="sig-param"><span class="n">corr</span><span class="o">=</span><span class="default_value">1.0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.create_nm_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a regular wavelength axis in nm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> – Number of steps on the axis</p></li>
<li><p><strong>step</strong> – Step size in nm</p></li>
<li><p><strong>order</strong> – Folding order (cannot be 0)</p></li>
<li><p><strong>corr</strong> – (Optional) Coefficient of correction (default 1.)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.spectrum.create_nm_axis_ireg">
<code class="sig-prename descclassname">orb.utils.spectrum.</code><code class="sig-name descname">create_nm_axis_ireg</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n</span></em>, <em class="sig-param"><span class="n">step</span></em>, <em class="sig-param"><span class="n">order</span></em>, <em class="sig-param"><span class="n">corr</span><span class="o">=</span><span class="default_value">1.0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.create_nm_axis_ireg" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an irregular wavelength axis from the regular wavenumber
axis in cm-1.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> – Number of steps on the axis</p></li>
<li><p><strong>step</strong> – Step size in nm</p></li>
<li><p><strong>order</strong> – Folding order (must be &gt; 0)</p></li>
<li><p><strong>corr</strong> – (Optional) Coefficient of correction (default 1.)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.spectrum.detect_velocity">
<code class="sig-prename descclassname">orb.utils.spectrum.</code><code class="sig-name descname">detect_velocity</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">spec</span></em>, <em class="sig-param"><span class="n">axis_cm1</span></em>, <em class="sig-param"><span class="n">lines_cm1</span></em>, <em class="sig-param"><span class="n">ncomps</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">vrange</span><span class="o">=</span><span class="default_value">1000</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.detect_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Detect velocity of different components in a spectrum.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>ncomps</strong> – maximum velocity components</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.spectrum.dsinc1d">
<code class="sig-prename descclassname">orb.utils.spectrum.</code><code class="sig-name descname">dsinc1d</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">h</span></em>, <em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">dx</span></em>, <em class="sig-param"><span class="n">fwhm</span></em>, <em class="sig-param"><span class="n">sigma</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.dsinc1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a 1D double sinc</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> – Array giving the positions where the function is evaluated</p></li>
<li><p><strong>h</strong> – Height</p></li>
<li><p><strong>a</strong> – Amplitude</p></li>
<li><p><strong>dx</strong> – Position of the center</p></li>
<li><p><strong>fwhm</strong> – FWHM</p></li>
<li><p><strong>sigma</strong> – broadening</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.spectrum.fast_pix2w">
<code class="sig-prename descclassname">orb.utils.spectrum.</code><code class="sig-name descname">fast_pix2w</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pix</span></em>, <em class="sig-param"><span class="n">axis_min</span></em>, <em class="sig-param"><span class="n">axis_step</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.fast_pix2w" title="Permalink to this definition">¶</a></dt>
<dd><p>Fast conversion of pixel to wavelength/wavenumber</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pix</strong> – position along axis in pixels</p></li>
<li><p><strong>axis_min</strong> – min axis wavelength/wavenumber</p></li>
<li><p><strong>axis_step</strong> – axis step size in wavelength/wavenumber</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.spectrum.fast_w2pix">
<code class="sig-prename descclassname">orb.utils.spectrum.</code><code class="sig-name descname">fast_w2pix</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">w</span></em>, <em class="sig-param"><span class="n">axis_min</span></em>, <em class="sig-param"><span class="n">axis_step</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.fast_w2pix" title="Permalink to this definition">¶</a></dt>
<dd><p>Fast conversion of wavelength/wavenumber to pixel</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>w</strong> – wavelength/wavenumber</p></li>
<li><p><strong>axis_min</strong> – min axis wavelength/wavenumber</p></li>
<li><p><strong>axis_step</strong> – axis step size in wavelength/wavenumber</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.spectrum.fwhm_cm12nm">
<code class="sig-prename descclassname">orb.utils.spectrum.</code><code class="sig-name descname">fwhm_cm12nm</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fwhm_cm1</span></em>, <em class="sig-param"><span class="n">cm1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.fwhm_cm12nm" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a FWHM in cm-1 to a FWHM in nm.</p>
<p>The central wavelength in cm-1 of the line must also be given</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fwhm_cm1</strong> – FWHM in cm-1</p></li>
<li><p><strong>cm1</strong> – Wavelength in cm-1 where the FWHM is evaluated</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.spectrum.fwhm_nm2cm1">
<code class="sig-prename descclassname">orb.utils.spectrum.</code><code class="sig-name descname">fwhm_nm2cm1</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fwhm_nm</span></em>, <em class="sig-param"><span class="n">nm</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.fwhm_nm2cm1" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a FWHM in nm to a FWHM in cm-1.</p>
<p>The central wavelength in nm of the line must also be given</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fwhm_nm</strong> – FWHM in nm</p></li>
<li><p><strong>nm</strong> – Wavelength in nm where the FWHM is evaluated</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.spectrum.gaussian1d">
<code class="sig-prename descclassname">orb.utils.spectrum.</code><code class="sig-name descname">gaussian1d</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">h</span></em>, <em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">dx</span></em>, <em class="sig-param"><span class="n">fwhm</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.gaussian1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a 1D gaussian given a set of parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> – Array giving the positions where the gaussian is evaluated</p></li>
<li><p><strong>h</strong> – Height</p></li>
<li><p><strong>a</strong> – Amplitude</p></li>
<li><p><strong>dx</strong> – Position of the center</p></li>
<li><p><strong>fwhm</strong> – FWHM, <span class="math notranslate nohighlight">\(\text{FWHM} = \text{Width} \times 2 \sqrt{2 \ln 2}\)</span></p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.spectrum.gaussian1d_complex">
<code class="sig-prename descclassname">orb.utils.spectrum.</code><code class="sig-name descname">gaussian1d_complex</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">h</span></em>, <em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">dx</span></em>, <em class="sig-param"><span class="n">fwhm</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.gaussian1d_complex" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a 1D gaussian given a set of parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> – Array giving the positions where the gaussian is evaluated</p></li>
<li><p><strong>h</strong> – Height</p></li>
<li><p><strong>a</strong> – Amplitude</p></li>
<li><p><strong>dx</strong> – Position of the center</p></li>
<li><p><strong>fwhm</strong> – FWHM, <span class="math notranslate nohighlight">\(\text{FWHM} = \text{Width} \times 2 \sqrt{2 \ln 2}\)</span></p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.spectrum.gaussian1d_flux">
<code class="sig-prename descclassname">orb.utils.spectrum.</code><code class="sig-name descname">gaussian1d_flux</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">fwhm</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.gaussian1d_flux" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute flux of a 1D Gaussian.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> – Amplitude</p></li>
<li><p><strong>fwhm</strong> – FWHM</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.spectrum.guess_snr">
<code class="sig-prename descclassname">orb.utils.spectrum.</code><code class="sig-name descname">guess_snr</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">calib_spectrum</span></em>, <em class="sig-param"><span class="n">flambda</span></em>, <em class="sig-param"><span class="n">exp_time</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.guess_snr" title="Permalink to this definition">¶</a></dt>
<dd><p>Guess calibrated spectrum snr</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>calib_spectrum</strong> – Calibrated spectrum</p></li>
<li><p><strong>flambda</strong> – Calibration FLAMBDA</p></li>
<li><p><strong>exp_time</strong> – Exposure time by step</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.spectrum.line_shift">
<code class="sig-prename descclassname">orb.utils.spectrum.</code><code class="sig-name descname">line_shift</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">velocity</span></em>, <em class="sig-param"><span class="n">line</span></em>, <em class="sig-param"><span class="n">wavenumber</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">relativistic</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.line_shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the line shift (in nm or in cm-1) given its relativistic velocity</p>
<p>beta = v / c</p>
<p>gamma = sqrt((1 + beta) / (1 - beta))</p>
<p>lambda - lambda_0 = lambda_0  * (gamma - 1)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>velocity</strong> – Line velocity in km.s-1</p></li>
<li><p><strong>line</strong> – Wavelength/wavenumber of the line. Must be in cm-1 if
wavenumber is True, must be in nm otherwise.</p></li>
<li><p><strong>wavenumber</strong> – (Optional) If True the result is returned in cm-1,
else it is returned in nm.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.spectrum.lorentzian1d">
<code class="sig-prename descclassname">orb.utils.spectrum.</code><code class="sig-name descname">lorentzian1d</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">h</span></em>, <em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">dx</span></em>, <em class="sig-param"><span class="n">fwhm</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.lorentzian1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a 1D lorentzian
:param x: Array giving the positions where the function is evaluated
:param h: Height
:param a: Amplitude
:param dx: Position of the center
:param fwhm: FWHM</p>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.spectrum.mertz1d">
<code class="sig-prename descclassname">orb.utils.spectrum.</code><code class="sig-name descname">mertz1d</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">h</span></em>, <em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">dx</span></em>, <em class="sig-param"><span class="n">fwhm</span></em>, <em class="sig-param"><span class="n">ratio</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.mertz1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Complex ILS when Mertz ramp is used during the Fourier transform.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> – 1D array of float64 giving the positions where the
function is evaluated</p></li>
<li><p><strong>h</strong> – Height</p></li>
<li><p><strong>a</strong> – Amplitude</p></li>
<li><p><strong>dx</strong> – Position of the center</p></li>
<li><p><strong>fwhm</strong> – FWHM of the sinc</p></li>
<li><p><strong>ratio</strong> – Ratio of the shortest side over the longest side of
the interferogram</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.spectrum.nm2cm1">
<code class="sig-prename descclassname">orb.utils.spectrum.</code><code class="sig-name descname">nm2cm1</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">nm</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.nm2cm1" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a wavelength in nm to a wavenumber in cm-1.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>nm</strong> – wavelength in nm</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.spectrum.nm2pix">
<code class="sig-prename descclassname">orb.utils.spectrum.</code><code class="sig-name descname">nm2pix</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">nm_axis</span></em>, <em class="sig-param"><span class="n">nm</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.nm2pix" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a wavelength in nm to a pixel position given an axis
in nm</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Slow because of interpolation : using
fast_w2pix is much faster.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nm_axis</strong> – Axis in nm</p></li>
<li><p><strong>nm</strong> – Wavelength in nm</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.spectrum.phase_shift_cm1_axis">
<code class="sig-prename descclassname">orb.utils.spectrum.</code><code class="sig-name descname">phase_shift_cm1_axis</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">step_nb</span></em>, <em class="sig-param"><span class="n">step</span></em>, <em class="sig-param"><span class="n">order</span></em>, <em class="sig-param"><span class="n">nm_laser_obs</span></em>, <em class="sig-param"><span class="n">nm_laser</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.phase_shift_cm1_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute phase shift on a given cm1 axis</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>step_nb</strong> – Number of steps</p></li>
<li><p><strong>step</strong> – Step size in nm</p></li>
<li><p><strong>order</strong> – Folding order</p></li>
<li><p><strong>nm_laser_obs</strong> – Observed calibration laser wavelength (in nm)</p></li>
<li><p><strong>nm_laser</strong> – Calibration laser wavelength (in nm)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.spectrum.pix2cm1">
<code class="sig-prename descclassname">orb.utils.spectrum.</code><code class="sig-name descname">pix2cm1</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cm1_axis</span></em>, <em class="sig-param"><span class="n">pix</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.pix2cm1" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a wavenumber in cm-1 to a pixel position given an axis
in cm-1.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cm1_axis</strong> – Axis in cm-1</p></li>
<li><p><strong>pix</strong> – Pixel position</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.spectrum.pix2nm">
<code class="sig-prename descclassname">orb.utils.spectrum.</code><code class="sig-name descname">pix2nm</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">nm_axis</span></em>, <em class="sig-param"><span class="n">pix</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.pix2nm" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a pixel position to a wavelength in nm given an axis
in nm</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Slow because of interpolation : using
fast_pix2w is much faster.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nm_axis</strong> – Axis in nm</p></li>
<li><p><strong>pix</strong> – Pixel position</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.spectrum.sinc1d">
<code class="sig-prename descclassname">orb.utils.spectrum.</code><code class="sig-name descname">sinc1d</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">h</span></em>, <em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">dx</span></em>, <em class="sig-param"><span class="n">fwhm</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.sinc1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a 1D sinc 
:param x: Array giving the positions where the function is evaluated
:param h: Height
:param a: Amplitude
:param dx: Position of the center
:param fwhm: FWHM</p>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.spectrum.sinc1d_complex">
<code class="sig-prename descclassname">orb.utils.spectrum.</code><code class="sig-name descname">sinc1d_complex</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">h</span></em>, <em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">dx</span></em>, <em class="sig-param"><span class="n">fwhm</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.sinc1d_complex" title="Permalink to this definition">¶</a></dt>
<dd><p>The “complex” version of the sinc (understood as the Fourier
Transform of a boxcar function from 0 to MPD).</p>
<p>This is the real sinc function when ones wants to fit both the real
part and the imaginary part of the spectrum.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> – 1D array of float64 giving the positions where the
function is evaluated</p></li>
<li><p><strong>h</strong> – Height</p></li>
<li><p><strong>a</strong> – Amplitude</p></li>
<li><p><strong>dx</strong> – Position of the center</p></li>
<li><p><strong>fwhm</strong> – FWHM of the sinc</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.spectrum.sinc1d_flux">
<code class="sig-prename descclassname">orb.utils.spectrum.</code><code class="sig-name descname">sinc1d_flux</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">fwhm</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.sinc1d_flux" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute flux of a 1D sinc.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> – Amplitude</p></li>
<li><p><strong>fwhm</strong> – FWHM</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.spectrum.sinc1d_phased">
<code class="sig-prename descclassname">orb.utils.spectrum.</code><code class="sig-name descname">sinc1d_phased</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">h</span></em>, <em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">dx</span></em>, <em class="sig-param"><span class="n">fwhm</span></em>, <em class="sig-param"><span class="n">alpha</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.sinc1d_phased" title="Permalink to this definition">¶</a></dt>
<dd><p>The phased version of the sinc function when that can be used to
fit a spectrum with a non perfect correction of the order 0 of the
phase.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> – 1D array of float64 giving the positions where the
function is evaluated</p></li>
<li><p><strong>h</strong> – Height</p></li>
<li><p><strong>a</strong> – Amplitude</p></li>
<li><p><strong>dx</strong> – Position of the center</p></li>
<li><p><strong>fwhm</strong> – FWHM of the sinc</p></li>
<li><p><strong>alpha</strong> – Mixing coefficient (in radians).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.spectrum.sinc21d_flux">
<code class="sig-prename descclassname">orb.utils.spectrum.</code><code class="sig-name descname">sinc21d_flux</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">fwhm</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.sinc21d_flux" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute flux of a 1D sinc2.
THIS IS BOGUS WITH CURRENT DEFINITION OF SINC2 MODEL
:param a: Amplitude
:param fwhm: FWHM</p>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.spectrum.sincgauss1d">
<code class="sig-prename descclassname">orb.utils.spectrum.</code><code class="sig-name descname">sincgauss1d</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">h</span></em>, <em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">dx</span></em>, <em class="sig-param"><span class="n">fwhm</span></em>, <em class="sig-param"><span class="n">sigma</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.sincgauss1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a 1D sinc convoluted with a gaussian of parameter sigma.</p>
<p>If sigma == 0 returns a pure sinc.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> – 1D array of float64 giving the positions where the</p>
</dd>
</dl>
<p>sinc is evaluated</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>h</strong> – Height</p></li>
<li><p><strong>a</strong> – Amplitude</p></li>
<li><p><strong>dx</strong> – Position of the center</p></li>
<li><p><strong>fwhm</strong> – FWHM of the sinc</p></li>
<li><p><strong>sigma</strong> – Sigma of the gaussian.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.spectrum.sincgauss1d_complex">
<code class="sig-prename descclassname">orb.utils.spectrum.</code><code class="sig-name descname">sincgauss1d_complex</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">h</span></em>, <em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">dx</span></em>, <em class="sig-param"><span class="n">fwhm</span></em>, <em class="sig-param"><span class="n">sigma</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.sincgauss1d_complex" title="Permalink to this definition">¶</a></dt>
<dd><p>The “complex” version of the sincgauss (dawson definition).</p>
<p>This is the real sinc*gauss function when ones wants to fit both the real
part and the imaginary part of the spectrum.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> – 1D array of float64 giving the positions where the
function is evaluated</p></li>
<li><p><strong>h</strong> – Height</p></li>
<li><p><strong>a</strong> – Amplitude</p></li>
<li><p><strong>dx</strong> – Position of the center</p></li>
<li><p><strong>fwhm</strong> – FWHM of the sinc</p></li>
<li><p><strong>sigma</strong> – Sigma of the gaussian.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.spectrum.sincgauss1d_complex_erf">
<code class="sig-prename descclassname">orb.utils.spectrum.</code><code class="sig-name descname">sincgauss1d_complex_erf</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">h</span></em>, <em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">dx</span></em>, <em class="sig-param"><span class="n">fwhm</span></em>, <em class="sig-param"><span class="n">sigma</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.sincgauss1d_complex_erf" title="Permalink to this definition">¶</a></dt>
<dd><p>The “complex” version of the sincgauss (erf formulation).</p>
<p>This is the real sinc*gauss function when ones wants to fit both the real
part and the imaginary part of the spectrum.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> – 1D array of float64 giving the positions where the
function is evaluated</p></li>
<li><p><strong>h</strong> – Height</p></li>
<li><p><strong>a</strong> – Amplitude</p></li>
<li><p><strong>dx</strong> – Position of the center</p></li>
<li><p><strong>fwhm</strong> – FWHM of the sinc</p></li>
<li><p><strong>sigma</strong> – Sigma of the gaussian.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.spectrum.sincgauss1d_flux">
<code class="sig-prename descclassname">orb.utils.spectrum.</code><code class="sig-name descname">sincgauss1d_flux</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">fwhm</span></em>, <em class="sig-param"><span class="n">sigma</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.sincgauss1d_flux" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute flux of a 1D sinc convoluted with a Gaussian of
parameter sigma.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> – Amplitude</p></li>
<li><p><strong>fwhm</strong> – FWHM of the sinc</p></li>
<li><p><strong>sigma</strong> – Sigma of the gaussian</p></li>
<li><p><strong>no_err</strong> – (Optional) No error is returned (default False)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.spectrum.sincgauss1d_phased">
<code class="sig-prename descclassname">orb.utils.spectrum.</code><code class="sig-name descname">sincgauss1d_phased</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">h</span></em>, <em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">dx</span></em>, <em class="sig-param"><span class="n">fwhm</span></em>, <em class="sig-param"><span class="n">sigma</span></em>, <em class="sig-param"><span class="n">alpha</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.sincgauss1d_phased" title="Permalink to this definition">¶</a></dt>
<dd><p>The phased version of the sinc*gauss function when that can be
used to fit a spectrum with a non perfect correction of the order
0 of the phase.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> – 1D array of float64 giving the positions where the
function is evaluated</p></li>
<li><p><strong>h</strong> – Height</p></li>
<li><p><strong>a</strong> – Amplitude</p></li>
<li><p><strong>dx</strong> – Position of the center</p></li>
<li><p><strong>fwhm</strong> – FWHM of the sinc</p></li>
<li><p><strong>sigma</strong> – Sigma of the gaussian.</p></li>
<li><p><strong>alpha</strong> – Mixing coefficient (in radians).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.spectrum.thermal_broadening_kms">
<code class="sig-prename descclassname">orb.utils.spectrum.</code><code class="sig-name descname">thermal_broadening_kms</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">wl</span></em>, <em class="sig-param"><span class="n">aw</span></em>, <em class="sig-param"><span class="n">T</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.thermal_broadening_kms" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the width of the line due to thermal broadening in km/s.</p>
<p>Equation can be refered to Harwit (Astrophysical concepts) but his
definition gives the HWHM (Half-Width at Half-Maximum).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>wl</strong> – Wavelength of the line (in nm)</p></li>
<li><p><strong>aw</strong> – Atomic weight of the emitting atom</p></li>
<li><p><strong>T</strong> – Temperature in K</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.spectrum.theta2corr">
<code class="sig-prename descclassname">orb.utils.spectrum.</code><code class="sig-name descname">theta2corr</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">theta</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.theta2corr" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the incident angle to a correction coefficient.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>theta</strong> – Incident angle in degrees</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.spectrum.velocity_classic2relativistic">
<code class="sig-prename descclassname">orb.utils.spectrum.</code><code class="sig-name descname">velocity_classic2relativistic</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">vel</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.velocity_classic2relativistic" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a classic velocity to a relativistic velocity</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>vel</strong> – Classic velocity in km/s</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.spectrum.velocity_relativistic2classic">
<code class="sig-prename descclassname">orb.utils.spectrum.</code><code class="sig-name descname">velocity_relativistic2classic</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">vel</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.velocity_relativistic2classic" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a relativistic velocity to a classic velocity</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>vel</strong> – Relativistic velocity in km/s</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-orb.utils.stats">
<span id="orb-utils-stats-module"></span><h2>orb.utils.stats module<a class="headerlink" href="#module-orb.utils.stats" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="orb.utils.stats.robust_mean">
<code class="sig-prename descclassname">orb.utils.stats.</code><code class="sig-name descname">robust_mean</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">weights</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">warn</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.stats.robust_mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the mean of a distribution even with NaN values</p>
<p>This is based on bottleneck module. See:
<a class="reference external" href="https://pypi.python.org/pypi/Bottleneck">https://pypi.python.org/pypi/Bottleneck</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> – A distribution of values</p></li>
<li><p><strong>weights</strong> – Weights of each value of a (Must have the same
length as a). If None, weights are all considered equal to 1
(default None).</p></li>
<li><p><strong>warn</strong> – If True, warnings are raised.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.stats.robust_median">
<code class="sig-prename descclassname">orb.utils.stats.</code><code class="sig-name descname">robust_median</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">warn</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.stats.robust_median" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the median of a distribution (skip NaN values).</p>
<p>This is based on bottleneck module. See:
<a class="reference external" href="https://pypi.python.org/pypi/Bottleneck">https://pypi.python.org/pypi/Bottleneck</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> – A distribution of values</p></li>
<li><p><strong>warn</strong> – If True, warnings are raised.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.stats.robust_std">
<code class="sig-prename descclassname">orb.utils.stats.</code><code class="sig-name descname">robust_std</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">warn</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.stats.robust_std" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the std of a distribution even with NaN values</p>
<p>This is based on bottleneck module. See:
<a class="reference external" href="https://pypi.python.org/pypi/Bottleneck">https://pypi.python.org/pypi/Bottleneck</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> – A distribution of values</p></li>
<li><p><strong>warn</strong> – If True, warnings are raised.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.stats.robust_sum">
<code class="sig-prename descclassname">orb.utils.stats.</code><code class="sig-name descname">robust_sum</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">warn</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.stats.robust_sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the sum of a distribution (skip NaN values)</p>
<p>This is based on bottleneck module. See:
<a class="reference external" href="https://pypi.python.org/pypi/Bottleneck">https://pypi.python.org/pypi/Bottleneck</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> – A distribution of values</p></li>
<li><p><strong>warn</strong> – If True, warnings are raised.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.stats.sigmacut">
<code class="sig-prename descclassname">orb.utils.stats.</code><code class="sig-name descname">sigmacut</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">sigma</span><span class="o">=</span><span class="default_value">3.0</span></em>, <em class="sig-param"><span class="n">min_values</span><span class="o">=</span><span class="default_value">3</span></em>, <em class="sig-param"><span class="n">central_value</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">warn</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">return_index_list</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.stats.sigmacut" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a distribution after a sigma cut rejection
of the too deviant values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> – The distribution to cut</p></li>
<li><p><strong>sigma</strong> – (Optional) Number of sigma above which values are
considered as deviant (default 3.)</p></li>
<li><p><strong>min_values</strong> – (Optional) Minimum number of values to return
(default 3)</p></li>
<li><p><strong>central_value</strong> – (Optional) If not none, this value is used as
the central value of the cut. Else the median of the
distribution is used as the central value (default None)</p></li>
<li><p><strong>warn</strong> – (Optional) If False no warning message is printed
(default False).</p></li>
<li><p><strong>return_index_list</strong> – (Optional) If True the list of the non
rejected values is returned also (default False).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.stats.unbiased_std">
<code class="sig-prename descclassname">orb.utils.stats.</code><code class="sig-name descname">unbiased_std</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.stats.unbiased_std" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the std based on the interquartile range.</p>
<p>Robust to outliers, but the underlying distribution must be Normal-ish</p>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Robust_measures_of_scale">https://en.wikipedia.org/wiki/Robust_measures_of_scale</a></p>
</dd></dl>

</div>
<div class="section" id="module-orb.utils.validate">
<span id="orb-utils-validate-module"></span><h2>orb.utils.validate module<a class="headerlink" href="#module-orb.utils.validate" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="orb.utils.validate.has_dtype">
<code class="sig-prename descclassname">orb.utils.validate.</code><code class="sig-name descname">has_dtype</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">obj</span></em>, <em class="sig-param"><span class="n">dtype</span></em>, <em class="sig-param"><span class="n">raise_exception</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">object_name</span><span class="o">=</span><span class="default_value">'object'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.validate.has_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if object is a numpy.ndarray of the correct type
:param obj: object to validate
:param dtype: array dtype
:param raise_exception: If True raise an exception else raise a warning.</p>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.validate.has_len">
<code class="sig-prename descclassname">orb.utils.validate.</code><code class="sig-name descname">has_len</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">obj</span></em>, <em class="sig-param"><span class="n">length</span></em>, <em class="sig-param"><span class="n">raise_exception</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">object_name</span><span class="o">=</span><span class="default_value">'object'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.validate.has_len" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if object is 1d and if its length is correct
:param obj: Object to check
:param raise_exception: If True raise an exception else raise a warning.
:param length: length of the object</p>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.validate.have_same_shape">
<code class="sig-prename descclassname">orb.utils.validate.</code><code class="sig-name descname">have_same_shape</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">objs</span></em>, <em class="sig-param"><span class="n">raise_exception</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">object_name</span><span class="o">=</span><span class="default_value">'arrays'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.validate.have_same_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if all numpy.ndarrays have the same shape
:param obj: list of objects to validate
:param raise_exception: If True raise an exception else raise a warning.</p>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.validate.index">
<code class="sig-prename descclassname">orb.utils.validate.</code><code class="sig-name descname">index</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">a_min</span></em>, <em class="sig-param"><span class="n">a_max</span></em>, <em class="sig-param"><span class="n">clip</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.validate.index" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a valid index (clipped between a_min and a_max - 1) or raise
an exception.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> – index. Can be a list or an array of indexes.</p></li>
<li><p><strong>a_min</strong> – Min index.</p></li>
<li><p><strong>a_max</strong> – Max index (max possible index will be considered as
a_max -1)</p></li>
<li><p><strong>clip</strong> – (Optional) If True return an index inside the
boundaries, else: raise an exception (default True).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.validate.is_1darray">
<code class="sig-prename descclassname">orb.utils.validate.</code><code class="sig-name descname">is_1darray</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">obj</span></em>, <em class="sig-param"><span class="n">raise_exception</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">object_name</span><span class="o">=</span><span class="default_value">'object'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.validate.is_1darray" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if object is a 1d numpy.ndarray
:param obj: object to validate
:param raise_exception: If True raise an exception else raise a warning.</p>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.validate.is_2darray">
<code class="sig-prename descclassname">orb.utils.validate.</code><code class="sig-name descname">is_2darray</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">obj</span></em>, <em class="sig-param"><span class="n">raise_exception</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">object_name</span><span class="o">=</span><span class="default_value">'object'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.validate.is_2darray" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if object is a 2d numpy.ndarray
:param obj: object to validate
:param raise_exception: If True raise an exception else raise a warning.</p>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.validate.is_3darray">
<code class="sig-prename descclassname">orb.utils.validate.</code><code class="sig-name descname">is_3darray</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">obj</span></em>, <em class="sig-param"><span class="n">raise_exception</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">object_name</span><span class="o">=</span><span class="default_value">'object'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.validate.is_3darray" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if object is a 3d numpy.ndarray
:param obj: object to validate
:param raise_exception: If True raise an exception else raise a warning.</p>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.validate.is_iterable">
<code class="sig-prename descclassname">orb.utils.validate.</code><code class="sig-name descname">is_iterable</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">obj</span></em>, <em class="sig-param"><span class="n">raise_exception</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">object_name</span><span class="o">=</span><span class="default_value">'object'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.validate.is_iterable" title="Permalink to this definition">¶</a></dt>
<dd><p>check if object is a tuple or a list or a 1darray</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obj</strong> – Object to check</p></li>
<li><p><strong>raise_exception</strong> – If True raise an exception else raise a warning.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.validate.is_ndarray">
<code class="sig-prename descclassname">orb.utils.validate.</code><code class="sig-name descname">is_ndarray</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">obj</span></em>, <em class="sig-param"><span class="n">raise_exception</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">object_name</span><span class="o">=</span><span class="default_value">'object'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.validate.is_ndarray" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if object is a numpy.ndarray
:param obj: object to validate
:param raise_exception: If True raise an exception else raise a warning.</p>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.validate.is_xdarray">
<code class="sig-prename descclassname">orb.utils.validate.</code><code class="sig-name descname">is_xdarray</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">obj</span></em>, <em class="sig-param"><span class="n">ndim</span></em>, <em class="sig-param"><span class="n">raise_exception</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">object_name</span><span class="o">=</span><span class="default_value">'object'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.validate.is_xdarray" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if object is a numpy.ndarray with the correct number of
dimensions</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obj</strong> – object to validate</p></li>
<li><p><strong>ndim</strong> – number of dimensions</p></li>
<li><p><strong>raise_exception</strong> – If True raise an exception else raise a warning.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-orb.utils.vector">
<span id="orb-utils-vector-module"></span><h2>orb.utils.vector module<a class="headerlink" href="#module-orb.utils.vector" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="orb.utils.vector.complex2float">
<code class="sig-prename descclassname">orb.utils.vector.</code><code class="sig-name descname">complex2float</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.vector.complex2float" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="orb.utils.vector.correct_vector">
<code class="sig-prename descclassname">orb.utils.vector.</code><code class="sig-name descname">correct_vector</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">vector</span></em>, <em class="sig-param"><span class="n">bad_value</span><span class="o">=</span><span class="default_value">nan</span></em>, <em class="sig-param"><span class="n">deg</span><span class="o">=</span><span class="default_value">3</span></em>, <em class="sig-param"><span class="n">polyfit</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">smoothing</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.vector.correct_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Correct a given vector for non valid values by interpolation or
polynomial fit.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vector</strong> – The vector to be corrected.</p></li>
<li><p><strong>bad_value</strong> – (Optional) Bad value to correct (default np.nan)</p></li>
<li><p><strong>deg</strong> – (Optional) Spline degree or polyfit degree (default 3)</p></li>
<li><p><strong>polyfit</strong> – (Optional) If True non valid values are guessed
using a polynomial fit to the data instead of an spline
interpolation (default False)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.vector.fft_filter">
<code class="sig-prename descclassname">orb.utils.vector.</code><code class="sig-name descname">fft_filter</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">cutoff_coeff</span></em>, <em class="sig-param"><span class="n">width_coeff</span><span class="o">=</span><span class="default_value">0.2</span></em>, <em class="sig-param"><span class="n">filter_type</span><span class="o">=</span><span class="default_value">'high_pass'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.vector.fft_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Simple lowpass or highpass FFT filter (high pass or low pass)</p>
<p>Filter shape is a gaussian.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> – Vector to filter</p></li>
<li><p><strong>cutoff_coeff</strong> – Coefficient defining the position of the cut
frequency (Cut frequency = cut_coeff * vector length)</p></li>
<li><p><strong>width_coeff</strong> – (Optional) Coefficient defining the width of
the smoothed part of the filter (width = width_coeff * vector
length) (default 0.2)</p></li>
<li><p><strong>filter_type</strong> – (Optional) Type of filter to use. Can be
‘high_pass’ or ‘low_pass’.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.vector.float2complex">
<code class="sig-prename descclassname">orb.utils.vector.</code><code class="sig-name descname">float2complex</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.vector.float2complex" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="orb.utils.vector.interpolate_axis">
<code class="sig-prename descclassname">orb.utils.vector.</code><code class="sig-name descname">interpolate_axis</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">new_axis</span></em>, <em class="sig-param"><span class="n">deg</span></em>, <em class="sig-param"><span class="n">old_axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">fill_value</span><span class="o">=</span><span class="default_value">nan</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.vector.interpolate_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolate a vector along a new axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> – vector to interpolate</p></li>
<li><p><strong>new_axis</strong> – Interpolation axis</p></li>
<li><p><strong>deg</strong> – Interpolation degree</p></li>
<li><p><strong>old_axis</strong> – (Optional) Original vector axis. If None,
a regular range axis is assumed (default None).</p></li>
<li><p><strong>fill_value</strong> – (Optional) extrapolated points are filled with
this value (default np.nan)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.vector.interpolate_size">
<code class="sig-prename descclassname">orb.utils.vector.</code><code class="sig-name descname">interpolate_size</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">size</span></em>, <em class="sig-param"><span class="n">deg</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.vector.interpolate_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Change size of a vector by interpolation</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> – vector to interpolate</p></li>
<li><p><strong>size</strong> – New size of the vector</p></li>
<li><p><strong>deg</strong> – Interpolation degree</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.vector.polyfit1d">
<code class="sig-prename descclassname">orb.utils.vector.</code><code class="sig-name descname">polyfit1d</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">deg</span></em>, <em class="sig-param"><span class="n">w</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">return_coeffs</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.vector.polyfit1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit a polynomial to a 1D vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> – Vector to fit</p></li>
<li><p><strong>deg</strong> – Fit degree</p></li>
<li><p><strong>return_coeffs</strong> – (Optional) If True return fit coefficients
as returned by numpy.polynomial.polynomial.polyfit() (default
False).</p></li>
<li><p><strong>w</strong> – (Optional) If not None, weights to apply to the
fit. Must have the same shape as the vector to fit (default
None)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.vector.robust_unwrap">
<code class="sig-prename descclassname">orb.utils.vector.</code><code class="sig-name descname">robust_unwrap</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">vec</span></em>, <em class="sig-param"><span class="n">dis</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.vector.robust_unwrap" title="Permalink to this definition">¶</a></dt>
<dd><p>Unwrap a vector with a given discontinuity. Robust to nans.</p>
<p>Note that the returned vector will start somewhere around 0 since
all modulo bias is removed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vec</strong> – 1d Vector to unwrap.</p></li>
<li><p><strong>dis</strong> – discontinuity (eg. np.pi)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.vector.smooth">
<code class="sig-prename descclassname">orb.utils.vector.</code><code class="sig-name descname">smooth</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">deg</span><span class="o">=</span><span class="default_value">2</span></em>, <em class="sig-param"><span class="n">kind</span><span class="o">=</span><span class="default_value">'gaussian'</span></em>, <em class="sig-param"><span class="n">keep_sides</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.vector.smooth" title="Permalink to this definition">¶</a></dt>
<dd><p>Smooth a given vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> – Vector to smooth</p></li>
<li><p><strong>deg</strong> – (Optional) Smoothing degree (or kernel
radius) Must be an integer (default 2).</p></li>
<li><p><strong>kind</strong> – Kind of smoothing function. ‘median’ or ‘mean’ are
self-explanatory. ‘gaussian’ uses a gaussian function for a
weighted average. ‘gaussian_conv’ and ‘cos_conv’ make use of
convolution with a gaussian kernel or a cosine
kernel. Convolution is much faster but less rigorous on the
edges of the vector (default ‘gaussian’).</p></li>
</ul>
</dd>
<dt class="field-even">Params keep_sides</dt>
<dd class="field-even"><p>If True, the vector is seen as keeping its
side values above its real boudaries (If False, the values
outside the vector are 0. and this creates an undesirable border
effect when convolving).</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-orb.utils.web">
<span id="orb-utils-web-module"></span><h2>orb.utils.web module<a class="headerlink" href="#module-orb.utils.web" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="orb.utils.web.Catalog">
<em class="property">class </em><code class="sig-prename descclassname">orb.utils.web.</code><code class="sig-name descname">Catalog</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">out</span></em>, <em class="sig-param"><span class="n">sort</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.web.Catalog" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.web.query_sesame">
<code class="sig-prename descclassname">orb.utils.web.</code><code class="sig-name descname">query_sesame</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">object_name</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">degree</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">pm</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.web.query_sesame" title="Permalink to this definition">¶</a></dt>
<dd><p>Query the SESAME Database to get RA/DEC given the name of an
object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>object_name</strong> – Name of the object</p></li>
<li><p><strong>verbose</strong> – (Optional) If True print messages (default True)</p></li>
<li><p><strong>degree</strong> – (Optional) If True return RA DEC in degrees
(default False)</p></li>
<li><p><strong>pm</strong> – (Optional) If True proper motion is also returned
(default False)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>[RA, DEC]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.utils.web.query_vizier">
<code class="sig-prename descclassname">orb.utils.web.</code><code class="sig-name descname">query_vizier</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">radius</span></em>, <em class="sig-param"><span class="n">target_ra</span></em>, <em class="sig-param"><span class="n">target_dec</span></em>, <em class="sig-param"><span class="n">catalog</span><span class="o">=</span><span class="default_value">'gaia'</span></em>, <em class="sig-param"><span class="n">max_stars</span><span class="o">=</span><span class="default_value">100</span></em>, <em class="sig-param"><span class="n">return_all_columns</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">as_pandas</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.web.query_vizier" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of star coordinates around an object in a
given radius based on a query to VizieR Services
(<a class="reference external" href="http://vizier.u-strasbg.fr/viz-bin/VizieR">http://vizier.u-strasbg.fr/viz-bin/VizieR</a>)</p>
<p>Note that the idea of this method has been picked from an IDL
function: QUERYVIZIER
(<a class="reference external" href="http://idlastro.gsfc.nasa.gov/ftp/pro/sockets/queryvizier.pro">http://idlastro.gsfc.nasa.gov/ftp/pro/sockets/queryvizier.pro</a>)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>radius</strong> – Radius around the target in arc-minutes.</p></li>
<li><p><strong>target_ra</strong> – Target RA in degrees</p></li>
<li><p><strong>target_dec</strong> – Target DEC in degrees</p></li>
<li><p><strong>max_stars</strong> – (Optional) Maximum number of rows to retrieve
(default 100)</p></li>
<li><p><strong>catalog</strong> – (Optional) can be ‘usno’ - Version B1 of the US
Naval Observatory catalog (2003), ‘gaia’ - GAIA DR1, or ‘2mass’
- 2MASS (default Gaia)</p></li>
<li><p><strong>return_all_columns</strong> – (Optional) If True, return all
columns. Else only ra, dec and Mag are returned (default False).</p></li>
<li><p><strong>as_pandas</strong> – (Optional) If True, results are returned as a
pandas.DataFrame instance. Else a numpy.ndarray instance is
returned (default False).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="changelog.html" class="btn btn-neutral float-right" title="Changelog" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="orb.ext.html" class="btn btn-neutral float-left" title="orb.ext package" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, Thomas Martin (thomas.martin.1@ulaval.ca)

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>