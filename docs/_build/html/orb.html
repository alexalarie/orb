

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>orb package &mdash; Orb 3.4 documentation</title>
  

  
  
    <link rel="shortcut icon" href="_static/logo.ico"/>
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="orb.ext package" href="orb.ext.html" />
    <link rel="prev" title="ORB installation" href="installation.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> Orb
          

          
            
            <img src="_static/logo_sidebar.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                3.4
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="installation.html">ORB installation</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">orb package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#subpackages">Subpackages</a><ul>
<li class="toctree-l3"><a class="reference internal" href="orb.ext.html">orb.ext package</a></li>
<li class="toctree-l3"><a class="reference internal" href="orb.utils.html">orb.utils package</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="#orb-astrometry-module">orb.astrometry module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-orb.cgvar">orb.cgvar module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-orb.constants">orb.constants module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-orb.core">orb.core module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-orb.cutils">orb.cutils module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-orb.etc">orb.etc module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-orb.fit">orb.fit module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-orb">Module contents</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="changelog.html">Changelog</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Orb</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>orb package</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/orb.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="orb-package">
<h1>orb package<a class="headerlink" href="#orb-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="subpackages">
<h2>Subpackages<a class="headerlink" href="#subpackages" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="orb.ext.html">orb.ext package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="orb.ext.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="orb.ext.html#module-orb.ext.zern">orb.ext.zern module</a></li>
<li class="toctree-l2"><a class="reference internal" href="orb.ext.html#module-orb.ext">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="orb.utils.html">orb.utils package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="orb.utils.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="orb.utils.html#module-orb.utils.astrometry">orb.utils.astrometry module</a></li>
<li class="toctree-l2"><a class="reference internal" href="orb.utils.html#module-orb.utils.err">orb.utils.err module</a></li>
<li class="toctree-l2"><a class="reference internal" href="orb.utils.html#module-orb.utils.fft">orb.utils.fft module</a></li>
<li class="toctree-l2"><a class="reference internal" href="orb.utils.html#module-orb.utils.filters">orb.utils.filters module</a></li>
<li class="toctree-l2"><a class="reference internal" href="orb.utils.html#module-orb.utils.fit">orb.utils.fit module</a></li>
<li class="toctree-l2"><a class="reference internal" href="orb.utils.html#module-orb.utils.image">orb.utils.image module</a></li>
<li class="toctree-l2"><a class="reference internal" href="orb.utils.html#module-orb.utils.io">orb.utils.io module</a></li>
<li class="toctree-l2"><a class="reference internal" href="orb.utils.html#module-orb.utils.log">orb.utils.log module</a></li>
<li class="toctree-l2"><a class="reference internal" href="orb.utils.html#module-orb.utils.misc">orb.utils.misc module</a></li>
<li class="toctree-l2"><a class="reference internal" href="orb.utils.html#module-orb.utils.parallel">orb.utils.parallel module</a></li>
<li class="toctree-l2"><a class="reference internal" href="orb.utils.html#module-orb.utils.photometry">orb.utils.photometry module</a></li>
<li class="toctree-l2"><a class="reference internal" href="orb.utils.html#module-orb.utils.sim">orb.utils.sim module</a></li>
<li class="toctree-l2"><a class="reference internal" href="orb.utils.html#module-orb.utils.spectrum">orb.utils.spectrum module</a></li>
<li class="toctree-l2"><a class="reference internal" href="orb.utils.html#module-orb.utils.stats">orb.utils.stats module</a></li>
<li class="toctree-l2"><a class="reference internal" href="orb.utils.html#module-orb.utils.validate">orb.utils.validate module</a></li>
<li class="toctree-l2"><a class="reference internal" href="orb.utils.html#module-orb.utils.vector">orb.utils.vector module</a></li>
<li class="toctree-l2"><a class="reference internal" href="orb.utils.html#module-orb.utils.web">orb.utils.web module</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="orb-astrometry-module">
<h2>orb.astrometry module<a class="headerlink" href="#orb-astrometry-module" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-orb.cgvar">
<span id="orb-cgvar-module"></span><h2>orb.cgvar module<a class="headerlink" href="#module-orb.cgvar" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="orb.cgvar.dawsni">
<code class="descclassname">orb.cgvar.</code><code class="descname">dawsni</code><span class="sig-paren">(</span><em>GVar im</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cgvar.dawsni" title="Permalink to this definition">¶</a></dt>
<dd><p>Dawson function for an imaginary float input</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>im</strong> – Imaginary gvar.GVar input</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">an imaginary gvar.GVar scalar</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.cgvar.dawsni_dfdx">
<code class="descclassname">orb.cgvar.</code><code class="descname">dawsni_dfdx</code><span class="sig-paren">(</span><em>double im</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cgvar.dawsni_dfdx" title="Permalink to this definition">¶</a></dt>
<dd><p>Derivative of the dawson function for an imaginary input</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>im</strong> – Imaginary input</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">an imaginary float</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.cgvar.sinc1d">
<code class="descclassname">orb.cgvar.</code><code class="descname">sinc1d</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cgvar.sinc1d" title="Permalink to this definition">¶</a></dt>
<dd><p>sinc function</p>
</dd></dl>

<dl class="function">
<dt id="orb.cgvar.sinc_dfdx">
<code class="descclassname">orb.cgvar.</code><code class="descname">sinc_dfdx</code><span class="sig-paren">(</span><em>ndarray x</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cgvar.sinc_dfdx" title="Permalink to this definition">¶</a></dt>
<dd><p>Derivative of the sinc function</p>
</dd></dl>

<dl class="function">
<dt id="orb.cgvar.sincgauss1d">
<code class="descclassname">orb.cgvar.</code><code class="descname">sincgauss1d</code><span class="sig-paren">(</span><em>a</em>, <em>b</em>, <em>erf=False</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cgvar.sincgauss1d" title="Permalink to this definition">¶</a></dt>
<dd><p>sincgauss function</p>
</dd></dl>

<dl class="function">
<dt id="orb.cgvar.sincgauss1d_complex">
<code class="descclassname">orb.cgvar.</code><code class="descname">sincgauss1d_complex</code><span class="sig-paren">(</span><em>a</em>, <em>b</em>, <em>erf=False</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cgvar.sincgauss1d_complex" title="Permalink to this definition">¶</a></dt>
<dd><p>The “complex” version of the sincgauss (dawson definition).</p>
<p>This is the real sinc*gauss function when ones wants to fit both the real
part and the imaginary part of the spectrum.</p>
</dd></dl>

<dl class="function">
<dt id="orb.cgvar.sincgauss_real">
<code class="descclassname">orb.cgvar.</code><code class="descname">sincgauss_real</code><span class="sig-paren">(</span><em>double a</em>, <em>ndarray b</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cgvar.sincgauss_real" title="Permalink to this definition">¶</a></dt>
<dd><p>Sincgauss function of a and b which returns a real vector.</p>
</dd></dl>

<dl class="function">
<dt id="orb.cgvar.sincgauss_real_dfdx">
<code class="descclassname">orb.cgvar.</code><code class="descname">sincgauss_real_dfdx</code><span class="sig-paren">(</span><em>double a</em>, <em>ndarray b</em>, <em>erf=False</em>, <em>f_ab=None</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cgvar.sincgauss_real_dfdx" title="Permalink to this definition">¶</a></dt>
<dd><p>Partial derivatives wrt. a and b of the sincgauss function.</p>
<p>Returns real derivatives.</p>
</dd></dl>

<dl class="function">
<dt id="orb.cgvar.sincgauss_real_erf">
<code class="descclassname">orb.cgvar.</code><code class="descname">sincgauss_real_erf</code><span class="sig-paren">(</span><em>double a</em>, <em>ndarray b</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cgvar.sincgauss_real_erf" title="Permalink to this definition">¶</a></dt>
<dd><p>Sincgauss function (erf formulation) of a and b which returns a
real vector.</p>
</dd></dl>

<dl class="function">
<dt id="orb.cgvar.sincgausscomplex_real">
<code class="descclassname">orb.cgvar.</code><code class="descname">sincgausscomplex_real</code><span class="sig-paren">(</span><em>double a</em>, <em>ndarray b</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cgvar.sincgausscomplex_real" title="Permalink to this definition">¶</a></dt>
<dd><p>Sincgausscomplex function of a and b which returns two real
vectors instead of a complex vector.</p>
</dd></dl>

<dl class="function">
<dt id="orb.cgvar.sincgausscomplex_real_dfdx">
<code class="descclassname">orb.cgvar.</code><code class="descname">sincgausscomplex_real_dfdx</code><span class="sig-paren">(</span><em>double a</em>, <em>ndarray b</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cgvar.sincgausscomplex_real_dfdx" title="Permalink to this definition">¶</a></dt>
<dd><p>Partial derivatives wrt. a and b of the sincgauss function.</p>
<p>Returns real derivatives.</p>
</dd></dl>

<dl class="function">
<dt id="orb.cgvar.sincgausscomplex_real_dfdx_erf">
<code class="descclassname">orb.cgvar.</code><code class="descname">sincgausscomplex_real_dfdx_erf</code><span class="sig-paren">(</span><em>double a</em>, <em>ndarray b</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cgvar.sincgausscomplex_real_dfdx_erf" title="Permalink to this definition">¶</a></dt>
<dd><p>Partial derivatives (erf formulation) wrt. a and b of the
sincgauss function.</p>
<p>Returns real derivatives.</p>
</dd></dl>

<dl class="function">
<dt id="orb.cgvar.sincgausscomplex_real_erf">
<code class="descclassname">orb.cgvar.</code><code class="descname">sincgausscomplex_real_erf</code><span class="sig-paren">(</span><em>double a</em>, <em>ndarray b</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cgvar.sincgausscomplex_real_erf" title="Permalink to this definition">¶</a></dt>
<dd><p>Sincgausscomplex function (erf formulation) of a and b which returns two real
vectors instead of a complex vector.</p>
</dd></dl>

</div>
<div class="section" id="module-orb.constants">
<span id="orb-constants-module"></span><h2>orb.constants module<a class="headerlink" href="#module-orb.constants" title="Permalink to this headline">¶</a></h2>
<dl class="data">
<dt id="orb.constants.ATOMIC_MASS">
<code class="descclassname">orb.constants.</code><code class="descname">ATOMIC_MASS</code><em class="property"> = 1.66053886e-24</em><a class="headerlink" href="#orb.constants.ATOMIC_MASS" title="Permalink to this definition">¶</a></dt>
<dd><p>1 Atomic mass in g</p>
</dd></dl>

<dl class="data">
<dt id="orb.constants.FITS_CARD_MAX_STR_LENGTH">
<code class="descclassname">orb.constants.</code><code class="descname">FITS_CARD_MAX_STR_LENGTH</code><em class="property"> = 18</em><a class="headerlink" href="#orb.constants.FITS_CARD_MAX_STR_LENGTH" title="Permalink to this definition">¶</a></dt>
<dd><p>Max length of a FITS string card</p>
</dd></dl>

<dl class="data">
<dt id="orb.constants.FWHM_COEFF">
<code class="descclassname">orb.constants.</code><code class="descname">FWHM_COEFF</code><em class="property"> = 2.3548200450309493</em><a class="headerlink" href="#orb.constants.FWHM_COEFF" title="Permalink to this definition">¶</a></dt>
<dd><p>Coefficient used to convert the width of a gaussian function to its FWHM (line_fwhm = line_width * FWHM)</p>
</dd></dl>

<dl class="data">
<dt id="orb.constants.FWHM_SINC_COEFF">
<code class="descclassname">orb.constants.</code><code class="descname">FWHM_SINC_COEFF</code><em class="property"> = 1.20671</em><a class="headerlink" href="#orb.constants.FWHM_SINC_COEFF" title="Permalink to this definition">¶</a></dt>
<dd><p>Coefficien used to determine sinc fwhm</p>
</dd></dl>

<dl class="data">
<dt id="orb.constants.K_BOLTZMANN">
<code class="descclassname">orb.constants.</code><code class="descname">K_BOLTZMANN</code><em class="property"> = 1.38064852e-16</em><a class="headerlink" href="#orb.constants.K_BOLTZMANN" title="Permalink to this definition">¶</a></dt>
<dd><p>Boltzmann constant in erg/K</p>
</dd></dl>

<dl class="data">
<dt id="orb.constants.LIGHT_VEL_AAS">
<code class="descclassname">orb.constants.</code><code class="descname">LIGHT_VEL_AAS</code><em class="property"> = 2.99792458e+18</em><a class="headerlink" href="#orb.constants.LIGHT_VEL_AAS" title="Permalink to this definition">¶</a></dt>
<dd><p>Velocity of the light in the vacuum in A.s-1</p>
</dd></dl>

<dl class="data">
<dt id="orb.constants.LIGHT_VEL_KMS">
<code class="descclassname">orb.constants.</code><code class="descname">LIGHT_VEL_KMS</code><em class="property"> = 299792.458</em><a class="headerlink" href="#orb.constants.LIGHT_VEL_KMS" title="Permalink to this definition">¶</a></dt>
<dd><p>Velocity of the light in the vacuum in km.s-1</p>
</dd></dl>

<dl class="data">
<dt id="orb.constants.PLANCK">
<code class="descclassname">orb.constants.</code><code class="descname">PLANCK</code><em class="property"> = 6.6260755e-27</em><a class="headerlink" href="#orb.constants.PLANCK" title="Permalink to this definition">¶</a></dt>
<dd><p>Planck constant in erg.s</p>
</dd></dl>

<dl class="data">
<dt id="orb.constants.SESAME_URL">
<code class="descclassname">orb.constants.</code><code class="descname">SESAME_URL</code><em class="property"> = 'http://cdsweb.u-strasbg.fr/cgi-bin/nph-sesame/-oxp/SNVA?'</em><a class="headerlink" href="#orb.constants.SESAME_URL" title="Permalink to this definition">¶</a></dt>
<dd><p>Sesame URL</p>
</dd></dl>

<dl class="data">
<dt id="orb.constants.VIZIER_URL">
<code class="descclassname">orb.constants.</code><code class="descname">VIZIER_URL</code><em class="property"> = 'http://webviz.u-strasbg.fr/viz-bin/'</em><a class="headerlink" href="#orb.constants.VIZIER_URL" title="Permalink to this definition">¶</a></dt>
<dd><p>Vizier URL in Canada</p>
</dd></dl>

<dl class="data">
<dt id="orb.constants.VIZIER_URL_CA">
<code class="descclassname">orb.constants.</code><code class="descname">VIZIER_URL_CA</code><em class="property"> = 'http://vizier.hia.nrc.ca/viz-bin/'</em><a class="headerlink" href="#orb.constants.VIZIER_URL_CA" title="Permalink to this definition">¶</a></dt>
<dd><p>Vizier URL in Canada</p>
</dd></dl>

</div>
<div class="section" id="module-orb.core">
<span id="orb-core-module"></span><h2>orb.core module<a class="headerlink" href="#module-orb.core" title="Permalink to this headline">¶</a></h2>
<p>The Core module contains all the core classes of ORB.</p>
<dl class="class">
<dt id="orb.core.Axis">
<em class="property">class </em><code class="descclassname">orb.core.</code><code class="descname">Axis</code><span class="sig-paren">(</span><em>data</em>, <em>axis=None</em>, <em>params=None</em>, <em>mask=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#orb.core.Vector1d" title="orb.core.Vector1d"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.core.Vector1d</span></code></a></p>
<p>Axis class</p>
<dl class="method">
<dt id="orb.core.Axis.convert">
<code class="descname">convert</code><span class="sig-paren">(</span><em>pos</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Axis.convert" title="Permalink to this definition">¶</a></dt>
<dd><p>convert the position in channel to a a value in axis unit</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>pos</strong> – Position in channel</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Value in axis unit</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="orb.core.Cm1Vector1d">
<em class="property">class </em><code class="descclassname">orb.core.</code><code class="descname">Cm1Vector1d</code><span class="sig-paren">(</span><em>spectrum</em>, <em>axis=None</em>, <em>params=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Cm1Vector1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#orb.core.Vector1d" title="orb.core.Vector1d"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.core.Vector1d</span></code></a></p>
<p>1d vector class for data projected on a cm-1 axis (e.g. complex
spectrum, phase)</p>
<dl class="method">
<dt id="orb.core.Cm1Vector1d.get_filter_bandpass_cm1">
<code class="descname">get_filter_bandpass_cm1</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Cm1Vector1d.get_filter_bandpass_cm1" title="Permalink to this definition">¶</a></dt>
<dd><p>Return filter bandpass in cm-1</p>
</dd></dl>

<dl class="method">
<dt id="orb.core.Cm1Vector1d.get_filter_bandpass_pix">
<code class="descname">get_filter_bandpass_pix</code><span class="sig-paren">(</span><em>border_ratio=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Cm1Vector1d.get_filter_bandpass_pix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return filter bandpass in channels</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>border_ratio</strong> – (Optional) Relative portion of filter
border removed (can be a negative float to get a bandpass
larger than the filter, default 0.)</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">(min, max)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="orb.core.Cm1Vector1d.mean_in_filter">
<code class="descname">mean_in_filter</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Cm1Vector1d.mean_in_filter" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="orb.core.Cm1Vector1d.needed_params">
<code class="descname">needed_params</code><em class="property"> = ('filter_name',)</em><a class="headerlink" href="#orb.core.Cm1Vector1d.needed_params" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="orb.core.Cm1Vector1d.obs_params">
<code class="descname">obs_params</code><em class="property"> = ('step', 'order', 'calib_coeff')</em><a class="headerlink" href="#orb.core.Cm1Vector1d.obs_params" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="orb.core.ColorStreamHandler">
<em class="property">class </em><code class="descclassname">orb.core.</code><code class="descname">ColorStreamHandler</code><span class="sig-paren">(</span><em>stream=None</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.ColorStreamHandler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">logging.StreamHandler</span></code></p>
<p>Manage colored logging</p>
<p>copied from <a class="reference external" href="https://gist.github.com/mooware/a1ed40987b6cc9ab9c65">https://gist.github.com/mooware/a1ed40987b6cc9ab9c65</a></p>
<dl class="attribute">
<dt id="orb.core.ColorStreamHandler.CRITICAL">
<code class="descname">CRITICAL</code><em class="property"> = '\x1b[31m'</em><a class="headerlink" href="#orb.core.ColorStreamHandler.CRITICAL" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="orb.core.ColorStreamHandler.DEBUG">
<code class="descname">DEBUG</code><em class="property"> = '\x1b[36m'</em><a class="headerlink" href="#orb.core.ColorStreamHandler.DEBUG" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="orb.core.ColorStreamHandler.DEFAULT">
<code class="descname">DEFAULT</code><em class="property"> = '\x1b[0m'</em><a class="headerlink" href="#orb.core.ColorStreamHandler.DEFAULT" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="orb.core.ColorStreamHandler.ERROR">
<code class="descname">ERROR</code><em class="property"> = '\x1b[31m'</em><a class="headerlink" href="#orb.core.ColorStreamHandler.ERROR" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="orb.core.ColorStreamHandler.INFO">
<code class="descname">INFO</code><em class="property"> = '\x1b[0m'</em><a class="headerlink" href="#orb.core.ColorStreamHandler.INFO" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="orb.core.ColorStreamHandler.WARNING">
<code class="descname">WARNING</code><em class="property"> = '\x1b[33m'</em><a class="headerlink" href="#orb.core.ColorStreamHandler.WARNING" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="orb.core.ColorStreamHandler.format">
<code class="descname">format</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.ColorStreamHandler.format" title="Permalink to this definition">¶</a></dt>
<dd><p>Format the specified record.</p>
<p>If a formatter is set, use it. Otherwise, use the default formatter
for the module.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="orb.core.Data">
<em class="property">class </em><code class="descclassname">orb.core.</code><code class="descname">Data</code><span class="sig-paren">(</span><em>data</em>, <em>err=None</em>, <em>axis=None</em>, <em>params=None</em>, <em>mask=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Data" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>base class for data objects.</p>
<p>data = array 
+ params (equiv to header, wcs params are contained in the params) 
+ axis (for 1d data and 3d data)
+ mask (1d for 1d, 2d for 2d and 3d)</p>
<dl class="method">
<dt id="orb.core.Data.assert_axis">
<code class="descname">assert_axis</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Data.assert_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Assert the presence of an axis</p>
</dd></dl>

<dl class="method">
<dt id="orb.core.Data.assert_err">
<code class="descname">assert_err</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Data.assert_err" title="Permalink to this definition">¶</a></dt>
<dd><p>Assert the presence of an error</p>
</dd></dl>

<dl class="method">
<dt id="orb.core.Data.assert_mask">
<code class="descname">assert_mask</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Data.assert_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Assert the presence of a mask</p>
</dd></dl>

<dl class="method">
<dt id="orb.core.Data.assert_no_pointer">
<code class="descname">assert_no_pointer</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Data.assert_no_pointer" title="Permalink to this definition">¶</a></dt>
<dd><p>Raise an exception if If data is a pointer to an hdf dataset</p>
</dd></dl>

<dl class="method">
<dt id="orb.core.Data.assert_params">
<code class="descname">assert_params</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Data.assert_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Assert the presence of parameters</p>
</dd></dl>

<dl class="attribute">
<dt id="orb.core.Data.convert_params">
<code class="descname">convert_params</code><em class="property"> = {}</em><a class="headerlink" href="#orb.core.Data.convert_params" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="orb.core.Data.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>data=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Data.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of the instance</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>data</strong> – (Optional) can be used to change data</li>
<li><strong>kwargs</strong> – Addition kwargs (useful to copy child classes
with more kwargs at init)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="orb.core.Data.copy_param">
<code class="descname">copy_param</code><span class="sig-paren">(</span><em>oldkey</em>, <em>newkey</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Data.copy_param" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy a parameter with a given key to a parameter with another
key. Do it only if the new key is not already set</p>
</dd></dl>

<dl class="method">
<dt id="orb.core.Data.get_axis">
<code class="descname">get_axis</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Data.get_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of self.axis</p>
</dd></dl>

<dl class="method">
<dt id="orb.core.Data.get_err">
<code class="descname">get_err</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Data.get_err" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of self.err</p>
</dd></dl>

<dl class="method">
<dt id="orb.core.Data.get_gvar">
<code class="descname">get_gvar</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Data.get_gvar" title="Permalink to this definition">¶</a></dt>
<dd><p>Return data and err as a gvar.GVar instance</p>
</dd></dl>

<dl class="method">
<dt id="orb.core.Data.get_header">
<code class="descname">get_header</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Data.get_header" title="Permalink to this definition">¶</a></dt>
<dd><p>Return params as an astropy.io.fits.Header instance</p>
</dd></dl>

<dl class="method">
<dt id="orb.core.Data.get_mask">
<code class="descname">get_mask</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Data.get_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of self.mask</p>
</dd></dl>

<dl class="method">
<dt id="orb.core.Data.get_param">
<code class="descname">get_param</code><span class="sig-paren">(</span><em>key</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Data.get_param" title="Permalink to this definition">¶</a></dt>
<dd><p>Get class parameter</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>key</strong> – parameter key</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="orb.core.Data.get_wcs">
<code class="descname">get_wcs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Data.get_wcs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="orb.core.Data.get_wcs_header">
<code class="descname">get_wcs_header</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Data.get_wcs_header" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="orb.core.Data.has_axis">
<code class="descname">has_axis</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Data.has_axis" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="orb.core.Data.has_err">
<code class="descname">has_err</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Data.has_err" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="orb.core.Data.has_mask">
<code class="descname">has_mask</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Data.has_mask" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="orb.core.Data.has_param">
<code class="descname">has_param</code><span class="sig-paren">(</span><em>key</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Data.has_param" title="Permalink to this definition">¶</a></dt>
<dd><p>Test the presence of a parameter</p>
</dd></dl>

<dl class="method">
<dt id="orb.core.Data.has_params">
<code class="descname">has_params</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Data.has_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Check the presence of observation parameters</p>
</dd></dl>

<dl class="method">
<dt id="orb.core.Data.is_pointer">
<code class="descname">is_pointer</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Data.is_pointer" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if data is a pointer to an hdf dataset (or if there is no data) in which case
some operations are impossible.</p>
</dd></dl>

<dl class="method">
<dt id="orb.core.Data.is_writeable">
<code class="descname">is_writeable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Data.is_writeable" title="Permalink to this definition">¶</a></dt>
<dd><p>Return False if data is read-only.</p>
</dd></dl>

<dl class="attribute">
<dt id="orb.core.Data.needed_params">
<code class="descname">needed_params</code><em class="property"> = ()</em><a class="headerlink" href="#orb.core.Data.needed_params" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="orb.core.Data.set_header">
<code class="descname">set_header</code><span class="sig-paren">(</span><em>header</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Data.set_header" title="Permalink to this definition">¶</a></dt>
<dd><p>update params from an astropy.io.fits.Header instance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>header</strong> – An astropy.io.fits.Header instance.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="orb.core.Data.set_mask">
<code class="descname">set_mask</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Data.set_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Set mask.</p>
<p>A mask must have the shape of the data but for 3d data which
has a 2d mask (self.dimx, self.dimy). A Zero indicates a pixel
which should be masked (Nans are returned for this pixel).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>data</strong> – mask. Must be a boolean array</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="orb.core.Data.set_param">
<code class="descname">set_param</code><span class="sig-paren">(</span><em>key</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Data.set_param" title="Permalink to this definition">¶</a></dt>
<dd><p>Set class parameter</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>key</strong> – parameter key</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="orb.core.Data.set_writeable">
<code class="descname">set_writeable</code><span class="sig-paren">(</span><em>write</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Data.set_writeable" title="Permalink to this definition">¶</a></dt>
<dd><p>Set writeability of the data.</p>
</dd></dl>

<dl class="method">
<dt id="orb.core.Data.to_fits">
<code class="descname">to_fits</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Data.to_fits" title="Permalink to this definition">¶</a></dt>
<dd><p>write data to a FITS file.</p>
<p>Note that most of the information will be lost in the
process. The only output guaranteed format is hdf5 (usr
writeto() method instead)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>path</strong> – Path to the FITS file</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="orb.core.Data.update_params">
<code class="descname">update_params</code><span class="sig-paren">(</span><em>params</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Data.update_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Update params with a dictionary or an astropy.io.fits.Header</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>params</strong> – A dict or an astropy.io.fits.Header instance.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="orb.core.Data.writeto">
<code class="descname">writeto</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Data.writeto" title="Permalink to this definition">¶</a></dt>
<dd><p>Write data to an hdf file</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>path</strong> – hdf file path.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="orb.core.ExtDebugLoggingFilter">
<em class="property">class </em><code class="descclassname">orb.core.</code><code class="descname">ExtDebugLoggingFilter</code><span class="sig-paren">(</span><em>name=''</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.ExtDebugLoggingFilter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">logging.Filter</span></code></p>
<dl class="attribute">
<dt id="orb.core.ExtDebugLoggingFilter.bad_names">
<code class="descname">bad_names</code><em class="property"> = ['pp']</em><a class="headerlink" href="#orb.core.ExtDebugLoggingFilter.bad_names" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="orb.core.ExtDebugLoggingFilter.filter">
<code class="descname">filter</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.ExtDebugLoggingFilter.filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if the specified record is to be logged.</p>
<p>Is the specified record to be logged? Returns 0 for no, nonzero for
yes. If deemed appropriate, the record may be modified in-place.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="orb.core.ExtInfoLoggingFilter">
<em class="property">class </em><code class="descclassname">orb.core.</code><code class="descname">ExtInfoLoggingFilter</code><span class="sig-paren">(</span><em>name=''</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.ExtInfoLoggingFilter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">logging.Filter</span></code></p>
<dl class="attribute">
<dt id="orb.core.ExtInfoLoggingFilter.bad_names">
<code class="descname">bad_names</code><em class="property"> = ['pp']</em><a class="headerlink" href="#orb.core.ExtInfoLoggingFilter.bad_names" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="orb.core.ExtInfoLoggingFilter.filter">
<code class="descname">filter</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.ExtInfoLoggingFilter.filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if the specified record is to be logged.</p>
<p>Is the specified record to be logged? Returns 0 for no, nonzero for
yes. If deemed appropriate, the record may be modified in-place.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="orb.core.FilterFile">
<em class="property">class </em><code class="descclassname">orb.core.</code><code class="descname">FilterFile</code><span class="sig-paren">(</span><em>filter_name</em>, <em>axis=None</em>, <em>params=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.FilterFile" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#orb.core.Vector1d" title="orb.core.Vector1d"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.core.Vector1d</span></code></a></p>
<p>Manage filter files</p>
<dl class="method">
<dt id="orb.core.FilterFile.get_filter_bandpass">
<code class="descname">get_filter_bandpass</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.FilterFile.get_filter_bandpass" title="Permalink to this definition">¶</a></dt>
<dd><p>Return filter bandpass in nm</p>
</dd></dl>

<dl class="method">
<dt id="orb.core.FilterFile.get_filter_bandpass_cm1">
<code class="descname">get_filter_bandpass_cm1</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.FilterFile.get_filter_bandpass_cm1" title="Permalink to this definition">¶</a></dt>
<dd><p>Return filter bandpass in cm-1</p>
</dd></dl>

<dl class="method">
<dt id="orb.core.FilterFile.get_modulation_efficiency">
<code class="descname">get_modulation_efficiency</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.FilterFile.get_modulation_efficiency" title="Permalink to this definition">¶</a></dt>
<dd><p>Return modulation efficiency.</p>
</dd></dl>

<dl class="method">
<dt id="orb.core.FilterFile.get_observation_params">
<code class="descname">get_observation_params</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.FilterFile.get_observation_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Return observation params as tuple (step, order).</p>
</dd></dl>

<dl class="method">
<dt id="orb.core.FilterFile.get_phase_fit_order">
<code class="descname">get_phase_fit_order</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.FilterFile.get_phase_fit_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Return phase fit order.</p>
</dd></dl>

<dl class="method">
<dt id="orb.core.FilterFile.get_sky_lines">
<code class="descname">get_sky_lines</code><span class="sig-paren">(</span><em>step_nb</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.FilterFile.get_sky_lines" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sky lines in a given filter</p>
</dd></dl>

<dl class="method">
<dt id="orb.core.FilterFile.get_transmission">
<code class="descname">get_transmission</code><span class="sig-paren">(</span><em>step_nb</em>, <em>corr=None</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.FilterFile.get_transmission" title="Permalink to this definition">¶</a></dt>
<dd><p>Return transmission in the filter bandpass
:param step_nb: number of steps</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>corr</strong> – calibration coeff (at center if None)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="orb.core.FilterFile.needed_params">
<code class="descname">needed_params</code><em class="property"> = ('step', 'order', 'phase_fit_order', 'modulation_efficiency', 'bandpass_min_nm', 'bandpass_max_nm', 'instrument')</em><a class="headerlink" href="#orb.core.FilterFile.needed_params" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="orb.core.FilterFile.project">
<code class="descname">project</code><span class="sig-paren">(</span><em>new_axis</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.FilterFile.project" title="Permalink to this definition">¶</a></dt>
<dd><p>Project vector on a new axis</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>new_axis</strong> – Axis. Must be an orb.core.Axis instance.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="orb.core.FilterFile.read_filter_file">
<code class="descname">read_filter_file</code><span class="sig-paren">(</span><em>return_spline=False</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.FilterFile.read_filter_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Return transmission, axis and bandpass</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>return_spline</strong> – If True a cubic spline
(scipy.interpolate.UnivariateSpline instance) is returned
instead of a tuple (filter_nm, filter_trans, filter_min, filter_max)</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="orb.core.Indexer">
<em class="property">class </em><code class="descclassname">orb.core.</code><code class="descname">Indexer</code><span class="sig-paren">(</span><em>instrument=None</em>, <em>config=None</em>, <em>data_prefix='./temp/data.'</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Indexer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#orb.core.Tools" title="orb.core.Tools"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.core.Tools</span></code></a></p>
<p>Manage locations of created files.</p>
<p>All files locations are stored in a text-like file: the index
file. This file is the ‘real’ counterpart of the index (which is
‘virtual’ until <code class="xref py py-meth docutils literal notranslate"><span class="pre">core.Indexer.update_index()</span></code> is
called). This method is called each time
<code class="xref py py-meth docutils literal notranslate"><span class="pre">core.Indexer.__setitem__()</span></code> is called.</p>
<p>This class can be accessed like a dictionary.</p>
<dl class="attribute">
<dt id="orb.core.Indexer.file_group">
<code class="descname">file_group</code><em class="property"> = None</em><a class="headerlink" href="#orb.core.Indexer.file_group" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="orb.core.Indexer.file_group_indexes">
<code class="descname">file_group_indexes</code><em class="property"> = [0, 1, 2]</em><a class="headerlink" href="#orb.core.Indexer.file_group_indexes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="orb.core.Indexer.file_groups">
<code class="descname">file_groups</code><em class="property"> = ['cam1', 'cam2', 'merged']</em><a class="headerlink" href="#orb.core.Indexer.file_groups" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="orb.core.Indexer.get_path">
<code class="descname">get_path</code><span class="sig-paren">(</span><em>file_key</em>, <em>file_group=None</em>, <em>err=False</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Indexer.get_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the path of a file recorded in the index.</p>
<p>Equivalent to self[file_key] if the option file_group is not used.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>file_key</strong> – Key name of the file to be located</li>
<li><strong>file_group</strong> – (Optional) Add group prefix to the key
name. File group must be ‘cam1’, ‘cam2’, ‘merged’ or their
integer equivalent 1, 2, 0. File group can also be set to
None (default None).</li>
<li><strong>err</strong> – (Optional) Print an error instead of a warning if
the file is not indexed.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="orb.core.Indexer.index">
<code class="descname">index</code><em class="property"> = {}</em><a class="headerlink" href="#orb.core.Indexer.index" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="orb.core.Indexer.load_index">
<code class="descname">load_index</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Indexer.load_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Load index file and rebuild index of already located files</p>
</dd></dl>

<dl class="method">
<dt id="orb.core.Indexer.set_file_group">
<code class="descname">set_file_group</code><span class="sig-paren">(</span><em>file_group</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Indexer.set_file_group" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the group of the next files to be recorded. All given
file keys will be prefixed by the file group.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>file_group</strong> – File group must be ‘cam1’, ‘cam2’, ‘merged’
or their integer equivalent 1, 2, 0. File group can also be
set to None.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="orb.core.Indexer.update_index">
<code class="descname">update_index</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Indexer.update_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Update index files with data in the virtual index</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="orb.core.Lines">
<em class="property">class </em><code class="descclassname">orb.core.</code><code class="descname">Lines</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Lines" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#orb.core.Tools" title="orb.core.Tools"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.core.Tools</span></code></a></p>
<p>This class manages emission lines names and wavelengths.</p>
<p>Spectral lines rest wavelength (excerpt, all recorded lines are in
self.air_lines_nm):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">============</span> <span class="o">=======</span>
  <span class="n">Em</span><span class="o">.</span> <span class="n">Line</span>     <span class="n">Air</span>
<span class="o">============</span> <span class="o">=======</span>
<span class="p">[</span><span class="n">OII</span><span class="p">]</span><span class="mi">3726</span>    <span class="mf">372.603</span>
<span class="p">[</span><span class="n">OII</span><span class="p">]</span><span class="mi">3729</span>    <span class="mf">372.882</span>
<span class="n">Hepsilon</span>     <span class="mf">397.007</span>
<span class="n">Hdelta</span>       <span class="mf">410.176</span>
<span class="n">Hgamma</span>       <span class="mf">434.047</span>
<span class="p">[</span><span class="n">OIII</span><span class="p">]</span><span class="mi">4363</span>   <span class="mf">436.321</span>
<span class="n">Hbeta</span>        <span class="mf">486.133</span>
<span class="p">[</span><span class="n">OIII</span><span class="p">]</span><span class="mi">4959</span>   <span class="mf">495.892</span>
<span class="p">[</span><span class="n">OIII</span><span class="p">]</span><span class="mi">5007</span>   <span class="mf">500.684</span>
<span class="p">[</span><span class="n">NII</span><span class="p">]</span><span class="mi">6548</span>    <span class="mf">654.803</span>
<span class="n">Halpha</span>       <span class="mf">656.279</span>
<span class="p">[</span><span class="n">NII</span><span class="p">]</span><span class="mi">6583</span>    <span class="mf">658.341</span>
<span class="p">[</span><span class="n">SII</span><span class="p">]</span><span class="mi">6716</span>    <span class="mf">671.647</span>
<span class="p">[</span><span class="n">SII</span><span class="p">]</span><span class="mi">6731</span>    <span class="mf">673.085</span>
</pre></div>
</div>
<dl class="attribute">
<dt id="orb.core.Lines.air_lines_name">
<code class="descname">air_lines_name</code><em class="property"> = None</em><a class="headerlink" href="#orb.core.Lines.air_lines_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="orb.core.Lines.air_lines_nm">
<code class="descname">air_lines_nm</code><em class="property"> = {'H10': 379.79044, 'H11': 377.06368, 'H12': 375.01584, 'H13': 373.43746, 'H14': 372.19449, 'H15': 371.19774, 'H8': 388.90557, 'H9': 383.53909, 'Halpha': 656.2819, 'Hbeta': 486.1333, 'Hdelta': 410.17415, 'HeI5876': 587.567, 'HeI6678': 667.81517, 'HeI7065': 706.52153, 'Hepsilon': 397.00788, 'Hgamma': 434.0471, '[ArIII]7136': 713.579, '[ArIII]7751': 775.111, '[NII]6548': 654.805, '[NII]6583': 658.345, '[NeIII]3869': 386.876, '[OIII]4363': 436.3209, '[OIII]4959': 495.8911, '[OIII]5007': 500.6843, '[OII]3726': 372.6032, '[OII]3729': 372.8815, '[OII]7320': 731.992, '[OII]7330': 733.019, '[OI]6300': 630.0304, '[SIII]6312': 631.206, '[SII]6716': 671.644, '[SII]6731': 673.0816}</em><a class="headerlink" href="#orb.core.Lines.air_lines_nm" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="orb.core.Lines.air_sky_lines_nm">
<code class="descname">air_sky_lines_nm</code><em class="property"> = None</em><a class="headerlink" href="#orb.core.Lines.air_sky_lines_nm" title="Permalink to this definition">¶</a></dt>
<dd><p>Air sky lines wavelength</p>
</dd></dl>

<dl class="method">
<dt id="orb.core.Lines.get_line_cm1">
<code class="descname">get_line_cm1</code><span class="sig-paren">(</span><em>lines_name</em>, <em>round_ang=False</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Lines.get_line_cm1" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the wavenumber of a line or a list of lines</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>lines_name</strong> – List of line names</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="orb.core.Lines.get_line_name">
<code class="descname">get_line_name</code><span class="sig-paren">(</span><em>lines</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Lines.get_line_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the name of a line or a list of lines given their
wavelength.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>lines</strong> – List of lines wavelength</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="orb.core.Lines.get_line_nm">
<code class="descname">get_line_nm</code><span class="sig-paren">(</span><em>lines_name</em>, <em>round_ang=False</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Lines.get_line_nm" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the wavelength of a line or a list of lines</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>lines_name</strong> – List of line names</li>
<li><strong>round_ang</strong> – (Optional) If True return the rounded
wavelength of the line in angstrom (default False)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="orb.core.Lines.get_sky_lines">
<code class="descname">get_sky_lines</code><span class="sig-paren">(</span><em>nm_min</em>, <em>nm_max</em>, <em>delta_nm</em>, <em>line_nb=0</em>, <em>get_names=False</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Lines.get_sky_lines" title="Permalink to this definition">¶</a></dt>
<dd><p>Return sky lines in a range of optical wavelength.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>nm_min</strong> – min Wavelength of the lines in nm</li>
<li><strong>nm_max</strong> – max Wavelength of the lines in nm</li>
<li><strong>delta_nm</strong> – Wavelength resolution in nm as the minimum
wavelength interval of the spectrum. Lines comprises in half
of this interval are merged.</li>
<li><strong>line_nb</strong> – (Optional) Number of the most intense lines to
retrieve. If 0 all lines are given (default 0).</li>
<li><strong>get_name</strong> – (Optional) If True return lines name also.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="orb.core.Lines.other_names">
<code class="descname">other_names</code><em class="property"> = {'Halpha': ['H3'], 'Hbeta': ['H4'], 'Hdelta': ['H6'], 'Hepsilon': ['H7'], 'Hgamma': ['H5'], '[NII]6583': ['[NII]6584'], '[OII]3726': ['[OII]3727'], '[SII]6716': ['[SII]6717']}</em><a class="headerlink" href="#orb.core.Lines.other_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Air emission lines wavelength</p>
</dd></dl>

<dl class="method">
<dt id="orb.core.Lines.round_nm2ang">
<code class="descname">round_nm2ang</code><span class="sig-paren">(</span><em>nm</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Lines.round_nm2ang" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a wavelength in nm into a rounded value in angstrom</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>nm</strong> – Line wavelength in nm</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="orb.core.Lines.sky_lines_file_name">
<code class="descname">sky_lines_file_name</code><em class="property"> = 'sky_lines.orb'</em><a class="headerlink" href="#orb.core.Lines.sky_lines_file_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of the sky lines data file.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="orb.core.LogRecordSocketReceiver">
<em class="property">class </em><code class="descclassname">orb.core.</code><code class="descname">LogRecordSocketReceiver</code><span class="sig-paren">(</span><em>host='localhost'</em>, <em>port=9020</em>, <em>handler=&lt;class orb.core.LogRecordStreamHandler&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.LogRecordSocketReceiver" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">SocketServer.ThreadingTCPServer</span></code></p>
<p>Simple TCP socket-based logging receiver suitable for testing.</p>
<dl class="method">
<dt id="orb.core.LogRecordSocketReceiver.serve_until_stopped">
<code class="descname">serve_until_stopped</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.LogRecordSocketReceiver.serve_until_stopped" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="orb.core.LogRecordSocketReceiver.server_bind">
<code class="descname">server_bind</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.LogRecordSocketReceiver.server_bind" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="orb.core.LogRecordStreamHandler">
<em class="property">class </em><code class="descclassname">orb.core.</code><code class="descname">LogRecordStreamHandler</code><span class="sig-paren">(</span><em>request</em>, <em>client_address</em>, <em>server</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.LogRecordStreamHandler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">SocketServer.StreamRequestHandler</span></code></p>
<p>Handler for a streaming logging request.</p>
<p>This basically logs the record using whatever logging policy is
configured locally.</p>
<dl class="method">
<dt id="orb.core.LogRecordStreamHandler.handle">
<code class="descname">handle</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.LogRecordStreamHandler.handle" title="Permalink to this definition">¶</a></dt>
<dd><p>Handle multiple requests - each expected to be a 4-byte length,
followed by the LogRecord in pickle format. Logs the record
according to whatever policy is configured locally.</p>
</dd></dl>

<dl class="method">
<dt id="orb.core.LogRecordStreamHandler.handleLogRecord">
<code class="descname">handleLogRecord</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.LogRecordStreamHandler.handleLogRecord" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="orb.core.LogRecordStreamHandler.unPickle">
<code class="descname">unPickle</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.LogRecordStreamHandler.unPickle" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="orb.core.Logger">
<em class="property">class </em><code class="descclassname">orb.core.</code><code class="descname">Logger</code><span class="sig-paren">(</span><em>debug=False</em>, <em>logfilter='default'</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Logger" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="method">
<dt id="orb.core.Logger.getLogger">
<code class="descname">getLogger</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Logger.getLogger" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="orb.core.Logger.get_file_logging_state">
<code class="descname">get_file_logging_state</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Logger.get_file_logging_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the file logging appears set</p>
</dd></dl>

<dl class="method">
<dt id="orb.core.Logger.get_logdateformat">
<code class="descname">get_logdateformat</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Logger.get_logdateformat" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a string describing the logging date format</p>
</dd></dl>

<dl class="method">
<dt id="orb.core.Logger.get_logfilter">
<code class="descname">get_logfilter</code><span class="sig-paren">(</span><em>logfilter</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Logger.get_logfilter" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="orb.core.Logger.get_logformat">
<code class="descname">get_logformat</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Logger.get_logformat" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a string describing the logging format</p>
</dd></dl>

<dl class="method">
<dt id="orb.core.Logger.get_logging_state">
<code class="descname">get_logging_state</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Logger.get_logging_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the logging is set</p>
</dd></dl>

<dl class="method">
<dt id="orb.core.Logger.get_simplelogformat">
<code class="descname">get_simplelogformat</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Logger.get_simplelogformat" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a string describing the simple logging format</p>
</dd></dl>

<dl class="method">
<dt id="orb.core.Logger.listen">
<code class="descname">listen</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Logger.listen" title="Permalink to this definition">¶</a></dt>
<dd><p>Listen and handle logging sent on TCP socket</p>
</dd></dl>

<dl class="attribute">
<dt id="orb.core.Logger.logfilters">
<code class="descname">logfilters</code><em class="property"> = {'default': &lt;orb.core.ExtDebugLoggingFilter object&gt;, 'extdebug': &lt;orb.core.ExtDebugLoggingFilter object&gt;, 'extinfo': &lt;orb.core.ExtInfoLoggingFilter object&gt;, 'none': &lt;orb.core.NoLoggingFilter object&gt;}</em><a class="headerlink" href="#orb.core.Logger.logfilters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="orb.core.Logger.start_file_logging">
<code class="descname">start_file_logging</code><span class="sig-paren">(</span><em>logfile_path=None</em>, <em>logfilter=None</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Logger.start_file_logging" title="Permalink to this definition">¶</a></dt>
<dd><p>Start file logging</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>logfile_path</strong> – Path to the logfile. If none is provided
a default logfile path is used.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="orb.core.Logger.start_logging">
<code class="descname">start_logging</code><span class="sig-paren">(</span><em>logfilter=None</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Logger.start_logging" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset logging only if logging is not set</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>logfilter</strong> – If set to None, default logfilter set at
init will be applied (default None)</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="orb.core.NoInstrumentConfigParams">
<em class="property">class </em><code class="descclassname">orb.core.</code><code class="descname">NoInstrumentConfigParams</code><a class="headerlink" href="#orb.core.NoInstrumentConfigParams" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#orb.core.ROParams" title="orb.core.ROParams"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.core.ROParams</span></code></a></p>
<p>Special dictionary which elements can be accessed like
attributes.</p>
<p>Attributes are read-only and may be defined only once.</p>
</dd></dl>

<dl class="class">
<dt id="orb.core.NoLoggingFilter">
<em class="property">class </em><code class="descclassname">orb.core.</code><code class="descname">NoLoggingFilter</code><span class="sig-paren">(</span><em>name=''</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.NoLoggingFilter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">logging.Filter</span></code></p>
<dl class="method">
<dt id="orb.core.NoLoggingFilter.filter">
<code class="descname">filter</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.NoLoggingFilter.filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if the specified record is to be logged.</p>
<p>Is the specified record to be logged? Returns 0 for no, nonzero for
yes. If deemed appropriate, the record may be modified in-place.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="orb.core.Params">
<em class="property">class </em><code class="descclassname">orb.core.</code><code class="descname">Params</code><a class="headerlink" href="#orb.core.Params" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></p>
<p>Special dictionary which elements can be accessed like
attributes.</p>
<dl class="method">
<dt id="orb.core.Params.convert">
<code class="descname">convert</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Params.convert" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert to a nice pickable object</p>
</dd></dl>

<dl class="method">
<dt id="orb.core.Params.load">
<code class="descname">load</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Params.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Load data from an HDF5 file saved with save method.</p>
</dd></dl>

<dl class="method">
<dt id="orb.core.Params.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Params.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Try to save data in an HDF5 format.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">All elements might not be saved</p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="orb.core.ParamsFile">
<em class="property">class </em><code class="descclassname">orb.core.</code><code class="descname">ParamsFile</code><span class="sig-paren">(</span><em>file_path</em>, <em>reset=True</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.ParamsFile" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#orb.core.Tools" title="orb.core.Tools"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.core.Tools</span></code></a></p>
<p>Manage correspondance between multiple dict containing the
same parameters and a file on disk.</p>
<p>Its behaviour is similar to <code class="xref py py-class docutils literal notranslate"><span class="pre">astrometry.StarsParams</span></code>.</p>
<dl class="method">
<dt id="orb.core.ParamsFile.append">
<code class="descname">append</code><span class="sig-paren">(</span><em>params</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.ParamsFile.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Append a dict to the file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>params</strong> – A dict of parameters</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="orb.core.ParamsFile.f">
<code class="descname">f</code><em class="property"> = None</em><a class="headerlink" href="#orb.core.ParamsFile.f" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="orb.core.ParamsFile.get_data">
<code class="descname">get_data</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.ParamsFile.get_data" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="orb.core.ProgressBar">
<em class="property">class </em><code class="descclassname">orb.core.</code><code class="descname">ProgressBar</code><span class="sig-paren">(</span><em>max_index</em>, <em>silent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.ProgressBar" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Display a simple progress bar in the terminal</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>max_index</strong> – Index representing a 100% completed task.</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="orb.core.ProgressBar.BAR_LENGTH">
<code class="descname">BAR_LENGTH</code><em class="property"> = 10.0</em><a class="headerlink" href="#orb.core.ProgressBar.BAR_LENGTH" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="orb.core.ProgressBar.MAX_CARAC">
<code class="descname">MAX_CARAC</code><em class="property"> = 78</em><a class="headerlink" href="#orb.core.ProgressBar.MAX_CARAC" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="orb.core.ProgressBar.REFRESH_COUNT">
<code class="descname">REFRESH_COUNT</code><em class="property"> = 3L</em><a class="headerlink" href="#orb.core.ProgressBar.REFRESH_COUNT" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="orb.core.ProgressBar.end">
<code class="descname">end</code><span class="sig-paren">(</span><em>silent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.ProgressBar.end" title="Permalink to this definition">¶</a></dt>
<dd><p>End the progress bar and display the total time needed to
complete the process.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>silent</strong> – If True remove the progress bar from the
screen. Further diplayed text will be displayed above the
progress bar.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="orb.core.ProgressBar.update">
<code class="descname">update</code><span class="sig-paren">(</span><em>index</em>, <em>info=''</em>, <em>remains=True</em>, <em>nolog=True</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.ProgressBar.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the progress bar.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>index</strong> – Index representing the progress of the
process. Must be less than index_max.</li>
<li><strong>info</strong> – (Optional) Information to be displayed as
comments (default ‘’).</li>
<li><strong>remains</strong> – (Optional) If True, remaining time is
displayed (default True).</li>
<li><strong>nolog</strong> – (Optional) No logging of the printed text is
made (default True).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="orb.core.ROParams">
<em class="property">class </em><code class="descclassname">orb.core.</code><code class="descname">ROParams</code><a class="headerlink" href="#orb.core.ROParams" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#orb.core.Params" title="orb.core.Params"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.core.Params</span></code></a></p>
<p>Special dictionary which elements can be accessed like
attributes.</p>
<p>Attributes are read-only and may be defined only once.</p>
<dl class="method">
<dt id="orb.core.ROParams.reset">
<code class="descname">reset</code><span class="sig-paren">(</span><em>key</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.ROParams.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Force parameter reset</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="orb.core.TextColor">
<em class="property">class </em><code class="descclassname">orb.core.</code><code class="descname">TextColor</code><a class="headerlink" href="#orb.core.TextColor" title="Permalink to this definition">¶</a></dt>
<dd><p>Define ANSI Escape sequences to display text with colors.</p>
<dl class="attribute">
<dt id="orb.core.TextColor.CYAN">
<code class="descname">CYAN</code><em class="property"> = '\x1b[36m'</em><a class="headerlink" href="#orb.core.TextColor.CYAN" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="orb.core.TextColor.DEFAULT">
<code class="descname">DEFAULT</code><em class="property"> = '\x1b[0m'</em><a class="headerlink" href="#orb.core.TextColor.DEFAULT" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="orb.core.TextColor.END">
<code class="descname">END</code><em class="property"> = '\x1b[0m'</em><a class="headerlink" href="#orb.core.TextColor.END" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="orb.core.TextColor.GREEN">
<code class="descname">GREEN</code><em class="property"> = '\x1b[32m'</em><a class="headerlink" href="#orb.core.TextColor.GREEN" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="orb.core.TextColor.KORED">
<code class="descname">KORED</code><em class="property"> = '\x1b[91m'</em><a class="headerlink" href="#orb.core.TextColor.KORED" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="orb.core.TextColor.OKGREEN">
<code class="descname">OKGREEN</code><em class="property"> = '\x1b[92m'</em><a class="headerlink" href="#orb.core.TextColor.OKGREEN" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="orb.core.TextColor.RED">
<code class="descname">RED</code><em class="property"> = '\x1b[31m'</em><a class="headerlink" href="#orb.core.TextColor.RED" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="orb.core.TextColor.YELLOW">
<code class="descname">YELLOW</code><em class="property"> = '\x1b[33m'</em><a class="headerlink" href="#orb.core.TextColor.YELLOW" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="orb.core.Tools">
<em class="property">class </em><code class="descclassname">orb.core.</code><code class="descname">Tools</code><span class="sig-paren">(</span><em>instrument=None</em>, <em>config=None</em>, <em>data_prefix='./temp/data.'</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Tools" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Base parent class for processing classes.</p>
<p>Load instrument config file and give access to orb data files.</p>
<dl class="attribute">
<dt id="orb.core.Tools.filters">
<code class="descname">filters</code><em class="property"> = ['SN1', 'SN2', 'SN3', 'C1', 'C2', 'C3', 'C4', 'FULL']</em><a class="headerlink" href="#orb.core.Tools.filters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="orb.core.Tools.instruments">
<code class="descname">instruments</code><em class="property"> = ['sitelle', 'spiomm']</em><a class="headerlink" href="#orb.core.Tools.instruments" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="orb.core.Tools.load_sip">
<code class="descname">load_sip</code><span class="sig-paren">(</span><em>fits_path</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Tools.load_sip" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a astropy.wcs.WCS object from a FITS file containing
SIP parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>fits_path</strong> – Path to the FITS file</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="orb.core.Tools.save_sip">
<code class="descname">save_sip</code><span class="sig-paren">(</span><em>fits_path</em>, <em>hdr</em>, <em>overwrite=True</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Tools.save_sip" title="Permalink to this definition">¶</a></dt>
<dd><p>Save SIP parameters from a header to a blanck FITS file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>fits_path</strong> – Path to the FITS file</li>
<li><strong>hdr</strong> – header from which SIP parameters must be read</li>
<li><strong>overwrite</strong> – (Optional) Overwrite the FITS file.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="orb.core.Tools.set_config">
<code class="descname">set_config</code><span class="sig-paren">(</span><em>key</em>, <em>cast</em>, <em>optional=False</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Tools.set_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Set configuration parameter (from the configuration file)</p>
</dd></dl>

<dl class="method">
<dt id="orb.core.Tools.update_config">
<code class="descname">update_config</code><span class="sig-paren">(</span><em>config</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Tools.update_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Update config values from a dict</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>config</strong> – Configuration dictionary</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="orb.core.Vector1d">
<em class="property">class </em><code class="descclassname">orb.core.</code><code class="descname">Vector1d</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Vector1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#orb.core.Data" title="orb.core.Data"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.core.Data</span></code></a></p>
<p>Basic 1d vector management class.</p>
<p>Vector can have a projection axis.</p>
<dl class="method">
<dt id="orb.core.Vector1d.add">
<code class="descname">add</code><span class="sig-paren">(</span><em>vector</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Vector1d.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Add another vector. Note that, if the axis differs, only the
common part is kept.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>vector</strong> – Must be a Vector1d instance.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="orb.core.Vector1d.crop">
<code class="descname">crop</code><span class="sig-paren">(</span><em>xmin</em>, <em>xmax</em>, <em>returned_class=None</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Vector1d.crop" title="Permalink to this definition">¶</a></dt>
<dd><p>Crop data. 
:param xmin: xmin
:param xmax: xmax</p>
</dd></dl>

<dl class="method">
<dt id="orb.core.Vector1d.math">
<code class="descname">math</code><span class="sig-paren">(</span><em>opname</em>, <em>arg=None</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Vector1d.math" title="Permalink to this definition">¶</a></dt>
<dd><p>Do math operations with another vector instance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>opname</strong> – math operation, must be a numpy.ufuncs.</li>
<li><strong>arg</strong> – If None, no argument is supplied. Else, can be a
float or a Vector1d instance.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="orb.core.Vector1d.multiply">
<code class="descname">multiply</code><span class="sig-paren">(</span><em>vector</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Vector1d.multiply" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply by another vector. Note that, if the axis differs, only the
common part is kept.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>vector</strong> – Must be a Cm1Vector1d instance.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="orb.core.Vector1d.project">
<code class="descname">project</code><span class="sig-paren">(</span><em>new_axis</em>, <em>returned_class=None</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Vector1d.project" title="Permalink to this definition">¶</a></dt>
<dd><p>Project vector on a new axis</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>new_axis</strong> – Axis. Must be an orb.core.Axis instance.</li>
<li><strong>returned_class</strong> – (Optional) If not None, set the
returned class. Must be a subclass of Vector1d.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="orb.core.Vector1d.reverse">
<code class="descname">reverse</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Vector1d.reverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverse data. Do not reverse the axis.</p>
</dd></dl>

<dl class="method">
<dt id="orb.core.Vector1d.subtract">
<code class="descname">subtract</code><span class="sig-paren">(</span><em>vector</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Vector1d.subtract" title="Permalink to this definition">¶</a></dt>
<dd><p>Subtract another vector. Note that, if the axis differs, only the
common part is kept.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>vector</strong> – Must be a Cm1Vector1d instance.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="orb.core.Vector1d.sum">
<code class="descname">sum</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Vector1d.sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Sum of the data</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="orb.core.WCSData">
<em class="property">class </em><code class="descclassname">orb.core.</code><code class="descname">WCSData</code><span class="sig-paren">(</span><em>data</em>, <em>instrument=None</em>, <em>config=None</em>, <em>data_prefix='./'</em>, <em>sip=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.WCSData" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#orb.core.Data" title="orb.core.Data"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.core.Data</span></code></a>, <a class="reference internal" href="#orb.core.Tools" title="orb.core.Tools"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.core.Tools</span></code></a></p>
<p>Add WCS functionalities to a Data instance.</p>
<dl class="method">
<dt id="orb.core.WCSData.arc2pix">
<code class="descname">arc2pix</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.WCSData.arc2pix" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert pixels to arcseconds</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>x</strong> – a value or a vector in pixel</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="orb.core.WCSData.assert_dxdymaps">
<code class="descname">assert_dxdymaps</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.WCSData.assert_dxdymaps" title="Permalink to this definition">¶</a></dt>
<dd><p>Raise an exception if dxdymaps are not loaded</p>
</dd></dl>

<dl class="attribute">
<dt id="orb.core.WCSData.convert_params">
<code class="descname">convert_params</code><em class="property"> = {'AIRMASS': 'airmass', 'BINNING': 'binning', 'CAMERA': 'camera', 'EXPTIME': 'exposure_time', 'FILTER': 'filter_name', 'INSTRUME': 'instrument', 'camera_number': 'camera'}</em><a class="headerlink" href="#orb.core.WCSData.convert_params" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="orb.core.WCSData.default_params">
<code class="descname">default_params</code><em class="property"> = {'camera': 1, 'instrument': 'sitelle', 'target_dec': 0.0, 'target_ra': 0.0, 'target_x': 0, 'target_y': 0}</em><a class="headerlink" href="#orb.core.WCSData.default_params" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="orb.core.WCSData.get_initial_alignment_parameters">
<code class="descname">get_initial_alignment_parameters</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.WCSData.get_initial_alignment_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Return initial alignemnt coefficients for camera 2 as a core.Params instance</p>
</dd></dl>

<dl class="method">
<dt id="orb.core.WCSData.get_scale">
<code class="descname">get_scale</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.WCSData.get_scale" title="Permalink to this definition">¶</a></dt>
<dd><p>Return mean platescale in arcsec/pixel</p>
</dd></dl>

<dl class="method">
<dt id="orb.core.WCSData.get_wcs">
<code class="descname">get_wcs</code><span class="sig-paren">(</span><em>validate=True</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.WCSData.get_wcs" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the WCS of the cube as an astropy.wcs.WCS instance</p>
</dd></dl>

<dl class="method">
<dt id="orb.core.WCSData.get_wcs_header">
<code class="descname">get_wcs_header</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.WCSData.get_wcs_header" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the WCS of the cube as a astropy.io.fits.Header instance</p>
</dd></dl>

<dl class="method">
<dt id="orb.core.WCSData.has_dxdymaps">
<code class="descname">has_dxdymaps</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.WCSData.has_dxdymaps" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True is self.dxmap and self.dymap exist</p>
</dd></dl>

<dl class="method">
<dt id="orb.core.WCSData.is_cam1">
<code class="descname">is_cam1</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.WCSData.is_cam1" title="Permalink to this definition">¶</a></dt>
<dd><p>Return true is image comes from camera 1 or is a merged frame</p>
</dd></dl>

<dl class="method">
<dt id="orb.core.WCSData.is_cam2">
<code class="descname">is_cam2</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.WCSData.is_cam2" title="Permalink to this definition">¶</a></dt>
<dd><p>Return true is image comes from camera 2</p>
</dd></dl>

<dl class="method">
<dt id="orb.core.WCSData.pix2arc">
<code class="descname">pix2arc</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.WCSData.pix2arc" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert arcseconds to pixels</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>x</strong> – a value or a vector in arcsec</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="orb.core.WCSData.pix2world">
<code class="descname">pix2world</code><span class="sig-paren">(</span><em>xy</em>, <em>deg=True</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.WCSData.pix2world" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert pixel coordinates to celestial coordinates</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>xy</strong> – A tuple (x,y) of pixel coordinates or a list of
tuples ((x0,y0), (x1,y1), …)</li>
<li><strong>deg</strong> – (Optional) If true, celestial coordinates are
returned in sexagesimal format (default False).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">it is much more efficient to pass a list of
coordinates than run the function for each couple of
coordinates you want to transform.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="orb.core.WCSData.query_vizier">
<code class="descname">query_vizier</code><span class="sig-paren">(</span><em>catalog='gaia'</em>, <em>max_stars=100</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.WCSData.query_vizier" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of star coordinates around an object in a
given radius based on a query to VizieR Services
(<a class="reference external" href="http://vizier.u-strasbg.fr/viz-bin/VizieR">http://vizier.u-strasbg.fr/viz-bin/VizieR</a>)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>catalog</strong> – (Optional) Catalog to ask on the VizieR
database (see notes) (default ‘gaia’)</li>
<li><strong>max_stars</strong> – (Optional) Maximum number of row to retrieve
(default 100)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="orb.utils.html#orb.utils.web.query_vizier" title="orb.utils.web.query_vizier"><code class="xref py py-meth docutils literal notranslate"><span class="pre">orb.utils.web.query_vizier()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="orb.core.WCSData.set_dxdymaps">
<code class="descname">set_dxdymaps</code><span class="sig-paren">(</span><em>dxmap</em>, <em>dymap</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.WCSData.set_dxdymaps" title="Permalink to this definition">¶</a></dt>
<dd><p>Set dxmap and dymap. Must have the same shape as the image shape.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>dxmap</strong> – Path to a dxmap or a numpy.ndarray</li>
<li><strong>dymap</strong> – Path to a dymap or a numpy.ndarray</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="orb.core.WCSData.set_wcs">
<code class="descname">set_wcs</code><span class="sig-paren">(</span><em>wcs</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.WCSData.set_wcs" title="Permalink to this definition">¶</a></dt>
<dd><p>Set WCS from a WCS instance or a FITS image</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>wcs</strong> – Must be an astropy.wcs.WCS instance or a path to a FITS image</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="orb.core.WCSData.validate_wcs">
<code class="descname">validate_wcs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.WCSData.validate_wcs" title="Permalink to this definition">¶</a></dt>
<dd><p>Verify the internal coherence between comprehensive wcs parameters
and FITS keywords.</p>
</dd></dl>

<dl class="method">
<dt id="orb.core.WCSData.world2pix">
<code class="descname">world2pix</code><span class="sig-paren">(</span><em>radec</em>, <em>deg=True</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.WCSData.world2pix" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert celestial coordinates to pixel coordinates</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>xy</strong> – A tuple (x,y) of celestial coordinates or a list of
tuples ((x0,y0), (x1,y1), …). Must be in degrees.</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">it is much more effficient to pass a list of
coordinates than run the function for each couple of
coordinates you want to transform.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="orb.core.WCSData.writeto">
<code class="descname">writeto</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.WCSData.writeto" title="Permalink to this definition">¶</a></dt>
<dd><p>Write data to an hdf file</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>path</strong> – hdf file path.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="orb.core.Waves">
<em class="property">class </em><code class="descclassname">orb.core.</code><code class="descname">Waves</code><span class="sig-paren">(</span><em>nm</em>, <em>velocity=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Waves" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Wave class that keep the best conversions possible from nm to cm1.</p>
<dl class="method">
<dt id="orb.core.Waves.get_cm1">
<code class="descname">get_cm1</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Waves.get_cm1" title="Permalink to this definition">¶</a></dt>
<dd><p>Return wavenumber of waves in cm-1 (taking velocity into account)</p>
</dd></dl>

<dl class="method">
<dt id="orb.core.Waves.get_cm1_rest">
<code class="descname">get_cm1_rest</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Waves.get_cm1_rest" title="Permalink to this definition">¶</a></dt>
<dd><p>Return restframe wavelength of waves in cm-1</p>
</dd></dl>

<dl class="method">
<dt id="orb.core.Waves.get_nm">
<code class="descname">get_nm</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Waves.get_nm" title="Permalink to this definition">¶</a></dt>
<dd><p>Return wavelength of waves in nm (taking velocity into account)</p>
</dd></dl>

<dl class="method">
<dt id="orb.core.Waves.get_nm_rest">
<code class="descname">get_nm_rest</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Waves.get_nm_rest" title="Permalink to this definition">¶</a></dt>
<dd><p>“Return restframe wavelength of waves in nm</p>
</dd></dl>

<dl class="method">
<dt id="orb.core.Waves.set_velocity">
<code class="descname">set_velocity</code><span class="sig-paren">(</span><em>velocity</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Waves.set_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Set waves velocity.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>velocity</strong> – velocity in km/s</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-orb.cutils">
<span id="orb-cutils-module"></span><h2>orb.cutils module<a class="headerlink" href="#module-orb.cutils" title="Permalink to this headline">¶</a></h2>
<p>CUtils is a set of C functions coded in <a class="reference external" href="http://cython.org/">Cython</a> to improve their speed.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>This file must be compiled before it can be used:</p>
<p>cython cutils.pyx</p>
<p>gcc -c -fPIC -I/usr/include/python2.7 cutils.c</p>
<p class="last">gcc -shared cutils.o -o cutils.so</p>
</div>
<dl class="function">
<dt id="orb.cutils.brute_photometry">
<code class="descclassname">orb.cutils.</code><code class="descname">brute_photometry</code><span class="sig-paren">(</span><em>ndarray im</em>, <em>ndarray star_list</em>, <em>ndarray kernel</em>, <em>int box_size</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.brute_photometry" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="orb.cutils.check_cosmic_rays_neighbourhood">
<code class="descclassname">orb.cutils.</code><code class="descname">check_cosmic_rays_neighbourhood</code><span class="sig-paren">(</span><em>ndarray frame</em>, <em>ndarray cr_map</em>, <em>int box_size</em>, <em>double detect_coeff</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.check_cosmic_rays_neighbourhood" title="Permalink to this definition">¶</a></dt>
<dd><p>Check the neighbourhood around detected cosmic rays in a frame.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>frame</strong> – Frame to check</li>
<li><strong>cr_map</strong> – Map of the cosimic-rays positions (boolean map, 1
is a cosmic ray)</li>
<li><strong>box_size</strong> – Size of the box checked around each cr.</li>
<li><strong>detect_coeff</strong> – Coefficient of detection (number of sigmas
threshold)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.cutils.complex_dft">
<code class="descclassname">orb.cutils.</code><code class="descname">complex_dft</code><span class="sig-paren">(</span><em>ndarray a</em>, <em>ndarray x</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.complex_dft" title="Permalink to this definition">¶</a></dt>
<dd><p>Discret Fourier Transform.</p>
<p>Compute an irregularly sampled spectrum from a complex regularly
sampled interferogram.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>a</strong> – complex regularly sampled interferogram.</li>
<li><strong>x</strong> – positions of the spectrum samples. If x =
range(size(a)), this function is equivalent to an fft. Note that
the fft is of course much faster to compute. This vector may
have any length.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.cutils.create_transform_maps">
<code class="descclassname">orb.cutils.</code><code class="descname">create_transform_maps</code><span class="sig-paren">(</span><em>int nx</em>, <em>int ny</em>, <em>double dx</em>, <em>double dy</em>, <em>double dr</em>, <em>double da</em>, <em>double db</em>, <em>double xrc</em>, <em>double yrc</em>, <em>double zx</em>, <em>double zy</em>, <em>sip_A</em>, <em>sip_B</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.create_transform_maps" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the 2 transformation maps used to compute the
geometrical transformation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>nx</strong> – size of the frame along x axis</li>
<li><strong>ny</strong> – size of the frame along y axis</li>
<li><strong>dx</strong> – translation along x</li>
<li><strong>dy</strong> – translation along y</li>
<li><strong>dr</strong> – rotation in the plane of the image</li>
<li><strong>da</strong> – tip angle</li>
<li><strong>db</strong> – tilt angle</li>
<li><strong>xrc</strong> – x coordinate of the rotation center</li>
<li><strong>yrc</strong> – y coordinate of the rotation center</li>
<li><strong>zx</strong> – zoom coefficient along x</li>
<li><strong>zy</strong> – zoom coefficient along y</li>
<li><strong>sip_A</strong> – pywcs.WCS() instance containing SIP parameters of
the output image.</li>
<li><strong>sip_B</strong> – pywcs.WCS() instance containing SIP parameters of
the input image.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.cutils.detect_cosmic_rays">
<code class="descclassname">orb.cutils.</code><code class="descname">detect_cosmic_rays</code><span class="sig-paren">(</span><em>ndarray frame</em>, <em>crs_list</em>, <em>int box_size</em>, <em>double detect_coeff</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.detect_cosmic_rays" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if a given pixel is a cosmic ray (classic detection).</p>
<p>classic detection: pixel value is checked against standard
deviation of values in a box around the pixel.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>frame</strong> – Frame to check</li>
<li><strong>crs_list</strong> – List of pixels to check</li>
<li><strong>box_size</strong> – Size of the box in pixels</li>
<li><strong>detect_coeff</strong> – Coefficient of detection (number of sigmas
threshold)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.cutils.dft">
<code class="descclassname">orb.cutils.</code><code class="descname">dft</code><span class="sig-paren">(</span><em>ndarray a</em>, <em>ndarray x</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.dft" title="Permalink to this definition">¶</a></dt>
<dd><p>Discret Fourier Transform.</p>
<p>Compute an irregularly sampled spectrum from a regularly
sampled interferogram.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>a</strong> – regularly sampled interferogram.</li>
<li><strong>x</strong> – positions of the spectrum samples. If x =
range(size(a)), this function is equivalent to an fft. Note that
the fft is of course much faster to compute. This vector may
have any length.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.cutils.fast_gaussian_kernel">
<code class="descclassname">orb.cutils.</code><code class="descname">fast_gaussian_kernel</code><span class="sig-paren">(</span><em>int deg</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.fast_gaussian_kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a fast gaussian kernel.</p>
<p>The value of each pixel is just the value of the gaussian at the
center of the pixel.</p>
<p>The degree gives the size of the kernel’s side : size = 2 * deg + 1</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>deg</strong> – The degree of the kernel. Must be an integer &gt;= 0.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.cutils.fast_pix2w">
<code class="descclassname">orb.cutils.</code><code class="descname">fast_pix2w</code><span class="sig-paren">(</span><em>ndarray pix</em>, <em>double axis_min</em>, <em>double axis_step</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.fast_pix2w" title="Permalink to this definition">¶</a></dt>
<dd><p>Fast conversion of pixel to wavelength/wavenumber</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>pix</strong> – position along axis in pixels</li>
<li><strong>axis_min</strong> – min axis wavelength/wavenumber</li>
<li><strong>axis_step</strong> – axis step size in wavelength/wavenumber</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.cutils.fast_w2pix">
<code class="descclassname">orb.cutils.</code><code class="descname">fast_w2pix</code><span class="sig-paren">(</span><em>ndarray w</em>, <em>double axis_min</em>, <em>double axis_step</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.fast_w2pix" title="Permalink to this definition">¶</a></dt>
<dd><p>Fast conversion of wavelength/wavenumber to pixel</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>w</strong> – wavelength/wavenumber</li>
<li><strong>axis_min</strong> – min axis wavelength/wavenumber</li>
<li><strong>axis_step</strong> – axis step size in wavelength/wavenumber</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.cutils.fft_filter">
<code class="descclassname">orb.cutils.</code><code class="descname">fft_filter</code><span class="sig-paren">(</span><em>ndarray a</em>, <em>double cutoff</em>, <em>double width</em>, <em>bool lowpass</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.fft_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Simple lowpass or highpass FFT filter (high pass or low pass)</p>
<p>Filter shape is a gaussian.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>a</strong> – a 1D float64 vector</li>
<li><strong>cutoff_coeff</strong> – Coefficient defining the position of the cutoff
frequency (Cutoff frequency = cutoff_coeff * vector length)</li>
<li><strong>width_coeff</strong> – Coefficient defining the width of
the smoothed part of the filter (width = width_coeff * vector
length)</li>
<li><strong>lowpass</strong> – If True filter will be ‘low_pass’ and ‘high_pass’
if False.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.cutils.filter_background">
<code class="descclassname">orb.cutils.</code><code class="descname">filter_background</code><span class="sig-paren">(</span><em>ndarray frame</em>, <em>int box_size</em>, <em>int big_box_coeff</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.filter_background" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace each pixel by the value in a box around it minus the
median of the baclground.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>frame</strong> – Frame to filter</li>
<li><strong>box_size</strong> – Size of the box</li>
<li><strong>big_box_coeff</strong> – Coeff by which the bo size is multiplied to
get the background box size.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.cutils.gaussian1d">
<code class="descclassname">orb.cutils.</code><code class="descname">gaussian1d</code><span class="sig-paren">(</span><em>ndarray x</em>, <em>double h</em>, <em>double a</em>, <em>double dx</em>, <em>double fwhm</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.gaussian1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a 1D gaussian given a set of parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> – 1D array of float64 giving the positions where the
gaussian is evaluated</li>
<li><strong>h</strong> – Height</li>
<li><strong>a</strong> – Amplitude</li>
<li><strong>dx</strong> – Position of the center</li>
<li><strong>w</strong> – FWHM, <img src="_images/mathmpl/math-c0419d808a.png" /></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.cutils.gaussian_array2d">
<code class="descclassname">orb.cutils.</code><code class="descname">gaussian_array2d</code><span class="sig-paren">(</span><em>double h</em>, <em>double a</em>, <em>double dx</em>, <em>double dy</em>, <em>double fwhm</em>, <em>int nx</em>, <em>int ny</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.gaussian_array2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the 2D profile of a gaussian</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>h</strong> – Height</li>
<li><strong>a</strong> – Amplitude</li>
<li><strong>dx</strong> – X position</li>
<li><strong>dy</strong> – Y position</li>
<li><strong>fwhm</strong> – FWHM</li>
<li><strong>nx</strong> – X dimension of the output array</li>
<li><strong>ny</strong> – Y dimension of the output array</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.cutils.gaussian_kernel">
<code class="descclassname">orb.cutils.</code><code class="descname">gaussian_kernel</code><span class="sig-paren">(</span><em>double deg</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.gaussian_kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a gaussian kernel.</p>
<p>The value of each pixel is the integral of the gaussian over the
whole pixel because the shape of the gaussian is not linear at
all. The estimation is done by subdividing each pixel in 9
sub-pixels.</p>
<p>The degree gives the size of the kernel’s side : size = 2 * deg + 1</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>deg</strong> – The degree of the kernel. Must be an integer &gt;= 0.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.cutils.get_box_coords">
<code class="descclassname">orb.cutils.</code><code class="descname">get_box_coords</code><span class="sig-paren">(</span><em>int ix</em>, <em>int iy</em>, <em>int box_size</em>, <em>int x_lim_min</em>, <em>int x_lim_max</em>, <em>int y_lim_min</em>, <em>int y_lim_max</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.get_box_coords" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the coordinates of a box given the center of the box,
its size and the limits of the range along x and y axes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>ix</strong> – center of the box along x axis</li>
<li><strong>iy</strong> – center of the box along y axis</li>
<li><strong>box_size</strong> – Size of the box. The final size of the box will
generally be the same if box_size is odd. Note that the final
size of the box cannot be guaranteed.</li>
<li><strong>x_lim_min</strong> – Minimum limit of the range along x.</li>
<li><strong>x_lim_max</strong> – Maximum limit of the range along x.</li>
<li><strong>y_lim_min</strong> – Minimum limit of the range along y.</li>
<li><strong>y_lim_max</strong> – Maximum limit of the range along y.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">x_min, x_max, y_min, y_max</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.cutils.get_cm1_axis_max">
<code class="descclassname">orb.cutils.</code><code class="descname">get_cm1_axis_max</code><span class="sig-paren">(</span><em>int n</em>, <em>double step</em>, <em>int order</em>, <em>double corr=1.</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.get_cm1_axis_max" title="Permalink to this definition">¶</a></dt>
<dd><p>Return max wavenumber of a regular wavenumber axis in cm-1.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>n</strong> – Number of steps on the axis</li>
<li><strong>step</strong> – Step size in nm</li>
<li><strong>order</strong> – Folding order</li>
<li><strong>corr</strong> – (Optional) Coefficient of correction (default 1.)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.cutils.get_cm1_axis_min">
<code class="descclassname">orb.cutils.</code><code class="descname">get_cm1_axis_min</code><span class="sig-paren">(</span><em>int n</em>, <em>double step</em>, <em>int order</em>, <em>double corr=1.</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.get_cm1_axis_min" title="Permalink to this definition">¶</a></dt>
<dd><p>Return min wavenumber of a regular wavenumber axis in cm-1.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>n</strong> – Number of steps on the axis</li>
<li><strong>step</strong> – Step size in nm</li>
<li><strong>order</strong> – Folding order</li>
<li><strong>corr</strong> – (Optional) Coefficient of correction (default 1.)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.cutils.get_cm1_axis_step">
<code class="descclassname">orb.cutils.</code><code class="descname">get_cm1_axis_step</code><span class="sig-paren">(</span><em>int n</em>, <em>double step</em>, <em>double corr=1.</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.get_cm1_axis_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Return step size of a regular wavenumber axis in cm-1.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>n</strong> – Number of steps on the axis</li>
<li><strong>step</strong> – Step size in nm</li>
<li><strong>corr</strong> – (Optional) Coefficient of correction (default 1.)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.cutils.get_nm_axis_max">
<code class="descclassname">orb.cutils.</code><code class="descname">get_nm_axis_max</code><span class="sig-paren">(</span><em>int n</em>, <em>double step</em>, <em>int order</em>, <em>double corr=1.</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.get_nm_axis_max" title="Permalink to this definition">¶</a></dt>
<dd><p>Return max wavelength of regular wavelength axis in nm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>n</strong> – Number of steps on the axis</li>
<li><strong>step</strong> – Step size in nm</li>
<li><strong>order</strong> – Folding order (cannot be 0)</li>
<li><strong>corr</strong> – (Optional) Coefficient of correction (default 1.)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.cutils.get_nm_axis_min">
<code class="descclassname">orb.cutils.</code><code class="descname">get_nm_axis_min</code><span class="sig-paren">(</span><em>int n</em>, <em>double step</em>, <em>int order</em>, <em>double corr=1.</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.get_nm_axis_min" title="Permalink to this definition">¶</a></dt>
<dd><p>Return min wavelength of regular wavelength axis in nm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>n</strong> – Number of steps on the axis</li>
<li><strong>step</strong> – Step size in nm</li>
<li><strong>order</strong> – Folding order (cannot be 0)</li>
<li><strong>corr</strong> – (Optional) Coefficient of correction (default 1.)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.cutils.get_nm_axis_step">
<code class="descclassname">orb.cutils.</code><code class="descname">get_nm_axis_step</code><span class="sig-paren">(</span><em>int n</em>, <em>double step</em>, <em>int order</em>, <em>double corr=1.</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.get_nm_axis_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Return step size of a regular wavelength axis in nm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>n</strong> – Number of steps on the axis</li>
<li><strong>step</strong> – Step size in nm</li>
<li><strong>order</strong> – Folding order (cannot be 0)</li>
<li><strong>corr</strong> – (Optional) Coefficient of correction (default 1.)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.cutils.im2rgba">
<code class="descclassname">orb.cutils.</code><code class="descname">im2rgba</code><span class="sig-paren">(</span><em>ndarray im</em>, <em>mpl_colorbar</em>, <em>double vmin</em>, <em>double vmax</em>, <em>int xmin</em>, <em>int xmax</em>, <em>int ymin</em>, <em>int ymax</em>, <em>ndarray computed_pixels</em>, <em>last_arr8</em>, <em>int res=1000</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.im2rgba" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute RGBA from image given a matplotlib colorbar instance.</p>
<p>This is a function used by <code class="xref py py-class docutils literal notranslate"><span class="pre">orb.visual.ImageCanvas</span></code>. It
is not a generalist function. It has been written to accelerate
matplotlib function colorbar.to_rgba().</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>im</strong> – Image</li>
<li><strong>mpl_colorbar</strong> – A matplotlib colorbar instance</li>
<li><strong>vmin</strong> – min value of the colorbar</li>
<li><strong>vmax</strong> – max value of the colorbar</li>
<li><strong>xmin</strong> – min x index of the region to compute</li>
<li><strong>xmax</strong> – max x index of the region to compute</li>
<li><strong>ymin</strong> – min y index of the region to compute</li>
<li><strong>ymax</strong> – max y index of the region to compute</li>
<li><strong>computed_pixels</strong> – Array giving the already computed pixels</li>
<li><strong>last_arr8</strong> – If not None, last computed array.</li>
<li><strong>res</strong> – (Optional) Lookup table resolution (default 1000)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.cutils.indft">
<code class="descclassname">orb.cutils.</code><code class="descname">indft</code><span class="sig-paren">(</span><em>ndarray a</em>, <em>ndarray x</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.indft" title="Permalink to this definition">¶</a></dt>
<dd><p>Inverse Non-uniform Discret Fourier Transform.</p>
<p>Compute the irregularly sampled interferogram from a regularly
sampled spectrum.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>a</strong> – regularly sampled spectrum.</li>
<li><strong>x</strong> – positions of the interferogram samples. If x =
range(size(a)), this function is equivalent to an idft or a
ifft. Note that the ifft is of course much faster to
compute. This vector may have any length.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.cutils.interf_mean_energy">
<code class="descclassname">orb.cutils.</code><code class="descname">interf_mean_energy</code><span class="sig-paren">(</span><em>ndarray interf</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.interf_mean_energy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the mean energy of an interferogram by step.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>interf</strong> – an interferogram</td>
</tr>
</tbody>
</table>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The mean of the interferogram is substracted to
compute only the modulation energy. This is the modulation
energy which must be conserved in the resulting spectrum. Note
that the interferogram transformation function (see
<code class="xref py py-meth docutils literal notranslate"><span class="pre">utils.transform_interferogram()</span></code>) remove the mean of the
interferogram before computing its FFT.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">NaNs are counted as zeros.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="orb.cutils.low_pass_image_filter">
<code class="descclassname">orb.cutils.</code><code class="descname">low_pass_image_filter</code><span class="sig-paren">(</span><em>ndarray im</em>, <em>int deg</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.low_pass_image_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Low pass image filter by convolution with a gaussian kernel.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>im</strong> – Image to filter</li>
<li><strong>deg</strong> – Kernel degree</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.cutils.map_me">
<code class="descclassname">orb.cutils.</code><code class="descname">map_me</code><span class="sig-paren">(</span><em>ndarray frame</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.map_me" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a map of the modulation efficiency from a laser frame.</p>
<p>The more fringes the best are the results.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>frame</strong> – laser frame.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.cutils.master_combine">
<code class="descclassname">orb.cutils.</code><code class="descname">master_combine</code><span class="sig-paren">(</span><em>ndarray frames</em>, <em>double sigma</em>, <em>int nkeep</em>, <em>int combine_mode</em>, <em>int reject_mode</em>, <em>return_std_frame=False</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.master_combine" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a master frame from a set a frames.</p>
<p>This method has been inspired by the <strong>IRAF</strong> function
combine.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>frames</strong> – Frames to be combined.</li>
<li><strong>sigma</strong> – Sigma factor for pixel rejection.</li>
<li><strong>nkeep</strong> – Minimum number of values to keep before
combining operation</li>
<li><strong>combine_mode</strong> – 0, mean ; 1, median.</li>
<li><strong>reject_mode</strong> – 0, avsigclip ; 1, sigclip ; 2, minmax.</li>
<li><strong>return_std</strong> – If True, the std frame is also returned
(default False).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Rejection operations:</p>
<ul class="last simple">
<li><strong>sigclip</strong>: A Sigma Clipping algorithm is applied for
each pixel. Min and max values are rejected to estimate
the mean and the standard deviation at each pixel. Then
all values over (median + sigma * std) or below (median -
sigma * std) are rejected. Those steps are repeated (this
time not excluding the extreme values) while no other
value is rejected or the minimum number of values to keep
is reached. Work best with at least 10 frames.</li>
<li><strong>avsigclip</strong>: Average Sigma Clipping algorithm is the
same as Sigma Clipping algorithm but the standard
deviation at each pixel is estimated using an averaged
value of the std over the lines. This work best than sigma
clipping for a small number of frames. This algorithm is a
little more time consuming than the others. Works best with
at least 5 frames.</li>
<li><strong>minmax</strong>: Minimum and maximum values at each pixel are
rejected.</li>
</ul>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">No rejection operation can be performed with less
than 3 frames.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="orb.cutils.mean2d">
<code class="descclassname">orb.cutils.</code><code class="descname">mean2d</code><span class="sig-paren">(</span><em>ndarray box</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.mean2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the mean of a 2d box with no GIL</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>box</strong> – 2d array</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.cutils.meansigcut2d">
<code class="descclassname">orb.cutils.</code><code class="descname">meansigcut2d</code><span class="sig-paren">(</span><em>ndarray x</em>, <em>double sigma=3</em>, <em>int min_values=3</em>, <em>int axis=0</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.meansigcut2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sigma cut mean of a 2d array along a given axis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> – The 2d array</li>
<li><strong>sigma</strong> – Number of sigma above which values are considered as
deviant</li>
<li><strong>min_values</strong> – Minimum number of values to return</li>
<li><strong>axis</strong> – Axis number. Must be 0 or 1.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.cutils.median2d">
<code class="descclassname">orb.cutils.</code><code class="descname">median2d</code><span class="sig-paren">(</span><em>ndarray box</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.median2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the median of a 2d box with no GIL</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>box</strong> – 2d array</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.cutils.moffat_array2d">
<code class="descclassname">orb.cutils.</code><code class="descname">moffat_array2d</code><span class="sig-paren">(</span><em>double h</em>, <em>double a</em>, <em>double dx</em>, <em>double dy</em>, <em>double fwhm</em>, <em>double beta</em>, <em>int nx</em>, <em>int ny</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.moffat_array2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the 2D profile of a moffat</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>h</strong> – Height</li>
<li><strong>a</strong> – Amplitude</li>
<li><strong>dx</strong> – X position</li>
<li><strong>dy</strong> – Y position</li>
<li><strong>fwhm</strong> – FWHM</li>
<li><strong>beta</strong> – Beta</li>
<li><strong>nx</strong> – X dimension of the output array</li>
<li><strong>ny</strong> – Y dimension of the output array</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.cutils.multi_fit_stars">
<code class="descclassname">orb.cutils.</code><code class="descname">multi_fit_stars</code><span class="sig-paren">(</span><em>ndarray frame, ndarray pos, int box_size, double height_guess=np.nan, ndarray fwhm_guess=np.array([np.nan], dtype=float), bool cov_height=False, bool cov_pos=True, bool cov_fwhm=True, bool fix_height=False, bool fix_pos=False, bool fix_fwhm=False, double fit_tol=1e-3, double ron=np.nan, double dcl=np.nan, bool enable_zoom=False, bool enable_rotation=False, bool estimate_local_noise=True, double saturation=0, sip=None</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.multi_fit_stars" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit multiple stars at the same time.</p>
<p>Useful if the relative positions of the stars are well known. In
this case the pattern of position can be shifted, zoomed and
rotated in order to be adjusted to the stars in the frame.</p>
<p>Other covarying parameters can be the height and the FWHM.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>frame</strong> – Frame</li>
<li><strong>pos</strong> – array of stars positions of shape [[x1, y1], [x2, y2] …]</li>
<li><strong>box_size</strong> – Size of the box around a single star</li>
<li><strong>height_guess</strong> – (Optional) Initial guess on the height
parameter (default NaN).</li>
<li><strong>fwhm_guess</strong> – (Optional) Initial guess on the FWHM parameter
must a numpy.ndarray.</li>
<li><strong>cov_height</strong> – (Optional) If True, height is considered to be
the same for all the stars. It is then a covarying parameter
(default False).</li>
<li><strong>cov_pos</strong> – (Optional) If True, shift along x and y is
considered as the same for all the stars. dx and dy are thus 2
covarying parameters (default True).</li>
<li><strong>cov_fwhm</strong> – (Optional) If True, FWHM is considered to be the
same for all the stars. It is then a covarying parameter
(default True).</li>
<li><strong>fix_height</strong> – (Optional) If True, height is fixed to its
guess (default False).</li>
<li><strong>fix_pos</strong> – (Optional) If True, x and y are fixed to the position
guess given by pos (default False).</li>
<li><strong>fix_fwhm</strong> – (Optional) If True, FWHM is fixed to its guess
(default False).</li>
<li><strong>fit_tol</strong> – (Optional) Tolerance on the fit (default 1e-3).</li>
<li><strong>ron</strong> – (Optional) Readout noise. If given and if
estimate_local_noise is set to False the readout noise is fixed
to the given value. If not given the ron is guessed from the
background around the stars (default NaN).</li>
<li><strong>dcl</strong> – (Optional) Dark current level. If given and if
estimate_local_noise is set to False the dark current level is
fixed to the given value. If not given the dark current level is
fixed to 0. (default NaN)</li>
<li><strong>enable_zoom</strong> – (Optional) If True the position pattern can be
zoomed (default False).</li>
<li><strong>enable_rotation</strong> – (Optional) If True the position pattern
can be rotated (default False).</li>
<li><strong>estimate_local_noise</strong> – (Optional) If True, the level of
noise is computed from the background pixels around the
stars. ron and dcl parameters are thus not used (default True).</li>
<li><strong>saturation</strong> – (Optional) If not 0, all pixels above the
saturation level are removed from the fit (default 0).</li>
<li><strong>sip</strong> – (Optional) A pywcs.WCS instance containing SIP
distorsion correction (default None).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.cutils.nanbin_image">
<code class="descclassname">orb.cutils.</code><code class="descname">nanbin_image</code><span class="sig-paren">(</span><em>ndarray im</em>, <em>int binning</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.nanbin_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Mean image binning robust to NaNs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>im</strong> – Image to bin</li>
<li><strong>binning</strong> – Binning factor (must be an integer)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.cutils.part_value">
<code class="descclassname">orb.cutils.</code><code class="descname">part_value</code><span class="sig-paren">(</span><em>ndarray distrib</em>, <em>double coeff</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.part_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the value lying between two parts of a partition</p>
<p>The partition process is nan robusts. It is made over a
distribution cleaned from nans.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>distrib</strong> – A 1D array of floats.</li>
<li><strong>coeff</strong> – Partition coefficient (must be &gt;= 0. and &lt;= 1.). If
0 return the min of the distribution and if 1 return the max.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.cutils.point_inside_polygon">
<code class="descclassname">orb.cutils.</code><code class="descname">point_inside_polygon</code><span class="sig-paren">(</span><em>double x</em>, <em>double y</em>, <em>list poly</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.point_inside_polygon" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if a point is inside a given polygon or not
Polygon is a list of (x,y) pairs.</p>
<p>This function has been taken from
<a class="reference external" href="http://www.ariel.com.au/a/python-point-int-poly.html">http://www.ariel.com.au/a/python-point-int-poly.html</a> and cythonized.</p>
</dd></dl>

<dl class="function">
<dt id="orb.cutils.radians">
<code class="descclassname">orb.cutils.</code><code class="descname">radians</code><span class="sig-paren">(</span><em>double deg</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.radians" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert degrees to radians</p>
</dd></dl>

<dl class="function">
<dt id="orb.cutils.robust_average">
<code class="descclassname">orb.cutils.</code><code class="descname">robust_average</code><span class="sig-paren">(</span><em>ndarray x</em>, <em>ndarray w</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.robust_average" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute robust average of a numpy ndarray (NaNs are skipped)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> – a numpy ndarray</li>
<li><strong>w</strong> – a numpy ndarray of weigths</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">To get a weighted average the MEAN of the weights must
be equal to 1.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="orb.cutils.robust_mean">
<code class="descclassname">orb.cutils.</code><code class="descname">robust_mean</code><span class="sig-paren">(</span><em>ndarray x</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.robust_mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute robust mean of a numpy ndarray (NaNs are skipped)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>x</strong> – a numpy ndarray</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.cutils.robust_median">
<code class="descclassname">orb.cutils.</code><code class="descname">robust_median</code><span class="sig-paren">(</span><em>ndarray x</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.robust_median" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute robust median of a numpy ndarray (NaNs are skipped)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>x</strong> – a numpy ndarray</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.cutils.robust_std">
<code class="descclassname">orb.cutils.</code><code class="descname">robust_std</code><span class="sig-paren">(</span><em>ndarray x</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.robust_std" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute robust std of a numpy ndarray (NaNs are skipped)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>x</strong> – a numpy ndarray</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.cutils.robust_sum">
<code class="descclassname">orb.cutils.</code><code class="descname">robust_sum</code><span class="sig-paren">(</span><em>ndarray x</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.robust_sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute robust sum of a numpy ndarray (NaNs are skipped)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>x</strong> – a numpy ndarray</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.cutils.sigmaclip">
<code class="descclassname">orb.cutils.</code><code class="descname">sigmaclip</code><span class="sig-paren">(</span><em>ndarray x</em>, <em>double sigma</em>, <em>int min_values</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.sigmaclip" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a distribution after a sigma clipping rejection
of the too deviant values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> – The distribution to sigmaclip</li>
<li><strong>sigma</strong> – Number of sigma above which values are considered as
deviant</li>
<li><strong>min_values</strong> – Minimum number of values to return</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.cutils.sigmacut">
<code class="descclassname">orb.cutils.</code><code class="descname">sigmacut</code><span class="sig-paren">(</span><em>ndarray x</em>, <em>double central_value</em>, <em>int use_central_value</em>, <em>double sigma</em>, <em>int min_values</em>, <em>return_index_list=False</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.sigmacut" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a distribution after a sigma cut rejection
of the too deviant values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> – The distribution to cut</li>
<li><strong>sigma</strong> – Number of sigma above which values are considered as
deviant</li>
<li><strong>min_values</strong> – Minimum number of values to return</li>
<li><strong>central_value</strong> – If not none, this value is used as the
central value of the cut. Else the median of the distribution is
used as the central value</li>
<li><strong>use_central_value</strong> – If True central value is used instead of
the median.</li>
<li><strong>return_index_list</strong> – (Optional) If True the list of the non
rejected values is returned also (default False).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.cutils.sinc1d">
<code class="descclassname">orb.cutils.</code><code class="descname">sinc1d</code><span class="sig-paren">(</span><em>ndarray x</em>, <em>double h</em>, <em>double a</em>, <em>double dx</em>, <em>double fwhm</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.sinc1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a 1D sinc given a set of parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> – 1D array of float64 giving the positions where the
sinc is evaluated</li>
<li><strong>h</strong> – Height</li>
<li><strong>a</strong> – Amplitude</li>
<li><strong>dx</strong> – Position of the center</li>
<li><strong>w</strong> – FWHM, <img src="_images/mathmpl/math-c0419d808a.png" /></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.cutils.sip_im2pix">
<code class="descclassname">orb.cutils.</code><code class="descname">sip_im2pix</code><span class="sig-paren">(</span><em>ndarray im_coords</em>, <em>sip</em>, <em>tolerance=1e-8</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.sip_im2pix" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform perfect pixel positions to distorded pixels positions</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>im_coords</strong> – perfect pixel positions as an Nx2 array of floats.</li>
<li><strong>sip</strong> – pywcs.WCS() instance containing SIP parameters.</li>
<li><strong>tolerance</strong> – tolerance on the iterative method.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">SIP.foc2pix must be used instead</p>
</div>
</dd></dl>

<dl class="function">
<dt id="orb.cutils.sip_pix2im">
<code class="descclassname">orb.cutils.</code><code class="descname">sip_pix2im</code><span class="sig-paren">(</span><em>ndarray pix_coords</em>, <em>sip</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.sip_pix2im" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform distorded pixel positions to perfect pixels positions</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>pix_coords</strong> – distorded pixel positions as an Nx2 array of floats.</li>
<li><strong>sip</strong> – pywcs.WCS() instance containing SIP parameters.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">SIP.pix2foc must be used instead</p>
</div>
</dd></dl>

<dl class="function">
<dt id="orb.cutils.spectrum_mean_energy">
<code class="descclassname">orb.cutils.</code><code class="descname">spectrum_mean_energy</code><span class="sig-paren">(</span><em>ndarray spectrum</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.spectrum_mean_energy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the mean energy of a spectrum by channel.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>spectrum</strong> – a 1D spectrum</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">NaNs are counted as zeros.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="orb.cutils.surface_value">
<code class="descclassname">orb.cutils.</code><code class="descname">surface_value</code><span class="sig-paren">(</span><em>int dimx</em>, <em>int dimy</em>, <em>double xc</em>, <em>double yc</em>, <em>double rmin</em>, <em>double rmax</em>, <em>long sub_div</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.surface_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an approximation of the surface value of a pixel given
the min and max radius of an annulus in pixels.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>dimx</strong> – dimension of the box along x</li>
<li><strong>dimy</strong> – dimension of the box along y</li>
<li><strong>xc</strong> – center of the annulus along x</li>
<li><strong>yc</strong> – center of the annulus along y</li>
<li><strong>rmin</strong> – min radius of the annulus</li>
<li><strong>rmax</strong> – max radius of the annulus</li>
<li><strong>sub_div</strong> – Number of subdivisions to make (the higher,the
better but the longer too)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.cutils.transform_A_to_B">
<code class="descclassname">orb.cutils.</code><code class="descname">transform_A_to_B</code><span class="sig-paren">(</span><em>double x1</em>, <em>double y1</em>, <em>double dx</em>, <em>double dy</em>, <em>double dr</em>, <em>double da</em>, <em>double db</em>, <em>double xrc</em>, <em>double yrc</em>, <em>double zx</em>, <em>double zy</em>, <em>double x1_err=0.</em>, <em>double y1_err=0.</em>, <em>double dx_err=0.</em>, <em>double dy_err=0.</em>, <em>double dr_err=0.</em>, <em>double zx_err=0.</em>, <em>double zy_err=0.</em>, <em>bool return_err=False</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.transform_A_to_B" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform star positions in camera A to the same star position
in camera B given the transformation parameters</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x1</strong> – x coordinate to transform</li>
<li><strong>y1</strong> – y coordinate to transform</li>
<li><strong>dx</strong> – translation along x</li>
<li><strong>dy</strong> – translation along y</li>
<li><strong>dr</strong> – rotation in the plane of the image</li>
<li><strong>da</strong> – tip angle</li>
<li><strong>db</strong> – tilt angle</li>
<li><strong>xrc</strong> – x coordinate of the rotation center</li>
<li><strong>yrc</strong> – y coordinate of the rotation center</li>
<li><strong>zx</strong> – zoom coefficient along x</li>
<li><strong>zy</strong> – zoom coefficient along y</li>
<li><strong>x1_err</strong> – (Optional) Error on x1 estimate (default 0.)</li>
<li><strong>y1_err</strong> – (Optional) Error on y1 estimate (default 0.)</li>
<li><strong>dx_err</strong> – (Optional) Error on dx estimate (default 0.)</li>
<li><strong>dy_err</strong> – (Optional) Error on dy estimate (default 0.)</li>
<li><strong>dr_err</strong> – (Optional) Error on dr estimate (default 0.)</li>
<li><strong>zx_err</strong> – (Optional) Error on zx estimate (default 0.)</li>
<li><strong>zy_err</strong> – (Optional) Error on zy estimate (default 0.)</li>
<li><strong>return_err</strong> – (Optional) If True, the error on the estimate
of x2 and y2 is returned.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">(x2, y2) = f(x1, y1). (x2, y2, x2_err, y2_err) if
return_err is True.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.cutils.transform_B_to_A">
<code class="descclassname">orb.cutils.</code><code class="descname">transform_B_to_A</code><span class="sig-paren">(</span><em>double x1</em>, <em>double y1</em>, <em>double dx</em>, <em>double dy</em>, <em>double dr</em>, <em>double da</em>, <em>double db</em>, <em>double xrc</em>, <em>double yrc</em>, <em>double zx</em>, <em>double zy</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.transform_B_to_A" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Transform star positions in camera B to the same star position</dt>
<dd>in camera A given the transformation parameters.</dd>
</dl>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">this function is meant to be the inverse of
transform_A_to_B. Given the output of transform_A_to_B and the
<strong>SAME transformation parameters</strong> the initial positions must be
returned by this function within the numerical error. i.e. if
(Xb, Yb) = A_to_B(Xi,Yi,p) and (Xa, Ya) = B_to_A(Xb, Yb, p) then
Xa - Xi ~ 1e-13 and Ya - Yi ~ 1e-13 (for float64 numbers)</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x1</strong> – x coordinate to transform</li>
<li><strong>y1</strong> – y coordinate to transform</li>
<li><strong>dx</strong> – translation along x</li>
<li><strong>dy</strong> – translation along y</li>
<li><strong>dr</strong> – rotation in the plane of the image</li>
<li><strong>da</strong> – tip angle</li>
<li><strong>db</strong> – tilt angle</li>
<li><strong>xrc</strong> – x coordinate of the rotation center</li>
<li><strong>yrc</strong> – y coordinate of the rotation center</li>
<li><strong>zx</strong> – zoom coefficient along x</li>
<li><strong>zy</strong> – zoom coefficient along y</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.cutils.unbin_image">
<code class="descclassname">orb.cutils.</code><code class="descname">unbin_image</code><span class="sig-paren">(</span><em>ndarray im</em>, <em>int nx</em>, <em>int ny</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.unbin_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Unbin a binned image (restore the image binned with the
function <a class="reference internal" href="#orb.cutils.nanbin_image" title="orb.cutils.nanbin_image"><code class="xref py py-func docutils literal notranslate"><span class="pre">nanbin_image()</span></code></a>).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>im</strong> – Image to unbin.</li>
<li><strong>nx</strong> – X dimension of the unbinned image.</li>
<li><strong>ny</strong> – Y dimension of the unbinned image.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-orb.etc">
<span id="orb-etc-module"></span><h2>orb.etc module<a class="headerlink" href="#module-orb.etc" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="orb.etc.ETC">
<em class="property">class </em><code class="descclassname">orb.etc.</code><code class="descname">ETC</code><span class="sig-paren">(</span><em>spectrum_phys</em>, <em>step</em>, <em>order</em>, <em>filter_name</em>, <em>add_sky=True</em>, <em>airmass=1</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.etc.ETC" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#orb.core.Tools" title="orb.core.Tools"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.core.Tools</span></code></a></p>
<dl class="method">
<dt id="orb.etc.ETC.convert">
<code class="descname">convert</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.etc.ETC.convert" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="orb.etc.ETC.effective_exposition_time">
<code class="descname">effective_exposition_time</code><span class="sig-paren">(</span><em>exposition_time</em>, <em>percent</em>, <em>reverse=False</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.etc.ETC.effective_exposition_time" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="orb.etc.ETC.get_exposition_time">
<code class="descname">get_exposition_time</code><span class="sig-paren">(</span><em>target</em>, <em>wavenumber</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.etc.ETC.get_exposition_time" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="orb.etc.ETC.get_sky_spectrum">
<code class="descname">get_sky_spectrum</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.etc.ETC.get_sky_spectrum" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="orb.etc.ETC.get_snr">
<code class="descname">get_snr</code><span class="sig-paren">(</span><em>exposition_time</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.etc.ETC.get_snr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="orb.etc.ETC.simulate_spectrum">
<code class="descname">simulate_spectrum</code><span class="sig-paren">(</span><em>exposition_time</em>, <em>remove_sky=True</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.etc.ETC.simulate_spectrum" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-orb.fit">
<span id="orb-fit-module"></span><h2>orb.fit module<a class="headerlink" href="#module-orb.fit" title="Permalink to this headline">¶</a></h2>
<p>Fit module of ORB.</p>
<p>Defines the general Fitting classes and the fitting models.</p>
<p>Best accessed through fit_lines_in_*() functions (defined at the end
of the file)</p>
<dl class="class">
<dt id="orb.fit.Cm1InputParams">
<em class="property">class </em><code class="descclassname">orb.fit.</code><code class="descname">Cm1InputParams</code><span class="sig-paren">(</span><em>step</em>, <em>order</em>, <em>step_nb</em>, <em>nm_laser</em>, <em>theta_proj</em>, <em>theta_orig</em>, <em>apodization</em>, <em>zpd_index</em>, <em>filter_name</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.Cm1InputParams" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#orb.fit.InputParams" title="orb.fit.InputParams"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.fit.InputParams</span></code></a></p>
<p>Manage the input parameters for <a class="reference internal" href="#orb.fit.FitVector" title="orb.fit.FitVector"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.fit.FitVector</span></code></a>
and <a class="reference internal" href="#orb.fit.fit_lines_in_spectrum" title="orb.fit.fit_lines_in_spectrum"><code class="xref py py-meth docutils literal notranslate"><span class="pre">orb.fit.fit_lines_in_spectrum()</span></code></a>.</p>
<dl class="method">
<dt id="orb.fit.Cm1InputParams.add_filter_model">
<code class="descname">add_filter_model</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.Cm1InputParams.add_filter_model" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="orb.fit.Cm1InputParams.add_lines_model">
<code class="descname">add_lines_model</code><span class="sig-paren">(</span><em>lines</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.Cm1InputParams.add_lines_model" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="orb.fit.Cm1InputParams.check_signal_range">
<code class="descname">check_signal_range</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.Cm1InputParams.check_signal_range" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="orb.fit.Cm1InputParams.convert">
<code class="descname">convert</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.Cm1InputParams.convert" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert class to a pickable dict object</p>
</dd></dl>

<dl class="method">
<dt id="orb.fit.Cm1InputParams.set_signal_range">
<code class="descname">set_signal_range</code><span class="sig-paren">(</span><em>rmin</em>, <em>rmax</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.Cm1InputParams.set_signal_range" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="orb.fit.Cm1LinesModel">
<em class="property">class </em><code class="descclassname">orb.fit.</code><code class="descname">Cm1LinesModel</code><span class="sig-paren">(</span><em>p_dict</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.Cm1LinesModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#orb.fit.LinesModel" title="orb.fit.LinesModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.fit.LinesModel</span></code></a></p>
<p>Emission/absorption lines model with a channel unity in cm-1.</p>
<p>Reimplements <code class="xref py py-class docutils literal notranslate"><span class="pre">fit.LinesModel</span></code> to use more physical units
: channels are translated to cm-1 and velocity to km/s in input
and output.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">For more information please refer to
<code class="xref py py-class docutils literal notranslate"><span class="pre">fit.LinesModel</span></code></p>
</div>
<dl class="attribute">
<dt id="orb.fit.Cm1LinesModel.accepted_keys">
<code class="descname">accepted_keys</code><em class="property"> = ['line_nb', 'fmodel', 'ratio', 'amp_def', 'pos_def', 'fwhm_def', 'sigma_def', 'alpha_def', 'amp_cov', 'pos_cov', 'fwhm_cov', 'sigma_cov', 'alpha_cov', 'amp_guess', 'pos_guess', 'fwhm_guess', 'sigma_guess', 'alpha_guess', 'step_nb', 'step', 'order', 'nm_laser', 'nm_laser_obs']</em><a class="headerlink" href="#orb.fit.Cm1LinesModel.accepted_keys" title="Permalink to this definition">¶</a></dt>
<dd><p>Accepted keys of the input dictionary (see
<code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_dict</span></code>)</p>
</dd></dl>

<dl class="method">
<dt id="orb.fit.Cm1LinesModel.parse_dict">
<code class="descname">parse_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.Cm1LinesModel.parse_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse input dictionary <code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_dict</span></code></p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="orb.fit.ContinuumModel">
<em class="property">class </em><code class="descclassname">orb.fit.</code><code class="descname">ContinuumModel</code><span class="sig-paren">(</span><em>p_dict</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.ContinuumModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#orb.fit.Model" title="orb.fit.Model"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.fit.Model</span></code></a></p>
<p>Polynomial continuum model.</p>
<p>Input dictionary <code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_dict</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="s1">&#39;poly_order&#39;</span><span class="p">:</span>
 <span class="s1">&#39;poly_guess&#39;</span><span class="p">:}</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>poly_order</strong> – Order of the polynomial to fit (be careful
with high order polynomials).</li>
<li><strong>poly_guess</strong> – Initial guess on the coefficient values :
must be a tuple of length poly_order + 1.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This model must be added to the others.</p>
</div>
<dl class="attribute">
<dt id="orb.fit.ContinuumModel.accepted_keys">
<code class="descname">accepted_keys</code><em class="property"> = ('poly_def', 'poly_order', 'poly_guess')</em><a class="headerlink" href="#orb.fit.ContinuumModel.accepted_keys" title="Permalink to this definition">¶</a></dt>
<dd><p>Accepted keys of the input dictionary (see
<code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_dict</span></code>)</p>
</dd></dl>

<dl class="method">
<dt id="orb.fit.ContinuumModel.check_input">
<code class="descname">check_input</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.ContinuumModel.check_input" title="Permalink to this definition">¶</a></dt>
<dd><p>Check input parameters</p>
</dd></dl>

<dl class="method">
<dt id="orb.fit.ContinuumModel.get_model">
<code class="descname">get_model</code><span class="sig-paren">(</span><em>x</em>, <em>p_free=None</em>, <em>return_models=False</em>, <em>multf=None</em>, <em>return_complex=False</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.ContinuumModel.get_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Return model M(x, p).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> – Positions where the model M(x, p) is computed.</li>
<li><strong>p_free</strong> – (Optional) New values of the free parameters
(default None).</li>
<li><strong>multf</strong> – 1d vector with the same length as x vector which
represent the function by which the model must be multiplied.</li>
<li><strong>return_models</strong> – (Optional) If True return also
individual models (default False)</li>
<li><strong>return_complex</strong> – (Optional) If True return a complex
model (default False).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="orb.fit.ContinuumModel.get_p_val_as_array">
<code class="descname">get_p_val_as_array</code><span class="sig-paren">(</span><em>p_val=None</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.ContinuumModel.get_p_val_as_array" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="orb.fit.ContinuumModel.make_guess">
<code class="descname">make_guess</code><span class="sig-paren">(</span><em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.ContinuumModel.make_guess" title="Permalink to this definition">¶</a></dt>
<dd><p>If a parameter value at init is a NaN this value is guessed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>v</strong> – Data vector from which the guess is made.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="orb.fit.ContinuumModel.parse_dict">
<code class="descname">parse_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.ContinuumModel.parse_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse input dictionary <code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_dict</span></code></p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="orb.fit.FilterModel">
<em class="property">class </em><code class="descclassname">orb.fit.</code><code class="descname">FilterModel</code><span class="sig-paren">(</span><em>p_dict</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.FilterModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#orb.fit.Model" title="orb.fit.Model"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.fit.Model</span></code></a></p>
<p>Simple model of filter based on a real filter shape. The only
possible free parameter is a wavelength/wavenumber shift.</p>
<p>Input dictionary <code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_dict</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="s1">&#39;filter_function&#39;</span><span class="p">:,</span>
 <span class="s1">&#39;shift_guess&#39;</span><span class="p">:,</span>
 <span class="s1">&#39;shift_def&#39;</span><span class="p">:}</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>filter_function</strong> – Transmission of the filter over the
fitted spectral range (axis must be exactly the same).</li>
<li><strong>shift_guess</strong> – Guess on the filter shift in pixels.</li>
<li><strong>shift_def</strong> – Definition of the shift parameter, can be
‘free’ or ‘fixed’</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This model must be multiplied with the other and used
last.</p>
</div>
<dl class="attribute">
<dt id="orb.fit.FilterModel.accepted_keys">
<code class="descname">accepted_keys</code><em class="property"> = ('filter_function', 'shift_guess', 'shift_def')</em><a class="headerlink" href="#orb.fit.FilterModel.accepted_keys" title="Permalink to this definition">¶</a></dt>
<dd><p>Accepted keys of the input dictionary (see
<code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_dict</span></code>)</p>
</dd></dl>

<dl class="method">
<dt id="orb.fit.FilterModel.check_input">
<code class="descname">check_input</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.FilterModel.check_input" title="Permalink to this definition">¶</a></dt>
<dd><p>Check input parameters</p>
</dd></dl>

<dl class="method">
<dt id="orb.fit.FilterModel.get_model">
<code class="descname">get_model</code><span class="sig-paren">(</span><em>x</em>, <em>p_free=None</em>, <em>return_models=False</em>, <em>return_complex=False</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.FilterModel.get_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Return model M(x, p).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> – Positions where the model M(x, p) is computed.</li>
<li><strong>p_free</strong> – (Optional) New values of the free parameters
(default None).</li>
<li><strong>return_models</strong> – (Optional) If True return also
individual models (default False)</li>
<li><strong>return_complex</strong> – (Optional) If True return a complex
model (default False).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="orb.fit.FilterModel.make_guess">
<code class="descname">make_guess</code><span class="sig-paren">(</span><em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.FilterModel.make_guess" title="Permalink to this definition">¶</a></dt>
<dd><p>If a parameter value at init is a NaN this value is guessed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>v</strong> – Data vector from which the guess is made.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="orb.fit.FilterModel.parse_dict">
<code class="descname">parse_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.FilterModel.parse_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse input dictionary <code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_dict</span></code></p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="orb.fit.FitVector">
<em class="property">class </em><code class="descclassname">orb.fit.</code><code class="descname">FitVector</code><span class="sig-paren">(</span><em>vector</em>, <em>models</em>, <em>params</em>, <em>snr_guess=None</em>, <em>fit_tol=1e-08</em>, <em>signal_range=None</em>, <em>classic=False</em>, <em>max_iter=None</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.FitVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>General fitting class for a 1d array of data based on
Levenberg-Marquardt least square fit algorithm.</p>
<p>Accept any combination of models (based on <code class="xref py py-class docutils literal notranslate"><span class="pre">fit.Model</span></code>)</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This class is a wrapper around
<code class="xref py py-meth docutils literal notranslate"><span class="pre">scipy.optimize.leastsq()</span></code>. Most of its purpose consists
in passing an array of purely free parameters to
<code class="xref py py-meth docutils literal notranslate"><span class="pre">scipy.optimize.leastsq()</span></code> and creating the objective
function from free and fixed parameters by combining the
different models.</p>
</div>
<dl class="method">
<dt id="orb.fit.FitVector.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>compute_mcmc_error=False</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.FitVector.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit data vector.</p>
<p>This is the central function of the class.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>compute_mcmc_error</strong> – (Optional) Compute Markov chain
Monte-Carlo error on the fit parameters (Uncertainty
estimates might be slighly better constrained but computing
time can be orders of magnitude longer) (default False).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="orb.fit.FitVector.fit_tol">
<code class="descname">fit_tol</code><em class="property"> = None</em><a class="headerlink" href="#orb.fit.FitVector.fit_tol" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="orb.fit.FitVector.get_model">
<code class="descname">get_model</code><span class="sig-paren">(</span><em>all_p_free</em>, <em>return_models=False</em>, <em>x=None</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.FitVector.get_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the combined model of the vector given a set of free
parameters.</p>
<p>This function is typically called to compute the objective
function. It can also be called to obtain the final model
based on fitted parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>all_p_free</strong> – Vector of free parameters.</li>
<li><strong>return_models</strong> – (Optional) If True return also
individual models (default False)</li>
<li><strong>x</strong> – (Optional) array of data points on which model is
computed instead of a typical np.arange(step_nb) (default
None).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="orb.fit.FitVector.max_fev">
<code class="descname">max_fev</code><em class="property"> = 5000</em><a class="headerlink" href="#orb.fit.FitVector.max_fev" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="orb.fit.FitVector.models">
<code class="descname">models</code><em class="property"> = None</em><a class="headerlink" href="#orb.fit.FitVector.models" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="orb.fit.FitVector.models_operation">
<code class="descname">models_operation</code><em class="property"> = None</em><a class="headerlink" href="#orb.fit.FitVector.models_operation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="orb.fit.FitVector.models_operations">
<code class="descname">models_operations</code><em class="property"> = ['add', 'mult']</em><a class="headerlink" href="#orb.fit.FitVector.models_operations" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="orb.fit.FitVector.priors_keys_list">
<code class="descname">priors_keys_list</code><em class="property"> = None</em><a class="headerlink" href="#orb.fit.FitVector.priors_keys_list" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="orb.fit.FitVector.priors_list">
<code class="descname">priors_list</code><em class="property"> = None</em><a class="headerlink" href="#orb.fit.FitVector.priors_list" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="orb.fit.FitVector.vector">
<code class="descname">vector</code><em class="property"> = None</em><a class="headerlink" href="#orb.fit.FitVector.vector" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="orb.fit.InputParams">
<em class="property">class </em><code class="descclassname">orb.fit.</code><code class="descname">InputParams</code><span class="sig-paren">(</span><em>step_nb</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.InputParams" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="attribute">
<dt id="orb.fit.InputParams.FWHM_SDEV">
<code class="descname">FWHM_SDEV</code><em class="property"> = 10</em><a class="headerlink" href="#orb.fit.InputParams.FWHM_SDEV" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="orb.fit.InputParams.SHIFT_SDEV">
<code class="descname">SHIFT_SDEV</code><em class="property"> = 10</em><a class="headerlink" href="#orb.fit.InputParams.SHIFT_SDEV" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="orb.fit.InputParams.SIGMA_SDEV">
<code class="descname">SIGMA_SDEV</code><em class="property"> = 10</em><a class="headerlink" href="#orb.fit.InputParams.SIGMA_SDEV" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="orb.fit.InputParams.add_continuum_model">
<code class="descname">add_continuum_model</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.InputParams.add_continuum_model" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="orb.fit.InputParams.add_lines_model">
<code class="descname">add_lines_model</code><span class="sig-paren">(</span><em>lines</em>, <em>fwhm_guess</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.InputParams.add_lines_model" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="orb.fit.InputParams.append_model">
<code class="descname">append_model</code><span class="sig-paren">(</span><em>model</em>, <em>operation</em>, <em>params</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.InputParams.append_model" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="orb.fit.InputParams.check_signal_range">
<code class="descname">check_signal_range</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.InputParams.check_signal_range" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="orb.fit.InputParams.clean_kwargs">
<code class="descname">clean_kwargs</code><span class="sig-paren">(</span><em>kwargs</em>, <em>params</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.InputParams.clean_kwargs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="orb.fit.InputParams.convert">
<code class="descname">convert</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.InputParams.convert" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert class to a pickable dict object</p>
</dd></dl>

<dl class="method">
<dt id="orb.fit.InputParams.has_model">
<code class="descname">has_model</code><span class="sig-paren">(</span><em>model</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.InputParams.has_model" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="orb.fit.InputParams.set_signal_range">
<code class="descname">set_signal_range</code><span class="sig-paren">(</span><em>rmin</em>, <em>rmax</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.InputParams.set_signal_range" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="orb.fit.LinesModel">
<em class="property">class </em><code class="descclassname">orb.fit.</code><code class="descname">LinesModel</code><span class="sig-paren">(</span><em>p_dict</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.LinesModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#orb.fit.Model" title="orb.fit.Model"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.fit.Model</span></code></a></p>
<p>Emission/absorption lines model with a channel unity in pixels.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This class is best seen as a basic class implemented
with more physical unities by <code class="xref py py-class docutils literal notranslate"><span class="pre">fit.Cm1LinesModel</span></code> or
<code class="xref py py-class docutils literal notranslate"><span class="pre">fit.NmLinesModel</span></code>.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Each line is built on 3 (or more) parameters : amplitude,
FWHM, position and sigma/alpha (the 4th and 5th parameters are used only for some models – see
below for details on the different models).</p>
<p class="last">Some lines can have one or more covarying parameters: FWHM can
be the same for all the lines (this is True if lines are not
resolved), lines issued from the same ion can have the same
speed (e.g. [NII] doublet, [SII] doublet, [OIII] doublet), and
some fixed transition ratios between lines can also be set
(e.g. [NII]6584/[NII]6548 can be set to 2.89, when [NII]6548 is
likely to be really noisy).</p>
</div>
<p>Input dictionary <code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_dict</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="s1">&#39;line_nb&#39;</span><span class="p">:,</span>
 <span class="s1">&#39;fmodel&#39;</span><span class="p">:,</span>
 <span class="s1">&#39;amp_def&#39;</span><span class="p">:,</span>
 <span class="s1">&#39;pos_def&#39;</span><span class="p">:,</span>
 <span class="s1">&#39;fwhm_def&#39;</span><span class="p">:,</span>
 <span class="s1">&#39;sigma_def&#39;</span><span class="p">:,</span> <span class="c1"># only for sincgauss fmodel</span>
 <span class="s1">&#39;alpha_def&#39;</span><span class="p">:,</span> <span class="c1"># only for sincphased fmode</span>
 <span class="s1">&#39;amp_cov&#39;</span><span class="p">:,</span>
 <span class="s1">&#39;pos_cov&#39;</span><span class="p">:,</span>
 <span class="s1">&#39;fwhm_cov&#39;</span><span class="p">:,</span>
 <span class="s1">&#39;sigma_cov&#39;</span><span class="p">:,</span> <span class="c1"># only for sincgauss fmodel</span>
 <span class="s1">&#39;alpha_cov&#39;</span><span class="p">:,</span> <span class="c1"># only for sincphased fmodel</span>
 <span class="s1">&#39;amp_guess&#39;</span><span class="p">:,</span>
 <span class="s1">&#39;pos_guess&#39;</span><span class="p">:,</span>
 <span class="s1">&#39;fwhm_guess&#39;</span><span class="p">:,</span>
 <span class="s1">&#39;sigma_guess&#39;</span><span class="p">:,</span> <span class="c1"># only for sincgauss fmodel</span>
 <span class="s1">&#39;alpha_guess&#39;</span><span class="p">:}</span> <span class="c1">#  only for sincphased fmodel</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>line_nb</strong> – Number of lines.</li>
<li><strong>fmodel</strong> – Line shape, can be ‘gaussian’, ‘sinc’, ‘sinc2’ or
‘sincgauss’.</li>
<li><strong>amp_def</strong> – Definition of the amplitude parameter, can be
‘free’, ‘fixed’ or set to a label that defines its covarying
group.</li>
<li><strong>pos_def</strong> – Definition of the position parameter in pixels,
can be ‘free’, ‘fixed’ or set to a label that defines its
covarying group.</li>
<li><strong>fwhm_def</strong> – Definition of the FWHM parameter in pixels, can
be ‘free’, ‘fixed’ or set to a label that defines its covarying
group.</li>
<li><strong>sigma_def</strong> – Definition of the sigma parameter in pixels,
can be ‘free’, ‘fixed’ or set to a label that defines its
covarying group.</li>
<li><strong>amp_cov</strong> – Guess on the covariant value of the amplitude
(best set to 0 in general). There must be as many values as
covarying amplitude groups or only one value if it is the same
for all groups.</li>
<li><strong>pos_cov</strong> – Guess on the covariant value of the velocity (in
pixels). There must be as many values as covarying amplitude
groups or only one value if it is the same
for all groups.</li>
<li><strong>fwhm_cov</strong> – Guess on the covariant value of the FWHM
(best set to 0 in general). There must be as many values as
covarying amplitude groups or only one value if it is the same
for all groups.</li>
<li><strong>sigma_cov</strong> – Guess on the covariant value of sigma (best
set to 0 in general). There must be as many values as covarying
amplitude groups or only one value if it is the same for all
groups.</li>
<li><strong>amp_guess</strong> – Initial guess on the amplitude value of the
lines. Best set to a NaN in general (it can be automatically
guessed with good robusteness). But if lines have a covarying
amplitude the initial guess fixes their ratio.</li>
<li><strong>pos_guess</strong> – Initial guess on the position of the lines:
the PRECISE rest frame position must be given here, especially
if lines share a covarying position, because their relative
position will be fixed.</li>
<li><strong>fwhm_guess</strong> – Initial guess on the FWHM of the lines. This
guess must be the MOST PRECISE possible (to a few 10%), it is by
far the most unstable parameter especially for sinc lines.</li>
<li><strong>sigma_guess</strong> – Initial guess on the value of sigma. Best
set to 0. in general</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Example: A red spectrum containing [NII]6548, Halpha, [NII]6584,
[SII]6716 and [SII]6731, with a mean velocity of 1500 km/s (which
translates in a pixel shift of 5.5), with a fixed amplitude ratio
netween [NII] lines, the same speed for lines issued from the same
ions and a shared FWHM between everybody but Halpha would be
defined this way:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="s1">&#39;line_nb&#39;</span> <span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
 <span class="s1">&#39;amp_def&#39;</span> <span class="p">:</span> <span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;free&#39;</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;free&#39;</span><span class="p">,</span> <span class="s1">&#39;free&#39;</span><span class="p">),</span>
 <span class="s1">&#39;pos_def&#39;</span> <span class="p">:</span> <span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;3&#39;</span><span class="p">,</span> <span class="s1">&#39;3&#39;</span><span class="p">),</span> 
 <span class="s1">&#39;fwhm_def&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">),</span>
 <span class="s1">&#39;amp_cov&#39;</span><span class="p">:</span> <span class="mf">0.</span><span class="p">,</span>
 <span class="s1">&#39;pos_cov&#39;</span><span class="p">:</span> <span class="mf">5.5</span><span class="p">,</span>
 <span class="s1">&#39;fwhm_cov&#39;</span><span class="p">:</span> <span class="mf">0.</span><span class="p">,</span>
 <span class="s1">&#39;amp_guess&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mf">2.89</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">),</span> <span class="c1"># here the amplitude ratio between covarying [NII] lines is fixed.</span>
 <span class="s1">&#39;pos_guess&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">40</span><span class="p">,</span><span class="mi">60</span><span class="p">,</span><span class="mi">80</span><span class="p">,</span><span class="mi">120</span><span class="p">,</span><span class="mi">140</span><span class="p">),</span> <span class="c1"># positions are given in pixel and are purely arbitrary in this example</span>
 <span class="s1">&#39;fwhm_guess&#39;</span><span class="p">:</span> <span class="mf">2.43</span><span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Line shapes (fmodel keyword):</p>
<ul class="last simple">
<li><strong>gaussian</strong>: A classical gaussian line shape. See <code class="xref py py-meth docutils literal notranslate"><span class="pre">cutils.gaussian1d()</span></code>.</li>
<li><strong>sinc</strong>: A pure sinc line shape, True interferometric line shape
if lines are strongly unresolved and if the interferometer has
no assymetry (generally good on SITELLE/SpIOMM low res cubes
–i.e. less than 500 steps– if the line SNR is not too high
–i.e. &lt; 50–). See <code class="xref py py-meth docutils literal notranslate"><span class="pre">cutils.sinc1d()</span></code>.</li>
<li><strong>sinc2</strong>: sinc2 = sqrt(sinc**2.). Can be used for spectra not
corrected in phase (where the absolute value of the complex
spectrum is taken).</li>
<li><strong>sincgauss</strong>: Convolution of a Gaussian (of width <strong>sigma</strong>) and
a sinc (FWHM). This line shape has a 4th parameter:
sigma. This is much closer to the true line shape, but it
takes much more time to compute because of the generally very
small value of sigma. This can be used to fit resolved lines,
like e.g. Halpha in absorption or active nucleus with broader
emission. See <code class="xref py py-meth docutils literal notranslate"><span class="pre">cutils.sincgauss1d()</span></code>.</li>
</ul>
</div>
<dl class="attribute">
<dt id="orb.fit.LinesModel.accepted_keys">
<code class="descname">accepted_keys</code><em class="property"> = ('line_nb', 'fmodel', 'ratio', 'amp_def', 'pos_def', 'fwhm_def', 'sigma_def', 'alpha_def', 'amp_cov', 'pos_cov', 'fwhm_cov', 'sigma_cov', 'alpha_cov', 'amp_guess', 'pos_guess', 'fwhm_guess', 'sigma_guess', 'alpha_guess')</em><a class="headerlink" href="#orb.fit.LinesModel.accepted_keys" title="Permalink to this definition">¶</a></dt>
<dd><p>Accepted keys of the input dictionary (see
<code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_dict</span></code>)</p>
</dd></dl>

<dl class="method">
<dt id="orb.fit.LinesModel.check_input">
<code class="descname">check_input</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.LinesModel.check_input" title="Permalink to this definition">¶</a></dt>
<dd><p>Check input parameters</p>
</dd></dl>

<dl class="method">
<dt id="orb.fit.LinesModel.get_model">
<code class="descname">get_model</code><span class="sig-paren">(</span><em>x</em>, <em>p_free=None</em>, <em>return_models=False</em>, <em>multf=None</em>, <em>return_complex=False</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.LinesModel.get_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Return model M(x, p).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> – Positions where the model M(x, p) is computed.</li>
<li><strong>p_free</strong> – (Optional) New values of the free parameters
(default None).</li>
<li><strong>multf</strong> – 1d vector with the same length as x vector which
represent the function by which the model must be multiplied.</li>
<li><strong>return_models</strong> – (Optional) If True return also
individual models (default False)</li>
<li><strong>return_complex</strong> – (Optional) If True return a complex model.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="orb.fit.LinesModel.get_p_val_as_array">
<code class="descname">get_p_val_as_array</code><span class="sig-paren">(</span><em>p_val=None</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.LinesModel.get_p_val_as_array" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="orb.fit.LinesModel.get_priors">
<code class="descname">get_priors</code><span class="sig-paren">(</span><em>classic</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.LinesModel.get_priors" title="Permalink to this definition">¶</a></dt>
<dd><p>Return priors. Replace gaussian distribution by lognormal
distribution for some parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>classic</strong> – If True, return classic priors (e.g. no log
distribution)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="orb.fit.LinesModel.log_param_keys">
<code class="descname">log_param_keys</code><em class="property"> = ['fwhm', 'sigma']</em><a class="headerlink" href="#orb.fit.LinesModel.log_param_keys" title="Permalink to this definition">¶</a></dt>
<dd><p>Parameter keys that have a lognormal distribution</p>
</dd></dl>

<dl class="method">
<dt id="orb.fit.LinesModel.make_guess">
<code class="descname">make_guess</code><span class="sig-paren">(</span><em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.LinesModel.make_guess" title="Permalink to this definition">¶</a></dt>
<dd><p>If a parameter value at init is a NaN this value is guessed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>v</strong> – Data vector from which the guess is made.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="orb.fit.LinesModel.p_array">
<code class="descname">p_array</code><em class="property"> = None</em><a class="headerlink" href="#orb.fit.LinesModel.p_array" title="Permalink to this definition">¶</a></dt>
<dd><p>equivalent of <code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_val</span></code> but presented as an
array with each row corresponding to a line which is easier to
handle.</p>
</dd></dl>

<dl class="attribute">
<dt id="orb.fit.LinesModel.param_keys">
<code class="descname">param_keys</code><em class="property"> = ['amp', 'pos', 'fwhm', 'sigma', 'alpha']</em><a class="headerlink" href="#orb.fit.LinesModel.param_keys" title="Permalink to this definition">¶</a></dt>
<dd><p>Parameter keys</p>
</dd></dl>

<dl class="method">
<dt id="orb.fit.LinesModel.parse_dict">
<code class="descname">parse_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.LinesModel.parse_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse input dictionary <code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_dict</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="orb.fit.LinesModel.same_param_keys">
<code class="descname">same_param_keys</code><em class="property"> = ['fwhm', 'sigma']</em><a class="headerlink" href="#orb.fit.LinesModel.same_param_keys" title="Permalink to this definition">¶</a></dt>
<dd><p>Parameter keys which must be the same if covarying</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="orb.fit.Model">
<em class="property">class </em><code class="descclassname">orb.fit.</code><code class="descname">Model</code><span class="sig-paren">(</span><em>p_dict</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.Model" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Template class for fit models. This class cannot be used directly.</p>
<p>The main purpose of a Model class is to output a model given a set
of parameters.</p>
<p>Methods that must be implemented by real classes:</p>
<blockquote>
<div><ul class="simple">
<li><code class="xref py py-meth docutils literal notranslate"><span class="pre">fit.Model.parse_dict()</span></code></li>
<li><code class="xref py py-meth docutils literal notranslate"><span class="pre">fit.Model.check_input()</span></code></li>
<li><code class="xref py py-meth docutils literal notranslate"><span class="pre">fit.Model.make_guess()</span></code></li>
<li><code class="xref py py-meth docutils literal notranslate"><span class="pre">fit.Model.get_model()</span></code></li>
</ul>
</div></blockquote>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>A model is computed from a given set of parameters
stored in <code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_val</span></code>. From this set some
parameters are <strong>free</strong>, some are <strong>fixed</strong> and some are
<strong>covarying</strong>, i.e. the value of a subset of parameters can be
computed from 1 free parameter.</p>
<p>Taking the definition of the parameters (free, fixed or
covarying, stored in <code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_def</span></code>) into account,
the reduced free parameter set is stored in
<code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_free</span></code>, the reduced set of fixed parameters
is stored in <code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_fixed</span></code>, the set of covarying
parameters is stored in <code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_cov</span></code> and when the
model needs to be computed, the full set of model parameters
(<code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_val</span></code>) is computed again from set.p_free`,
<code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_fixed</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_cov</span></code> and
<code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_def</span></code>.</p>
<p>A group of covarying parameters is defined by the same label. If
<code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_def</span></code> is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="s1">&#39;free&#39;</span><span class="p">,</span> <span class="s1">&#39;fixed&#39;</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="s1">&#39;free&#39;</span><span class="p">,</span> <span class="s1">&#39;fixed&#39;</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="s1">&#39;free&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>It means that we have 3 free parameters, 2 fixed parameters and
2 groups of covarying parameters. The first group contains 2
parameters and the second group contains 3 parameters. In this
case the real number of free parameters will be 3 + 2 (one free
parameter for each group of covarying parameters) = 5 and the
real number of fixed parameters will be 2 + 5 (one fixed
parameter for each covarying parameters) = 7.</p>
<p>A Model class works this way :</p>
<ol class="last arabic simple">
<li>Init: the dictionary defining the parameters (free, fixed,
covarying) and their values is parsed with
<code class="xref py py-meth docutils literal notranslate"><span class="pre">fit.Model.parse_dict()</span></code>: <code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_def</span></code>,
<code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_val</span></code> and <code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_cov</span></code> are
created. Then <code class="xref py py-meth docutils literal notranslate"><span class="pre">fit.Model.val2free()</span></code> is called to
create <code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_free</span></code> and
<code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_fixed</span></code>.</li>
<li>the set of free parameters can then be changed with
<code class="xref py py-meth docutils literal notranslate"><span class="pre">fit.Model.set_p_free()</span></code> before calling
<code class="xref py py-meth docutils literal notranslate"><span class="pre">fit.Model.get_model()</span></code>. the updated values of
<code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_val</span></code> are computed before the model is created via
<code class="xref py py-meth docutils literal notranslate"><span class="pre">fit.Model.free2val()</span></code>. A new set of free parameters
can also be passed to <code class="xref py py-meth docutils literal notranslate"><span class="pre">fit.Model.get_model()</span></code>.</li>
</ol>
</div>
<dl class="attribute">
<dt id="orb.fit.Model.accepted_keys">
<code class="descname">accepted_keys</code><em class="property"> = ()</em><a class="headerlink" href="#orb.fit.Model.accepted_keys" title="Permalink to this definition">¶</a></dt>
<dd><p>Accepted keys of the input dictionary (see
<code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_dict</span></code>)</p>
</dd></dl>

<dl class="method">
<dt id="orb.fit.Model.check_input">
<code class="descname">check_input</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.Model.check_input" title="Permalink to this definition">¶</a></dt>
<dd><p>Check input parameters</p>
</dd></dl>

<dl class="method">
<dt id="orb.fit.Model.free2val">
<code class="descname">free2val</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.Model.free2val" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the array of parameters definition
<code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_def</span></code> and update the parameter values
based on the new set of free parameters
<code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_free</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="orb.fit.Model.get_model">
<code class="descname">get_model</code><span class="sig-paren">(</span><em>x</em>, <em>return_models=False</em>, <em>return_complex=False</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.Model.get_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute a model M(x, p) for all passed x positions. p are
the parameter values stored in <code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_val</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> – Positions where the model M(x, p) is computed.</li>
<li><strong>return_models</strong> – (Optional) If True return also
individual models (default False)</li>
<li><strong>return_complex</strong> – (Optional) If True return a complex
model (default False).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="orb.fit.Model.get_p_free">
<code class="descname">get_p_free</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.Model.get_p_free" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the vector of free parameters <code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_free</span></code></p>
</dd></dl>

<dl class="method">
<dt id="orb.fit.Model.get_p_val">
<code class="descname">get_p_val</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.Model.get_p_val" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_val</span></code></p>
</dd></dl>

<dl class="method">
<dt id="orb.fit.Model.get_priors">
<code class="descname">get_priors</code><span class="sig-paren">(</span><em>classic</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.Model.get_priors" title="Permalink to this definition">¶</a></dt>
<dd><p>Return priors</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>classic</strong> – If True, return classic priors (e.g. no log distribution)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="orb.fit.Model.make_guess">
<code class="descname">make_guess</code><span class="sig-paren">(</span><em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.Model.make_guess" title="Permalink to this definition">¶</a></dt>
<dd><p>If a parameter value at init is a NaN this value is guessed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>v</strong> – Data vector from which the guess is made.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="orb.fit.Model.p_cov">
<code class="descname">p_cov</code><em class="property"> = None</em><a class="headerlink" href="#orb.fit.Model.p_cov" title="Permalink to this definition">¶</a></dt>
<dd><p>dict that stores the groups of covarying parameters by label
and their associated value and covarying operation (a pointer to a
function), i.e.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{[</span><span class="s1">&#39;cov_label_1&#39;</span><span class="p">:</span> <span class="p">(</span><span class="n">value1</span><span class="p">,</span> <span class="n">cov_operation1</span><span class="p">)],</span>
 <span class="p">[</span><span class="s1">&#39;cov_label_2&#39;</span><span class="p">:</span> <span class="p">(</span><span class="n">value2</span><span class="p">,</span> <span class="n">cov_operation2</span><span class="p">)],</span>
 <span class="o">...</span><span class="p">}</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="orb.fit.Model.p_def">
<code class="descname">p_def</code><em class="property"> = None</em><a class="headerlink" href="#orb.fit.Model.p_def" title="Permalink to this definition">¶</a></dt>
<dd><p>Definition the full set of parameters (fixed, free or
covarying). This array as the same shape as <code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_val</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="orb.fit.Model.p_dict">
<code class="descname">p_dict</code><em class="property"> = None</em><a class="headerlink" href="#orb.fit.Model.p_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Input dictionary defining the parameters. Contains the initial
values of the parameters</p>
</dd></dl>

<dl class="attribute">
<dt id="orb.fit.Model.p_fixed">
<code class="descname">p_fixed</code><em class="property"> = None</em><a class="headerlink" href="#orb.fit.Model.p_fixed" title="Permalink to this definition">¶</a></dt>
<dd><p>Array of fixed parameters. Each covarying parameter is stored
as fixed. And one free parameter is added for each group of
covarying parameters.</p>
</dd></dl>

<dl class="attribute">
<dt id="orb.fit.Model.p_free">
<code class="descname">p_free</code><em class="property"> = None</em><a class="headerlink" href="#orb.fit.Model.p_free" title="Permalink to this definition">¶</a></dt>
<dd><p>Up to date value of the free parameters. Its size is always
less or equal to the size of the full set of parameters used
directly to compute the model. It reflects the real number of
fitted parameters. For each group of covarying parameters one free
parameter is added.</p>
</dd></dl>

<dl class="attribute">
<dt id="orb.fit.Model.p_val">
<code class="descname">p_val</code><em class="property"> = None</em><a class="headerlink" href="#orb.fit.Model.p_val" title="Permalink to this definition">¶</a></dt>
<dd><p>Up to date values of the full set of parameters used by the model
(initial guess before fit, fitted value after fit). This array as
the same shape as <code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_def</span></code>. It does not reflect the real number
of fitted parameters.</p>
</dd></dl>

<dl class="method">
<dt id="orb.fit.Model.parse_dict">
<code class="descname">parse_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.Model.parse_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse input dictionary to create <code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_def</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_val</span></code> and
<code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_cov</span></code></p>
</dd></dl>

<dl class="method">
<dt id="orb.fit.Model.set_p_free">
<code class="descname">set_p_free</code><span class="sig-paren">(</span><em>p_free</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.Model.set_p_free" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the vector of free parameters <code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_free</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>p_free</strong> – New vector of free parameters</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="orb.fit.Model.set_p_val">
<code class="descname">set_p_val</code><span class="sig-paren">(</span><em>p_val</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.Model.set_p_val" title="Permalink to this definition">¶</a></dt>
<dd><p>Set <code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_val</span></code></p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This method is used to bypass all the initialized
parameters and reuse an already initialized model with
another full set of parameters. Note that you might want to
call <code class="xref py py-meth docutils literal notranslate"><span class="pre">fit.Model.get_model()</span></code> directly after this
method because any call to <code class="xref py py-meth docutils literal notranslate"><span class="pre">fit.Model.set_p_free()</span></code>
or <code class="xref py py-meth docutils literal notranslate"><span class="pre">fit.Model.free2val()</span></code> will recompute
<code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_val</span></code> from the init values and the
actual <code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_free</span></code>.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>p_val</strong> – New full set of parameters.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="orb.fit.Model.val2free">
<code class="descname">val2free</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.Model.val2free" title="Permalink to this definition">¶</a></dt>
<dd><p>Recompute the set of free parameters
<code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_free</span></code> with the updated values of
<code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_val</span></code></p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="orb.fit.NmLinesModel">
<em class="property">class </em><code class="descclassname">orb.fit.</code><code class="descname">NmLinesModel</code><span class="sig-paren">(</span><em>p_dict</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.NmLinesModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#orb.fit.Cm1LinesModel" title="orb.fit.Cm1LinesModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.fit.Cm1LinesModel</span></code></a></p>
<p>Emission/absorption lines model with a channel unity in nm.</p>
<p>Reimplements <code class="xref py py-class docutils literal notranslate"><span class="pre">fit.Cm1LinesModel</span></code> to use nm instead of
cm-1. Channels are translated to cm-1 and velocity to km/s in
input and output.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">For more information please refer to
<code class="xref py py-class docutils literal notranslate"><span class="pre">fit.Cm1LinesModel</span></code> and <code class="xref py py-class docutils literal notranslate"><span class="pre">fit.LinesModel</span></code></p>
</div>
<dl class="method">
<dt id="orb.fit.NmLinesModel.parse_dict">
<code class="descname">parse_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.NmLinesModel.parse_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse input dictionary <code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_dict</span></code></p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="orb.fit.OutputParams">
<em class="property">class </em><code class="descclassname">orb.fit.</code><code class="descname">OutputParams</code><a class="headerlink" href="#orb.fit.OutputParams" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#orb.fit.Params" title="orb.fit.Params"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.fit.Params</span></code></a></p>
<dl class="method">
<dt id="orb.fit.OutputParams.convert">
<code class="descname">convert</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.OutputParams.convert" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert class to a raw pickable format</p>
</dd></dl>

<dl class="method">
<dt id="orb.fit.OutputParams.translate">
<code class="descname">translate</code><span class="sig-paren">(</span><em>inputparams</em>, <em>fitvector</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.OutputParams.translate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="orb.fit.Params">
<em class="property">class </em><code class="descclassname">orb.fit.</code><code class="descname">Params</code><a class="headerlink" href="#orb.fit.Params" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#orb.core.Params" title="orb.core.Params"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.core.Params</span></code></a></p>
<p>Manage a set of parameters as a special dictionary which
elements can be accessed like attributes.</p>
</dd></dl>

<dl class="function">
<dt id="orb.fit.check_fit">
<code class="descclassname">orb.fit.</code><code class="descname">check_fit</code><span class="sig-paren">(</span><em>lines</em>, <em>amp</em>, <em>fwhm</em>, <em>step_nb</em>, <em>snr</em>, <em>line_shift=0</em>, <em>sigma=0</em>, <em>alpha=0</em>, <em>fmodel='sincgauss'</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.check_fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a model and fit it.</p>
<p>This is a good way to check the quality and the internal coherency
of the fitting routine.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>lines</strong> – lines channels</li>
<li><strong>amp</strong> – Amplitude (must have the same size as lines)</li>
<li><strong>fwhm</strong> – lines FWHM (in channels)</li>
<li><strong>step_nb</strong> – Number of steps of the spectrum.</li>
<li><strong>snr</strong> – SNR of the strongest line</li>
<li><strong>line_shift</strong> – (Optional) Global shift applied to all the
lines (in channels, default 0.)</li>
<li><strong>sigma</strong> – (Optional) Sigma of the lines (in channels, default
0.)</li>
<li><strong>alpha</strong> – (Optional) Phase coefficient of the lines (default
0.)</li>
<li><strong>fmodel</strong> – (Optional) Lines model. Can be ‘gaussian’, ‘sinc’,
‘sincgauss’, ‘sincphased’, ‘sincgaussphased’ (default sincgauss).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.fit.check_fit_cm1">
<code class="descclassname">orb.fit.</code><code class="descname">check_fit_cm1</code><span class="sig-paren">(</span><em>lines_cm1</em>, <em>amp</em>, <em>step</em>, <em>order</em>, <em>resolution</em>, <em>theta</em>, <em>snr</em>, <em>sigma=0</em>, <em>vel=0</em>, <em>alpha=0.0</em>, <em>fmodel='sincgauss'</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.check_fit_cm1" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a model and fit it.</p>
<p>This is a good way to check the quality and the internal coherency
of the fitting routine.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>lines_cm1</strong> – Lines rest wavenumber in cm-1</li>
<li><strong>amp</strong> – Amplitude of the lines</li>
<li><strong>step</strong> – Step size in nm</li>
<li><strong>oder</strong> – Folding order</li>
<li><strong>resolution</strong> – Resolution</li>
<li><strong>theta</strong> – Incident angle</li>
<li><strong>snr</strong> – SNR of the strongest line</li>
<li><strong>sigma</strong> – (Optional) Line broadening in km/s (default 0.)</li>
<li><strong>vel</strong> – (Optional) Velocity in km/s (default 0.)</li>
<li><strong>alpha</strong> – (Optional) Phase coefficient of the lines (default
0.)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.fit.create_cm1_lines_model">
<code class="descclassname">orb.fit.</code><code class="descname">create_cm1_lines_model</code><span class="sig-paren">(</span><em>lines_cm1</em>, <em>amp</em>, <em>step</em>, <em>order</em>, <em>resolution</em>, <em>theta</em>, <em>vel=0.0</em>, <em>sigma=0.0</em>, <em>alpha=0.0</em>, <em>fmodel='sincgauss'</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.create_cm1_lines_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a simple emission-line spectrum model in cm-1</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>lines</strong> – lines in cm-1</li>
<li><strong>amp</strong> – Amplitude (must have the same size as lines)</li>
<li><strong>step</strong> – Step size</li>
<li><strong>order</strong> – Folding order</li>
<li><strong>resolution</strong> – Resolution of the spectrum</li>
<li><strong>theta</strong> – Incident angle</li>
<li><strong>step_nb</strong> – Number of steps of the spectrum.</li>
<li><strong>vel</strong> – (Optional) Global velocity shift applied to all the
lines (in km/s, default 0.)</li>
<li><strong>sigma</strong> – (Optional) Line broadening (in km/s, default 0.)</li>
<li><strong>alpha</strong> – (Optional) Phase coefficient of the lines (default
0.)</li>
<li><strong>fmodel</strong> – (Optional) Lines model. Can be ‘gaussian’, ‘sinc’,
‘sincgauss’, ‘sincphased’, ‘sincgaussphased’ (default sincgauss).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.fit.create_lines_model">
<code class="descclassname">orb.fit.</code><code class="descname">create_lines_model</code><span class="sig-paren">(</span><em>lines</em>, <em>amp</em>, <em>fwhm</em>, <em>step_nb</em>, <em>line_shift=0.0</em>, <em>sigma=0.0</em>, <em>alpha=0.0</em>, <em>fmodel='sincgauss'</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.create_lines_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a simple emission-line spectrum model with no physical units.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>lines</strong> – lines channels.</li>
<li><strong>amp</strong> – Amplitude (must have the same size as lines).</li>
<li><strong>fwhm</strong> – lines FWHM (in channels).</li>
<li><strong>step_nb</strong> – Number of steps of the spectrum.</li>
<li><strong>line_shift</strong> – (Optional) Global shift applied to all the
lines (in channels, default 0.)</li>
<li><strong>sigma</strong> – (Optional) Sigma of the lines (in channels, default
0.)</li>
<li><strong>alpha</strong> – (Optional) Phase coefficient of the lines (default
0.)</li>
<li><strong>fmodel</strong> – (Optional) Lines model. Can be ‘gaussian’, ‘sinc’,
‘sincgauss’, ‘sincphased’, ‘sincgaussphased’ (default sincgauss).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.fit.fit_lines_in_spectrum">
<code class="descclassname">orb.fit.</code><code class="descname">fit_lines_in_spectrum</code><span class="sig-paren">(</span><em>spectrum</em>, <em>lines</em>, <em>step</em>, <em>order</em>, <em>nm_laser</em>, <em>theta</em>, <em>zpd_index</em>, <em>wavenumber=True</em>, <em>filter_name=None</em>, <em>apodization=1.0</em>, <em>fit_tol=1e-10</em>, <em>velocity_range=None</em>, <em>compute_mcmc_error=False</em>, <em>snr_guess=None</em>, <em>max_iter=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.fit_lines_in_spectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit lines in spectrum</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">If spectrum is in wavenumber (option wavenumber set
to True) input and output unit will be in cm-1. If spectrum is
in wavelength (option wavenumber set to False) input and output
unit will be in nm.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>spectrum</strong> – Spectrum to fit</li>
<li><strong>lines</strong> – Positions of the lines in nm/cm-1</li>
<li><strong>step</strong> – Step size in nm</li>
<li><strong>order</strong> – Folding order</li>
<li><strong>nm_laser</strong> – Calibration laser wavelength in nm.</li>
<li><strong>theta_proj</strong> – Projected incident angle of the spectrum in
degrees.</li>
<li><strong>zpd_index</strong> – Index of the ZPD in the interferogram.</li>
<li><strong>apodization</strong> – (Optional) Apodization level. Permit to separate the
broadening due to the apodization and the real line broadening
(see ‘broadening’ output parameter, default 1.).</li>
<li><strong>fit_tol</strong> – (Optional) Tolerance on the fit value (default
1e-10).</li>
<li><strong>filter_name</strong> – (Optional) Filter file path (default
None).</li>
<li><strong>velocity_range</strong> – (Optional) Range of velocity to check
around the shift_guess value. If not None, a brute force
algorithm is used to find the best velocity value. If more than
one shift_guess is given (e.g. if lines are have different
velocities, the mean velocity will be used as an initial
velocity guess). The quality of this guess depends strongly on
the spectrum noise. Try avoid using it with low a SNR spectrum.</li>
<li><strong>compute_mcmc_error</strong> – (Optional) If True, uncertainty
estimates are computed from a Markov chain Monte-Carlo
algorithm. If the estimates can be better constrained, the
fitting time is orders of magnitude longer (default False).</li>
<li><strong>snr_guess</strong> – (Optional) Guess on the SNR (default None).</li>
<li><strong>max_iter</strong> – (Optional) Maximum number of iterations (default None)</li>
<li><strong>kwargs</strong> – (Optional) Fitting parameters of
<code class="xref py py-class docutils literal notranslate"><span class="pre">orb.fit.Cm1LinesInput</span></code> or
<a class="reference internal" href="#orb.fit.FitVector" title="orb.fit.FitVector"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.fit.FitVector</span></code></a>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><p>a dictionary containing:</p>
<ul class="simple">
<li>all the fit parameters [key: ‘fit_params’]</li>
<li>lines parameters [key: ‘lines_params’] Lines parameters are
given as an array of shape (lines_nb, 5). The order of the 5
parameters for each lines is [height at the center of the
line, amplitude, position, fwhm, sigma]. Position and FWHM are given
in nm/cm-1 depending on the input unit (i.e. nm if wavenumber
is False and cm-1 if wavenumber is True)</li>
<li>lines parameters errors [key: ‘lines_params_err’]</li>
<li>velocity [key: ‘velocity’] Velocity of the lines in km/s</li>
<li>velocity error [key: ‘velocity_err’] Error on the velocity of
the lines in km/s</li>
<li>residual [key: ‘residual’]</li>
<li>chi-square [key: ‘chi2’]</li>
<li>reduced chi-square [key: ‘rchi2’]</li>
<li>SNR [key: ‘snr’]</li>
<li>continuum parameters [key: ‘cont_params’]</li>
<li>fitted spectrum [key: ‘fitted_vector’]</li>
<li>log(Gaussian Bayes Factor) [key: ‘logGBF’]</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.fit.fit_lines_in_vector">
<code class="descclassname">orb.fit.</code><code class="descname">fit_lines_in_vector</code><span class="sig-paren">(</span><em>vector</em>, <em>lines</em>, <em>fwhm_guess</em>, <em>fit_tol=1e-10</em>, <em>compute_mcmc_error=False</em>, <em>snr_guess=None</em>, <em>max_iter=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.fit_lines_in_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit lines in a vector</p>
<p>Use this function only if little is known about the vector. A
vector resulting from an interferogram FFT is assumed :
i.e. regular axis, symmetrical line shape.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">All position units are in channels</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>vector</strong> – vector to fit</li>
<li><strong>lines</strong> – Positions of the lines in channels</li>
<li><strong>fwhm_guess</strong> – Initial guess on the lines FWHM (in channels).</li>
<li><strong>fit_tol</strong> – (Optional) Tolerance on the fit value (default
1e-10).</li>
<li><strong>compute_mcmc_error</strong> – (Optional) If True, uncertainty
estimates are computed from a Markov chain Monte-Carlo
algorithm. If the estimates can be better constrained, the
fitting time is orders of magnitude longer (default False).</li>
<li><strong>max_iter</strong> – (Optional) Maximum number of iterations (default None)</li>
<li><strong>kwargs</strong> – (Optional) Fitting parameters of
<code class="xref py py-class docutils literal notranslate"><span class="pre">orb.fit.LinesInput</span></code> or
<a class="reference internal" href="#orb.fit.FitVector" title="orb.fit.FitVector"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.fit.FitVector</span></code></a>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Snr_guess:</th><td class="field-body"><p class="first">(Optional) Guess on the SNR (default None).</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><p>a dictionary containing:</p>
<ul class="simple">
<li>all the fit parameters [key: ‘fit_params’]</li>
<li>lines parameters [key: ‘lines_params’] Lines parameters are
given as an array of shape (lines_nb, 5). The order of the 5
parameters for each lines is [height at the center of the
line, amplitude, position, fwhm, sigma]. Postion and FWHM are given
in channels.</li>
<li>lines parameters errors [key: ‘lines_params_err’]</li>
<li>residual [key: ‘residual’]</li>
<li>chi-square [key: ‘chi2’]</li>
<li>reduced chi-square [key: ‘rchi2’]</li>
<li>SNR [key: ‘snr’]</li>
<li>continuum parameters [key: ‘cont_params’]</li>
<li>fitted spectrum [key: ‘fitted_vector’]</li>
<li>log(Gaussian Bayes Factor) [key: ‘logGBF’]</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-orb">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-orb" title="Permalink to this headline">¶</a></h2>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="orb.ext.html" class="btn btn-neutral float-right" title="orb.ext package" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="installation.html" class="btn btn-neutral float-left" title="ORB installation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, Thomas Martin (thomas.martin.1@ulaval.ca)

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>