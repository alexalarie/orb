

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>orb package &mdash; Orb latest documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/plot_directive.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="_static/logo.ico"/>
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="orb.ext package" href="orb.ext.html" />
    <link rel="prev" title="ORB Documentation" href="index.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> Orb
          

          
            
            <img src="_static/logo_sidebar.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                latest
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">orb package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#subpackages">Subpackages</a><ul>
<li class="toctree-l3"><a class="reference internal" href="orb.ext.html">orb.ext package</a></li>
<li class="toctree-l3"><a class="reference internal" href="orb.utils.html">orb.utils package</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-orb.cgvar">orb.cgvar module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-orb.constants">orb.constants module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-orb.core">orb.core module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-orb.cube">orb.cube module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-orb.cutils">orb.cutils module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-orb.fft">orb.fft module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-orb.fit">orb.fit module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-orb.image">orb.image module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-orb.old">orb.old module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-orb.photometry">orb.image photometry</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-orb.sim">orb.sim</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-orb">Module contents</a></li>
</ul>
</li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Orb</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>orb package</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/orb.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="orb-package">
<h1>orb package<a class="headerlink" href="#orb-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="subpackages">
<h2>Subpackages<a class="headerlink" href="#subpackages" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="orb.ext.html">orb.ext package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="orb.ext.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="orb.ext.html#module-orb.ext.zern">orb.ext.zern module</a></li>
<li class="toctree-l2"><a class="reference internal" href="orb.ext.html#module-orb.ext">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="orb.utils.html">orb.utils package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="orb.utils.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="orb.utils.html#module-orb.utils.astrometry">orb.utils.astrometry module</a></li>
<li class="toctree-l2"><a class="reference internal" href="orb.utils.html#module-orb.utils.err">orb.utils.err module</a></li>
<li class="toctree-l2"><a class="reference internal" href="orb.utils.html#module-orb.utils.fft">orb.utils.fft module</a></li>
<li class="toctree-l2"><a class="reference internal" href="orb.utils.html#module-orb.utils.filters">orb.utils.filters module</a></li>
<li class="toctree-l2"><a class="reference internal" href="orb.utils.html#module-orb.utils.fit">orb.utils.fit module</a></li>
<li class="toctree-l2"><a class="reference internal" href="orb.utils.html#module-orb.utils.image">orb.utils.image module</a></li>
<li class="toctree-l2"><a class="reference internal" href="orb.utils.html#module-orb.utils.io">orb.utils.io module</a></li>
<li class="toctree-l2"><a class="reference internal" href="orb.utils.html#module-orb.utils.log">orb.utils.log module</a></li>
<li class="toctree-l2"><a class="reference internal" href="orb.utils.html#module-orb.utils.misc">orb.utils.misc module</a></li>
<li class="toctree-l2"><a class="reference internal" href="orb.utils.html#module-orb.utils.parallel">orb.utils.parallel module</a></li>
<li class="toctree-l2"><a class="reference internal" href="orb.utils.html#module-orb.utils.photometry">orb.utils.photometry module</a></li>
<li class="toctree-l2"><a class="reference internal" href="orb.utils.html#module-orb.utils.sim">orb.utils.sim module</a></li>
<li class="toctree-l2"><a class="reference internal" href="orb.utils.html#module-orb.utils.spectrum">orb.utils.spectrum module</a></li>
<li class="toctree-l2"><a class="reference internal" href="orb.utils.html#module-orb.utils.stats">orb.utils.stats module</a></li>
<li class="toctree-l2"><a class="reference internal" href="orb.utils.html#module-orb.utils.validate">orb.utils.validate module</a></li>
<li class="toctree-l2"><a class="reference internal" href="orb.utils.html#module-orb.utils.vector">orb.utils.vector module</a></li>
<li class="toctree-l2"><a class="reference internal" href="orb.utils.html#module-orb.utils.web">orb.utils.web module</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-orb.cgvar">
<span id="orb-cgvar-module"></span><h2>orb.cgvar module<a class="headerlink" href="#module-orb.cgvar" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-orb.constants">
<span id="orb-constants-module"></span><h2>orb.constants module<a class="headerlink" href="#module-orb.constants" title="Permalink to this headline">¶</a></h2>
<dl class="py data">
<dt id="orb.constants.ATOMIC_MASS">
<code class="sig-prename descclassname"><span class="pre">orb.constants.</span></code><code class="sig-name descname"><span class="pre">ATOMIC_MASS</span></code><em class="property"> <span class="pre">=</span> <span class="pre">1.66053886e-24</span></em><a class="headerlink" href="#orb.constants.ATOMIC_MASS" title="Permalink to this definition">¶</a></dt>
<dd><p>1 Atomic mass in g</p>
</dd></dl>

<dl class="py data">
<dt id="orb.constants.FITS_CARD_MAX_STR_LENGTH">
<code class="sig-prename descclassname"><span class="pre">orb.constants.</span></code><code class="sig-name descname"><span class="pre">FITS_CARD_MAX_STR_LENGTH</span></code><em class="property"> <span class="pre">=</span> <span class="pre">18</span></em><a class="headerlink" href="#orb.constants.FITS_CARD_MAX_STR_LENGTH" title="Permalink to this definition">¶</a></dt>
<dd><p>Max length of a FITS string card</p>
</dd></dl>

<dl class="py data">
<dt id="orb.constants.FWHM_COEFF">
<code class="sig-prename descclassname"><span class="pre">orb.constants.</span></code><code class="sig-name descname"><span class="pre">FWHM_COEFF</span></code><em class="property"> <span class="pre">=</span> <span class="pre">2.3548200450309493</span></em><a class="headerlink" href="#orb.constants.FWHM_COEFF" title="Permalink to this definition">¶</a></dt>
<dd><p>Coefficient used to convert the width of a gaussian function to its FWHM (line_fwhm = line_width * FWHM)</p>
</dd></dl>

<dl class="py data">
<dt id="orb.constants.FWHM_SINC_COEFF">
<code class="sig-prename descclassname"><span class="pre">orb.constants.</span></code><code class="sig-name descname"><span class="pre">FWHM_SINC_COEFF</span></code><em class="property"> <span class="pre">=</span> <span class="pre">1.20671</span></em><a class="headerlink" href="#orb.constants.FWHM_SINC_COEFF" title="Permalink to this definition">¶</a></dt>
<dd><p>Coefficien used to determine sinc fwhm</p>
</dd></dl>

<dl class="py data">
<dt id="orb.constants.K_BOLTZMANN">
<code class="sig-prename descclassname"><span class="pre">orb.constants.</span></code><code class="sig-name descname"><span class="pre">K_BOLTZMANN</span></code><em class="property"> <span class="pre">=</span> <span class="pre">1.38064852e-16</span></em><a class="headerlink" href="#orb.constants.K_BOLTZMANN" title="Permalink to this definition">¶</a></dt>
<dd><p>Boltzmann constant in erg/K</p>
</dd></dl>

<dl class="py data">
<dt id="orb.constants.LIGHT_VEL_AAS">
<code class="sig-prename descclassname"><span class="pre">orb.constants.</span></code><code class="sig-name descname"><span class="pre">LIGHT_VEL_AAS</span></code><em class="property"> <span class="pre">=</span> <span class="pre">2.99792458e+18</span></em><a class="headerlink" href="#orb.constants.LIGHT_VEL_AAS" title="Permalink to this definition">¶</a></dt>
<dd><p>Velocity of the light in the vacuum in A.s-1</p>
</dd></dl>

<dl class="py data">
<dt id="orb.constants.LIGHT_VEL_KMS">
<code class="sig-prename descclassname"><span class="pre">orb.constants.</span></code><code class="sig-name descname"><span class="pre">LIGHT_VEL_KMS</span></code><em class="property"> <span class="pre">=</span> <span class="pre">299792.458</span></em><a class="headerlink" href="#orb.constants.LIGHT_VEL_KMS" title="Permalink to this definition">¶</a></dt>
<dd><p>Velocity of the light in the vacuum in km.s-1</p>
</dd></dl>

<dl class="py data">
<dt id="orb.constants.PLANCK">
<code class="sig-prename descclassname"><span class="pre">orb.constants.</span></code><code class="sig-name descname"><span class="pre">PLANCK</span></code><em class="property"> <span class="pre">=</span> <span class="pre">6.6260755e-27</span></em><a class="headerlink" href="#orb.constants.PLANCK" title="Permalink to this definition">¶</a></dt>
<dd><p>Planck constant in erg.s</p>
</dd></dl>

<dl class="py data">
<dt id="orb.constants.SESAME_URL">
<code class="sig-prename descclassname"><span class="pre">orb.constants.</span></code><code class="sig-name descname"><span class="pre">SESAME_URL</span></code><em class="property"> <span class="pre">=</span> <span class="pre">'http://cdsweb.u-strasbg.fr/cgi-bin/nph-sesame/-oxp/SNVA?'</span></em><a class="headerlink" href="#orb.constants.SESAME_URL" title="Permalink to this definition">¶</a></dt>
<dd><p>Sesame URL</p>
</dd></dl>

<dl class="py data">
<dt id="orb.constants.VIZIER_URL">
<code class="sig-prename descclassname"><span class="pre">orb.constants.</span></code><code class="sig-name descname"><span class="pre">VIZIER_URL</span></code><em class="property"> <span class="pre">=</span> <span class="pre">'http://webviz.u-strasbg.fr/viz-bin/'</span></em><a class="headerlink" href="#orb.constants.VIZIER_URL" title="Permalink to this definition">¶</a></dt>
<dd><p>Vizier URL in Canada</p>
</dd></dl>

<dl class="py data">
<dt id="orb.constants.VIZIER_URL_CA">
<code class="sig-prename descclassname"><span class="pre">orb.constants.</span></code><code class="sig-name descname"><span class="pre">VIZIER_URL_CA</span></code><em class="property"> <span class="pre">=</span> <span class="pre">'http://vizier.hia.nrc.ca/viz-bin/'</span></em><a class="headerlink" href="#orb.constants.VIZIER_URL_CA" title="Permalink to this definition">¶</a></dt>
<dd><p>Vizier URL in Canada</p>
</dd></dl>

</div>
<div class="section" id="module-orb.core">
<span id="orb-core-module"></span><h2>orb.core module<a class="headerlink" href="#module-orb.core" title="Permalink to this headline">¶</a></h2>
<p>The Core module contains all the core classes of ORB.</p>
<dl class="py class">
<dt id="orb.core.Axis">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">orb.core.</span></code><code class="sig-name descname"><span class="pre">Axis</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#orb.core.Vector1d" title="orb.core.Vector1d"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.core.Vector1d</span></code></a></p>
<p>Axis class</p>
<dl class="py method">
<dt id="orb.core.Axis.convert">
<code class="sig-name descname"><span class="pre">convert</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pos</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Axis.convert" title="Permalink to this definition">¶</a></dt>
<dd><p>convert the position in channel to a a value in axis unit</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>pos</strong> – Position in channel</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Value in axis unit</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="orb.core.Cm1Vector1d">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">orb.core.</span></code><code class="sig-name descname"><span class="pre">Cm1Vector1d</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">spectrum</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Cm1Vector1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#orb.core.Vector1d" title="orb.core.Vector1d"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.core.Vector1d</span></code></a></p>
<p>1d vector class for data projected on a cm-1 axis (e.g. complex
spectrum, phase)</p>
<dl class="py method">
<dt id="orb.core.Cm1Vector1d.change_resolution">
<code class="sig-name descname"><span class="pre">change_resolution</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">resolution</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Cm1Vector1d.change_resolution" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a vector with a defined resolution (note that resolution can
only be decreased, there is no way to increase resolution)</p>
</dd></dl>

<dl class="py method">
<dt id="orb.core.Cm1Vector1d.get_filter_bandpass_cm1">
<code class="sig-name descname"><span class="pre">get_filter_bandpass_cm1</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Cm1Vector1d.get_filter_bandpass_cm1" title="Permalink to this definition">¶</a></dt>
<dd><p>Return filter bandpass in cm-1</p>
</dd></dl>

<dl class="py method">
<dt id="orb.core.Cm1Vector1d.get_filter_bandpass_pix">
<code class="sig-name descname"><span class="pre">get_filter_bandpass_pix</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">border_ratio</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Cm1Vector1d.get_filter_bandpass_pix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return filter bandpass in channels</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>border_ratio</strong> – (Optional) Relative portion of filter
border removed (can be a negative float to get a bandpass
larger than the filter, default 0.)</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>(min, max)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.core.Cm1Vector1d.mean_in_filter">
<code class="sig-name descname"><span class="pre">mean_in_filter</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Cm1Vector1d.mean_in_filter" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="orb.core.Cm1Vector1d.needed_params">
<code class="sig-name descname"><span class="pre">needed_params</span></code><em class="property"> <span class="pre">=</span> <span class="pre">('filter_name',)</span></em><a class="headerlink" href="#orb.core.Cm1Vector1d.needed_params" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="orb.core.Cm1Vector1d.obs_params">
<code class="sig-name descname"><span class="pre">obs_params</span></code><em class="property"> <span class="pre">=</span> <span class="pre">('step',</span> <span class="pre">'order',</span> <span class="pre">'calib_coeff')</span></em><a class="headerlink" href="#orb.core.Cm1Vector1d.obs_params" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="orb.core.Cm1Vector1d.velocity_shift">
<code class="sig-name descname"><span class="pre">velocity_shift</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">velocity</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Cm1Vector1d.velocity_shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a vector with its axis shifted by a given velocity.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>velocity</strong> – Velocity in km/s</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="orb.core.ColorStreamHandler">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">orb.core.</span></code><code class="sig-name descname"><span class="pre">ColorStreamHandler</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stream</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.ColorStreamHandler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">logging.StreamHandler</span></code></p>
<p>Manage colored logging</p>
<p>copied from <a class="reference external" href="https://gist.github.com/mooware/a1ed40987b6cc9ab9c65">https://gist.github.com/mooware/a1ed40987b6cc9ab9c65</a></p>
<dl class="py attribute">
<dt id="orb.core.ColorStreamHandler.CRITICAL">
<code class="sig-name descname"><span class="pre">CRITICAL</span></code><em class="property"> <span class="pre">=</span> <span class="pre">'\x1b[31m'</span></em><a class="headerlink" href="#orb.core.ColorStreamHandler.CRITICAL" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="orb.core.ColorStreamHandler.DEBUG">
<code class="sig-name descname"><span class="pre">DEBUG</span></code><em class="property"> <span class="pre">=</span> <span class="pre">'\x1b[36m'</span></em><a class="headerlink" href="#orb.core.ColorStreamHandler.DEBUG" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="orb.core.ColorStreamHandler.DEFAULT">
<code class="sig-name descname"><span class="pre">DEFAULT</span></code><em class="property"> <span class="pre">=</span> <span class="pre">'\x1b[0m'</span></em><a class="headerlink" href="#orb.core.ColorStreamHandler.DEFAULT" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="orb.core.ColorStreamHandler.ERROR">
<code class="sig-name descname"><span class="pre">ERROR</span></code><em class="property"> <span class="pre">=</span> <span class="pre">'\x1b[31m'</span></em><a class="headerlink" href="#orb.core.ColorStreamHandler.ERROR" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="orb.core.ColorStreamHandler.INFO">
<code class="sig-name descname"><span class="pre">INFO</span></code><em class="property"> <span class="pre">=</span> <span class="pre">'\x1b[0m'</span></em><a class="headerlink" href="#orb.core.ColorStreamHandler.INFO" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="orb.core.ColorStreamHandler.WARNING">
<code class="sig-name descname"><span class="pre">WARNING</span></code><em class="property"> <span class="pre">=</span> <span class="pre">'\x1b[33m'</span></em><a class="headerlink" href="#orb.core.ColorStreamHandler.WARNING" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="orb.core.ColorStreamHandler.format">
<code class="sig-name descname"><span class="pre">format</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">record</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.ColorStreamHandler.format" title="Permalink to this definition">¶</a></dt>
<dd><p>Format the specified record.</p>
<p>If a formatter is set, use it. Otherwise, use the default formatter
for the module.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="orb.core.Data">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">orb.core.</span></code><code class="sig-name descname"><span class="pre">Data</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">err</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Data" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>base class for data objects.</p>
<p>data = array 
+ params (equiv to header, wcs params are contained in the params) 
+ axis (for 1d data and 3d data)
+ mask (1d for 1d, 2d for 2d and 3d)</p>
<dl class="py method">
<dt id="orb.core.Data.assert_axis">
<code class="sig-name descname"><span class="pre">assert_axis</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Data.assert_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Assert the presence of an axis</p>
</dd></dl>

<dl class="py method">
<dt id="orb.core.Data.assert_err">
<code class="sig-name descname"><span class="pre">assert_err</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Data.assert_err" title="Permalink to this definition">¶</a></dt>
<dd><p>Assert the presence of an error</p>
</dd></dl>

<dl class="py method">
<dt id="orb.core.Data.assert_mask">
<code class="sig-name descname"><span class="pre">assert_mask</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Data.assert_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Assert the presence of a mask</p>
</dd></dl>

<dl class="py method">
<dt id="orb.core.Data.assert_params">
<code class="sig-name descname"><span class="pre">assert_params</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Data.assert_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Assert the presence of parameters</p>
</dd></dl>

<dl class="py attribute">
<dt id="orb.core.Data.convert_params">
<code class="sig-name descname"><span class="pre">convert_params</span></code><em class="property"> <span class="pre">=</span> <span class="pre">{}</span></em><a class="headerlink" href="#orb.core.Data.convert_params" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="orb.core.Data.copy">
<code class="sig-name descname"><span class="pre">copy</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Data.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of the instance</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> – (Optional) can be used to change data</p></li>
<li><p><strong>kwargs</strong> – Addition kwargs (useful to copy child classes
with more kwargs at init)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.core.Data.copy_param">
<code class="sig-name descname"><span class="pre">copy_param</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">oldkey</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">newkey</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Data.copy_param" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy a parameter with a given key to a parameter with another
key. Do it only if the new key is not already set</p>
</dd></dl>

<dl class="py method">
<dt id="orb.core.Data.get_axis">
<code class="sig-name descname"><span class="pre">get_axis</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Data.get_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of self.axis</p>
</dd></dl>

<dl class="py method">
<dt id="orb.core.Data.get_err">
<code class="sig-name descname"><span class="pre">get_err</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Data.get_err" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of self.err</p>
</dd></dl>

<dl class="py method">
<dt id="orb.core.Data.get_gvar">
<code class="sig-name descname"><span class="pre">get_gvar</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Data.get_gvar" title="Permalink to this definition">¶</a></dt>
<dd><p>Return data and err as a gvar.GVar instance</p>
</dd></dl>

<dl class="py method">
<dt id="orb.core.Data.get_header">
<code class="sig-name descname"><span class="pre">get_header</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Data.get_header" title="Permalink to this definition">¶</a></dt>
<dd><p>Return params as an astropy.io.fits.Header instance</p>
</dd></dl>

<dl class="py method">
<dt id="orb.core.Data.get_mask">
<code class="sig-name descname"><span class="pre">get_mask</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Data.get_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of self.mask</p>
</dd></dl>

<dl class="py method">
<dt id="orb.core.Data.get_param">
<code class="sig-name descname"><span class="pre">get_param</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Data.get_param" title="Permalink to this definition">¶</a></dt>
<dd><p>Get class parameter</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>key</strong> – parameter key</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.core.Data.get_wcs">
<code class="sig-name descname"><span class="pre">get_wcs</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Data.get_wcs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="orb.core.Data.get_wcs_header">
<code class="sig-name descname"><span class="pre">get_wcs_header</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Data.get_wcs_header" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="orb.core.Data.has_axis">
<code class="sig-name descname"><span class="pre">has_axis</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Data.has_axis" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="orb.core.Data.has_err">
<code class="sig-name descname"><span class="pre">has_err</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Data.has_err" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="orb.core.Data.has_mask">
<code class="sig-name descname"><span class="pre">has_mask</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Data.has_mask" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="orb.core.Data.has_param">
<code class="sig-name descname"><span class="pre">has_param</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Data.has_param" title="Permalink to this definition">¶</a></dt>
<dd><p>Test the presence of a parameter</p>
</dd></dl>

<dl class="py method">
<dt id="orb.core.Data.has_params">
<code class="sig-name descname"><span class="pre">has_params</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Data.has_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Check the presence of observation parameters</p>
</dd></dl>

<dl class="py attribute">
<dt id="orb.core.Data.needed_params">
<code class="sig-name descname"><span class="pre">needed_params</span></code><em class="property"> <span class="pre">=</span> <span class="pre">()</span></em><a class="headerlink" href="#orb.core.Data.needed_params" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="orb.core.Data.set_header">
<code class="sig-name descname"><span class="pre">set_header</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">header</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Data.set_header" title="Permalink to this definition">¶</a></dt>
<dd><p>update params from an astropy.io.fits.Header instance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>header</strong> – An astropy.io.fits.Header instance.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.core.Data.set_mask">
<code class="sig-name descname"><span class="pre">set_mask</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Data.set_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Set mask.</p>
<p>A mask must have the shape of the data but for 3d data which
has a 2d mask (self.dimx, self.dimy). A Zero indicates a pixel
which should be masked (Nans are returned for this pixel).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>data</strong> – mask. Must be a boolean array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.core.Data.set_param">
<code class="sig-name descname"><span class="pre">set_param</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Data.set_param" title="Permalink to this definition">¶</a></dt>
<dd><p>Set class parameter</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>key</strong> – parameter key</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.core.Data.to_bundle">
<code class="sig-name descname"><span class="pre">to_bundle</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Data.to_bundle" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a bundle of picleable objects that can be passed to a
parallelized process and recreate the Data object.</p>
</dd></dl>

<dl class="py method">
<dt id="orb.core.Data.to_fits">
<code class="sig-name descname"><span class="pre">to_fits</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Data.to_fits" title="Permalink to this definition">¶</a></dt>
<dd><p>write data to a FITS file.</p>
<p>Note that most of the information will be lost in the
process. The only output guaranteed format is hdf5 (use
writeto() method)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>path</strong> – Path to the FITS file</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.core.Data.update_params">
<code class="sig-name descname"><span class="pre">update_params</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Data.update_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Update params with a dictionary or an astropy.io.fits.Header</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>params</strong> – A dict or an astropy.io.fits.Header instance.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.core.Data.writeto">
<code class="sig-name descname"><span class="pre">writeto</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Data.writeto" title="Permalink to this definition">¶</a></dt>
<dd><p>Write data to an hdf file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>path</strong> – hdf file path.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="orb.core.ExtDebugLoggingFilter">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">orb.core.</span></code><code class="sig-name descname"><span class="pre">ExtDebugLoggingFilter</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.ExtDebugLoggingFilter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">logging.Filter</span></code></p>
<dl class="py attribute">
<dt id="orb.core.ExtDebugLoggingFilter.bad_names">
<code class="sig-name descname"><span class="pre">bad_names</span></code><em class="property"> <span class="pre">=</span> <span class="pre">['pp']</span></em><a class="headerlink" href="#orb.core.ExtDebugLoggingFilter.bad_names" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="orb.core.ExtDebugLoggingFilter.filter">
<code class="sig-name descname"><span class="pre">filter</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">record</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.ExtDebugLoggingFilter.filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if the specified record is to be logged.</p>
<p>Is the specified record to be logged? Returns 0 for no, nonzero for
yes. If deemed appropriate, the record may be modified in-place.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="orb.core.ExtInfoLoggingFilter">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">orb.core.</span></code><code class="sig-name descname"><span class="pre">ExtInfoLoggingFilter</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.ExtInfoLoggingFilter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">logging.Filter</span></code></p>
<dl class="py attribute">
<dt id="orb.core.ExtInfoLoggingFilter.bad_names">
<code class="sig-name descname"><span class="pre">bad_names</span></code><em class="property"> <span class="pre">=</span> <span class="pre">['pp']</span></em><a class="headerlink" href="#orb.core.ExtInfoLoggingFilter.bad_names" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="orb.core.ExtInfoLoggingFilter.filter">
<code class="sig-name descname"><span class="pre">filter</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">record</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.ExtInfoLoggingFilter.filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if the specified record is to be logged.</p>
<p>Is the specified record to be logged? Returns 0 for no, nonzero for
yes. If deemed appropriate, the record may be modified in-place.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="orb.core.FilterFile">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">orb.core.</span></code><code class="sig-name descname"><span class="pre">FilterFile</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filter_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.FilterFile" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#orb.core.Vector1d" title="orb.core.Vector1d"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.core.Vector1d</span></code></a></p>
<p>Manage filter files</p>
<dl class="py method">
<dt id="orb.core.FilterFile.get_filter_bandpass">
<code class="sig-name descname"><span class="pre">get_filter_bandpass</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.FilterFile.get_filter_bandpass" title="Permalink to this definition">¶</a></dt>
<dd><p>Return filter bandpass in nm</p>
</dd></dl>

<dl class="py method">
<dt id="orb.core.FilterFile.get_filter_bandpass_cm1">
<code class="sig-name descname"><span class="pre">get_filter_bandpass_cm1</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.FilterFile.get_filter_bandpass_cm1" title="Permalink to this definition">¶</a></dt>
<dd><p>Return filter bandpass in cm-1</p>
</dd></dl>

<dl class="py method">
<dt id="orb.core.FilterFile.get_high_order_phase">
<code class="sig-name descname"><span class="pre">get_high_order_phase</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.FilterFile.get_high_order_phase" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="orb.core.FilterFile.get_mean_cm1">
<code class="sig-name descname"><span class="pre">get_mean_cm1</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.FilterFile.get_mean_cm1" title="Permalink to this definition">¶</a></dt>
<dd><p>Return mean wavenumber</p>
</dd></dl>

<dl class="py method">
<dt id="orb.core.FilterFile.get_mean_nm">
<code class="sig-name descname"><span class="pre">get_mean_nm</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.FilterFile.get_mean_nm" title="Permalink to this definition">¶</a></dt>
<dd><p>Return mean wavelength</p>
</dd></dl>

<dl class="py method">
<dt id="orb.core.FilterFile.get_modulation_efficiency">
<code class="sig-name descname"><span class="pre">get_modulation_efficiency</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.FilterFile.get_modulation_efficiency" title="Permalink to this definition">¶</a></dt>
<dd><p>Return modulation efficiency.</p>
</dd></dl>

<dl class="py method">
<dt id="orb.core.FilterFile.get_observation_params">
<code class="sig-name descname"><span class="pre">get_observation_params</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.FilterFile.get_observation_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Return observation params as tuple (step, order).</p>
</dd></dl>

<dl class="py method">
<dt id="orb.core.FilterFile.get_phase_fit_order">
<code class="sig-name descname"><span class="pre">get_phase_fit_order</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.FilterFile.get_phase_fit_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Return phase fit order.</p>
</dd></dl>

<dl class="py method">
<dt id="orb.core.FilterFile.get_phase_fit_ref">
<code class="sig-name descname"><span class="pre">get_phase_fit_ref</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.FilterFile.get_phase_fit_ref" title="Permalink to this definition">¶</a></dt>
<dd><p>Return reference wavenumber for phase fitting</p>
</dd></dl>

<dl class="py method">
<dt id="orb.core.FilterFile.get_sky_lines">
<code class="sig-name descname"><span class="pre">get_sky_lines</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">step_nb</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.FilterFile.get_sky_lines" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sky lines in a given filter</p>
</dd></dl>

<dl class="py method">
<dt id="orb.core.FilterFile.get_transmission">
<code class="sig-name descname"><span class="pre">get_transmission</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">step_nb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">corr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.FilterFile.get_transmission" title="Permalink to this definition">¶</a></dt>
<dd><p>Return transmission in the filter bandpass
:param step_nb: number of steps</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>corr</strong> – calibration coeff (at center if None)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="orb.core.FilterFile.needed_params">
<code class="sig-name descname"><span class="pre">needed_params</span></code><em class="property"> <span class="pre">=</span> <span class="pre">('step',</span> <span class="pre">'order',</span> <span class="pre">'phase_fit_order',</span> <span class="pre">'modulation_efficiency',</span> <span class="pre">'bandpass_min_nm',</span> <span class="pre">'bandpass_max_nm',</span> <span class="pre">'instrument')</span></em><a class="headerlink" href="#orb.core.FilterFile.needed_params" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="orb.core.FilterFile.project">
<code class="sig-name descname"><span class="pre">project</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">new_axis</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.FilterFile.project" title="Permalink to this definition">¶</a></dt>
<dd><p>Project vector on a new axis</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>new_axis</strong> – Axis. Must be an orb.core.Axis instance.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.core.FilterFile.read_filter_file">
<code class="sig-name descname"><span class="pre">read_filter_file</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">return_spline</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.FilterFile.read_filter_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Return transmission, axis and bandpass</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>return_spline</strong> – If True a cubic spline
(scipy.interpolate.UnivariateSpline instance) is returned
instead of a tuple (filter_nm, filter_trans, filter_min, filter_max)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="orb.core.Indexer">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">orb.core.</span></code><code class="sig-name descname"><span class="pre">Indexer</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Indexer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#orb.core.Tools" title="orb.core.Tools"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.core.Tools</span></code></a></p>
<p>Manage locations of created files.</p>
<p>All files locations are stored in a text-like file: the index
file. This file is the ‘real’ counterpart of the index (which is
‘virtual’ until <code class="xref py py-meth docutils literal notranslate"><span class="pre">core.Indexer.update_index()</span></code> is
called). This method is called each time
<code class="xref py py-meth docutils literal notranslate"><span class="pre">core.Indexer.__setitem__()</span></code> is called.</p>
<p>This class can be accessed like a dictionary.</p>
<dl class="py method">
<dt id="orb.core.Indexer.get_path">
<code class="sig-name descname"><span class="pre">get_path</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_group</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">err</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Indexer.get_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the path of a file recorded in the index.</p>
<p>Equivalent to self[file_key] if the option file_group is not used.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file_key</strong> – Key name of the file to be located</p></li>
<li><p><strong>file_group</strong> – (Optional) Add group prefix to the key
name. File group must be ‘cam1’, ‘cam2’, ‘merged’ or their
integer equivalent 1, 2, 0. File group can also be set to
None (default None).</p></li>
<li><p><strong>err</strong> – (Optional) Print an error instead of a warning if
the file is not indexed.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.core.Indexer.load_index">
<code class="sig-name descname"><span class="pre">load_index</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Indexer.load_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Load index file and rebuild index of already located files</p>
</dd></dl>

<dl class="py method">
<dt id="orb.core.Indexer.set_file_group">
<code class="sig-name descname"><span class="pre">set_file_group</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_group</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Indexer.set_file_group" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the group of the next files to be recorded. All given
file keys will be prefixed by the file group.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>file_group</strong> – File group must be ‘cam1’, ‘cam2’, ‘merged’
or their integer equivalent 1, 2, 0. File group can also be
set to None.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.core.Indexer.update_index">
<code class="sig-name descname"><span class="pre">update_index</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Indexer.update_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Update index files with data in the virtual index</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="orb.core.Lines">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">orb.core.</span></code><code class="sig-name descname"><span class="pre">Lines</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Lines" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#orb.core.Tools" title="orb.core.Tools"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.core.Tools</span></code></a></p>
<p>This class manages emission lines names and wavelengths.</p>
<p>Spectral lines rest wavelength (excerpt, all recorded lines are in
self.air_lines_nm):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">============</span> <span class="o">=======</span>
  <span class="n">Em</span><span class="o">.</span> <span class="n">Line</span>     <span class="n">Air</span>
<span class="o">============</span> <span class="o">=======</span>
<span class="p">[</span><span class="n">OII</span><span class="p">]</span><span class="mi">3726</span>    <span class="mf">372.603</span>
<span class="p">[</span><span class="n">OII</span><span class="p">]</span><span class="mi">3729</span>    <span class="mf">372.882</span>
<span class="n">Hepsilon</span>     <span class="mf">397.007</span>
<span class="n">Hdelta</span>       <span class="mf">410.176</span>
<span class="n">Hgamma</span>       <span class="mf">434.047</span>
<span class="p">[</span><span class="n">OIII</span><span class="p">]</span><span class="mi">4363</span>   <span class="mf">436.321</span>
<span class="n">Hbeta</span>        <span class="mf">486.133</span>
<span class="p">[</span><span class="n">OIII</span><span class="p">]</span><span class="mi">4959</span>   <span class="mf">495.892</span>
<span class="p">[</span><span class="n">OIII</span><span class="p">]</span><span class="mi">5007</span>   <span class="mf">500.684</span>
<span class="p">[</span><span class="n">NII</span><span class="p">]</span><span class="mi">6548</span>    <span class="mf">654.803</span>
<span class="n">Halpha</span>       <span class="mf">656.279</span>
<span class="p">[</span><span class="n">NII</span><span class="p">]</span><span class="mi">6583</span>    <span class="mf">658.341</span>
<span class="p">[</span><span class="n">SII</span><span class="p">]</span><span class="mi">6716</span>    <span class="mf">671.647</span>
<span class="p">[</span><span class="n">SII</span><span class="p">]</span><span class="mi">6731</span>    <span class="mf">673.085</span>
</pre></div>
</div>
<dl class="py attribute">
<dt id="orb.core.Lines.air_lines_name">
<code class="sig-name descname"><span class="pre">air_lines_name</span></code><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#orb.core.Lines.air_lines_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="orb.core.Lines.air_lines_nm">
<code class="sig-name descname"><span class="pre">air_lines_nm</span></code><em class="property"> <span class="pre">=</span> <span class="pre">{'H10':</span> <span class="pre">379.79044,</span> <span class="pre">'H11':</span> <span class="pre">377.06368,</span> <span class="pre">'H12':</span> <span class="pre">375.01584,</span> <span class="pre">'H13':</span> <span class="pre">373.43746,</span> <span class="pre">'H14':</span> <span class="pre">372.19449,</span> <span class="pre">'H15':</span> <span class="pre">371.19774,</span> <span class="pre">'H8':</span> <span class="pre">388.90557,</span> <span class="pre">'H9':</span> <span class="pre">383.53909,</span> <span class="pre">'Halpha':</span> <span class="pre">656.2819,</span> <span class="pre">'Hbeta':</span> <span class="pre">486.1333,</span> <span class="pre">'Hdelta':</span> <span class="pre">410.17415,</span> <span class="pre">'HeI5876':</span> <span class="pre">587.567,</span> <span class="pre">'HeI6678':</span> <span class="pre">667.81517,</span> <span class="pre">'HeI7065':</span> <span class="pre">706.52153,</span> <span class="pre">'Hepsilon':</span> <span class="pre">397.00788,</span> <span class="pre">'Hgamma':</span> <span class="pre">434.0471,</span> <span class="pre">'[ArIII]7136':</span> <span class="pre">713.579,</span> <span class="pre">'[ArIII]7751':</span> <span class="pre">775.111,</span> <span class="pre">'[NII]5755':</span> <span class="pre">575.459,</span> <span class="pre">'[NII]6548':</span> <span class="pre">654.805,</span> <span class="pre">'[NII]6583':</span> <span class="pre">658.345,</span> <span class="pre">'[NeIII]3869':</span> <span class="pre">386.876,</span> <span class="pre">'[OIII]4363':</span> <span class="pre">436.3209,</span> <span class="pre">'[OIII]4959':</span> <span class="pre">495.8911,</span> <span class="pre">'[OIII]5007':</span> <span class="pre">500.6843,</span> <span class="pre">'[OII]3726':</span> <span class="pre">372.6032,</span> <span class="pre">'[OII]3729':</span> <span class="pre">372.8815,</span> <span class="pre">'[OII]7320':</span> <span class="pre">731.992,</span> <span class="pre">'[OII]7330':</span> <span class="pre">733.019,</span> <span class="pre">'[OI]6300':</span> <span class="pre">630.0304,</span> <span class="pre">'[SIII]6312':</span> <span class="pre">631.206,</span> <span class="pre">'[SII]6716':</span> <span class="pre">671.644,</span> <span class="pre">'[SII]6731':</span> <span class="pre">673.0816}</span></em><a class="headerlink" href="#orb.core.Lines.air_lines_nm" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="orb.core.Lines.air_sky_lines_nm">
<code class="sig-name descname"><span class="pre">air_sky_lines_nm</span></code><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#orb.core.Lines.air_sky_lines_nm" title="Permalink to this definition">¶</a></dt>
<dd><p>Air sky lines wavelength</p>
</dd></dl>

<dl class="py method">
<dt id="orb.core.Lines.get_line_cm1">
<code class="sig-name descname"><span class="pre">get_line_cm1</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lines_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">round_ang</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Lines.get_line_cm1" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the wavenumber of a line or a list of lines</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>lines_name</strong> – List of line names</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.core.Lines.get_line_name">
<code class="sig-name descname"><span class="pre">get_line_name</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lines</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Lines.get_line_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the name of a line or a list of lines given their
wavelength.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>lines</strong> – List of lines wavelength</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.core.Lines.get_line_nm">
<code class="sig-name descname"><span class="pre">get_line_nm</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lines_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">round_ang</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Lines.get_line_nm" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the wavelength of a line or a list of lines</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lines_name</strong> – List of line names</p></li>
<li><p><strong>round_ang</strong> – (Optional) If True return the rounded
wavelength of the line in angstrom (default False)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.core.Lines.get_sky_lines">
<code class="sig-name descname"><span class="pre">get_sky_lines</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nm_min</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nm_max</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta_nm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">line_nb</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_names</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Lines.get_sky_lines" title="Permalink to this definition">¶</a></dt>
<dd><p>Return sky lines in a range of optical wavelength.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nm_min</strong> – min Wavelength of the lines in nm</p></li>
<li><p><strong>nm_max</strong> – max Wavelength of the lines in nm</p></li>
<li><p><strong>delta_nm</strong> – Wavelength resolution in nm as the minimum
wavelength interval of the spectrum. Lines comprises in half
of this interval are merged.</p></li>
<li><p><strong>line_nb</strong> – (Optional) Number of the most intense lines to
retrieve. If 0 all lines are given (default 0).</p></li>
<li><p><strong>get_name</strong> – (Optional) If True return lines name also.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="orb.core.Lines.other_names">
<code class="sig-name descname"><span class="pre">other_names</span></code><em class="property"> <span class="pre">=</span> <span class="pre">{'Halpha':</span> <span class="pre">['H3'],</span> <span class="pre">'Hbeta':</span> <span class="pre">['H4'],</span> <span class="pre">'Hdelta':</span> <span class="pre">['H6'],</span> <span class="pre">'Hepsilon':</span> <span class="pre">['H7'],</span> <span class="pre">'Hgamma':</span> <span class="pre">['H5'],</span> <span class="pre">'[NII]6583':</span> <span class="pre">['[NII]6584'],</span> <span class="pre">'[OII]3726':</span> <span class="pre">['[OII]3727'],</span> <span class="pre">'[SII]6716':</span> <span class="pre">['[SII]6717']}</span></em><a class="headerlink" href="#orb.core.Lines.other_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Air emission lines wavelength</p>
</dd></dl>

<dl class="py method">
<dt id="orb.core.Lines.round_nm2ang">
<code class="sig-name descname"><span class="pre">round_nm2ang</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nm</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Lines.round_nm2ang" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a wavelength in nm into a rounded value in angstrom</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>nm</strong> – Line wavelength in nm</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="orb.core.Lines.sky_lines_file_name">
<code class="sig-name descname"><span class="pre">sky_lines_file_name</span></code><em class="property"> <span class="pre">=</span> <span class="pre">'sky_lines.orb'</span></em><a class="headerlink" href="#orb.core.Lines.sky_lines_file_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of the sky lines data file.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="orb.core.LogRecordSocketReceiver">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">orb.core.</span></code><code class="sig-name descname"><span class="pre">LogRecordSocketReceiver</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">host='localhost'</span></em>, <em class="sig-param"><span class="pre">port=9020</span></em>, <em class="sig-param"><span class="pre">handler=&lt;class</span> <span class="pre">'orb.core.LogRecordStreamHandler'&gt;</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.LogRecordSocketReceiver" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">socketserver.ThreadingTCPServer</span></code></p>
<p>Simple TCP socket-based logging receiver suitable for testing.</p>
<dl class="py method">
<dt id="orb.core.LogRecordSocketReceiver.serve_until_stopped">
<code class="sig-name descname"><span class="pre">serve_until_stopped</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.LogRecordSocketReceiver.serve_until_stopped" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="orb.core.LogRecordSocketReceiver.server_bind">
<code class="sig-name descname"><span class="pre">server_bind</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.LogRecordSocketReceiver.server_bind" title="Permalink to this definition">¶</a></dt>
<dd><p>Called by constructor to bind the socket.</p>
<p>May be overridden.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="orb.core.LogRecordStreamHandler">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">orb.core.</span></code><code class="sig-name descname"><span class="pre">LogRecordStreamHandler</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">request</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">client_address</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">server</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.LogRecordStreamHandler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">socketserver.StreamRequestHandler</span></code></p>
<p>Handler for a streaming logging request.</p>
<p>This basically logs the record using whatever logging policy is
configured locally.</p>
<dl class="py method">
<dt id="orb.core.LogRecordStreamHandler.handle">
<code class="sig-name descname"><span class="pre">handle</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.LogRecordStreamHandler.handle" title="Permalink to this definition">¶</a></dt>
<dd><p>Handle multiple requests - each expected to be a 4-byte length,
followed by the LogRecord in pickle format. Logs the record
according to whatever policy is configured locally.</p>
</dd></dl>

<dl class="py method">
<dt id="orb.core.LogRecordStreamHandler.handleLogRecord">
<code class="sig-name descname"><span class="pre">handleLogRecord</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">record</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.LogRecordStreamHandler.handleLogRecord" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="orb.core.LogRecordStreamHandler.unPickle">
<code class="sig-name descname"><span class="pre">unPickle</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.LogRecordStreamHandler.unPickle" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt id="orb.core.Logger">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">orb.core.</span></code><code class="sig-name descname"><span class="pre">Logger</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">debug</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">logfilter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'default'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Logger" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py method">
<dt id="orb.core.Logger.getLogger">
<code class="sig-name descname"><span class="pre">getLogger</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Logger.getLogger" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="orb.core.Logger.get_file_logging_state">
<code class="sig-name descname"><span class="pre">get_file_logging_state</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Logger.get_file_logging_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the file logging appears set</p>
</dd></dl>

<dl class="py method">
<dt id="orb.core.Logger.get_logdateformat">
<code class="sig-name descname"><span class="pre">get_logdateformat</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Logger.get_logdateformat" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a string describing the logging date format</p>
</dd></dl>

<dl class="py method">
<dt id="orb.core.Logger.get_logfilter">
<code class="sig-name descname"><span class="pre">get_logfilter</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">logfilter</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Logger.get_logfilter" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="orb.core.Logger.get_logformat">
<code class="sig-name descname"><span class="pre">get_logformat</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Logger.get_logformat" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a string describing the logging format</p>
</dd></dl>

<dl class="py method">
<dt id="orb.core.Logger.get_logging_state">
<code class="sig-name descname"><span class="pre">get_logging_state</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Logger.get_logging_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the logging is set</p>
</dd></dl>

<dl class="py method">
<dt id="orb.core.Logger.get_simplelogformat">
<code class="sig-name descname"><span class="pre">get_simplelogformat</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Logger.get_simplelogformat" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a string describing the simple logging format</p>
</dd></dl>

<dl class="py method">
<dt id="orb.core.Logger.listen">
<code class="sig-name descname"><span class="pre">listen</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Logger.listen" title="Permalink to this definition">¶</a></dt>
<dd><p>Listen and handle logging sent on TCP socket</p>
</dd></dl>

<dl class="py attribute">
<dt id="orb.core.Logger.logfilters">
<code class="sig-name descname"><span class="pre">logfilters</span></code><em class="property"> <span class="pre">=</span> <span class="pre">{'default':</span> <span class="pre">&lt;orb.core.ExtDebugLoggingFilter</span> <span class="pre">object&gt;,</span> <span class="pre">'extdebug':</span> <span class="pre">&lt;orb.core.ExtDebugLoggingFilter</span> <span class="pre">object&gt;,</span> <span class="pre">'extinfo':</span> <span class="pre">&lt;orb.core.ExtInfoLoggingFilter</span> <span class="pre">object&gt;,</span> <span class="pre">'none':</span> <span class="pre">&lt;orb.core.NoLoggingFilter</span> <span class="pre">object&gt;}</span></em><a class="headerlink" href="#orb.core.Logger.logfilters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="orb.core.Logger.start_file_logging">
<code class="sig-name descname"><span class="pre">start_file_logging</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">logfile_path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">logfilter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Logger.start_file_logging" title="Permalink to this definition">¶</a></dt>
<dd><p>Start file logging</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>logfile_path</strong> – Path to the logfile. If none is provided
a default logfile path is used.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.core.Logger.start_logging">
<code class="sig-name descname"><span class="pre">start_logging</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">logfilter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Logger.start_logging" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset logging only if logging is not set</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>logfilter</strong> – If set to None, default logfilter set at
init will be applied (default None)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="orb.core.NoInstrumentConfigParams">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">orb.core.</span></code><code class="sig-name descname"><span class="pre">NoInstrumentConfigParams</span></code><a class="headerlink" href="#orb.core.NoInstrumentConfigParams" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#orb.core.ROParams" title="orb.core.ROParams"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.core.ROParams</span></code></a></p>
<p>Special dictionary which elements can be accessed like
attributes.</p>
<p>Attributes are read-only and may be defined only once.</p>
</dd></dl>

<dl class="py class">
<dt id="orb.core.NoLoggingFilter">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">orb.core.</span></code><code class="sig-name descname"><span class="pre">NoLoggingFilter</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.NoLoggingFilter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">logging.Filter</span></code></p>
<dl class="py method">
<dt id="orb.core.NoLoggingFilter.filter">
<code class="sig-name descname"><span class="pre">filter</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">record</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.NoLoggingFilter.filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if the specified record is to be logged.</p>
<p>Is the specified record to be logged? Returns 0 for no, nonzero for
yes. If deemed appropriate, the record may be modified in-place.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="orb.core.Params">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">orb.core.</span></code><code class="sig-name descname"><span class="pre">Params</span></code><a class="headerlink" href="#orb.core.Params" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></p>
<p>Special dictionary which elements can be accessed like
attributes.</p>
<dl class="py method">
<dt id="orb.core.Params.convert">
<code class="sig-name descname"><span class="pre">convert</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Params.convert" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert to a nice pickable object</p>
</dd></dl>

<dl class="py method">
<dt id="orb.core.Params.load">
<code class="sig-name descname"><span class="pre">load</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Params.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Load data from an HDF5 file saved with save method.</p>
</dd></dl>

<dl class="py method">
<dt id="orb.core.Params.save">
<code class="sig-name descname"><span class="pre">save</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Params.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Try to save data in an HDF5 format.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>All elements might not be saved</p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="orb.core.ParamsFile">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">orb.core.</span></code><code class="sig-name descname"><span class="pre">ParamsFile</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.ParamsFile" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#orb.core.Tools" title="orb.core.Tools"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.core.Tools</span></code></a></p>
<p>Manage correspondance between multiple dict containing the
same parameters and a file on disk.</p>
<p>Its behaviour is similar to <code class="xref py py-class docutils literal notranslate"><span class="pre">astrometry.StarsParams</span></code>.</p>
<dl class="py method">
<dt id="orb.core.ParamsFile.append">
<code class="sig-name descname"><span class="pre">append</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.ParamsFile.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Append a dict to the file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>params</strong> – A dict of parameters</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="orb.core.ParamsFile.f">
<code class="sig-name descname"><span class="pre">f</span></code><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#orb.core.ParamsFile.f" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="orb.core.ParamsFile.get_data">
<code class="sig-name descname"><span class="pre">get_data</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.ParamsFile.get_data" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt id="orb.core.ProgressBar">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">orb.core.</span></code><code class="sig-name descname"><span class="pre">ProgressBar</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">max_index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">silent</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.ProgressBar" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Display a simple progress bar in the terminal</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>max_index</strong> – Index representing a 100% completed task.</p>
</dd>
</dl>
<dl class="py attribute">
<dt id="orb.core.ProgressBar.BAR_LENGTH">
<code class="sig-name descname"><span class="pre">BAR_LENGTH</span></code><em class="property"> <span class="pre">=</span> <span class="pre">10.0</span></em><a class="headerlink" href="#orb.core.ProgressBar.BAR_LENGTH" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="orb.core.ProgressBar.MAX_CARAC">
<code class="sig-name descname"><span class="pre">MAX_CARAC</span></code><em class="property"> <span class="pre">=</span> <span class="pre">78</span></em><a class="headerlink" href="#orb.core.ProgressBar.MAX_CARAC" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="orb.core.ProgressBar.REFRESH_COUNT">
<code class="sig-name descname"><span class="pre">REFRESH_COUNT</span></code><em class="property"> <span class="pre">=</span> <span class="pre">3</span></em><a class="headerlink" href="#orb.core.ProgressBar.REFRESH_COUNT" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="orb.core.ProgressBar.end">
<code class="sig-name descname"><span class="pre">end</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">silent</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.ProgressBar.end" title="Permalink to this definition">¶</a></dt>
<dd><p>End the progress bar and display the total time needed to
complete the process.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>silent</strong> – If True remove the progress bar from the
screen. Further diplayed text will be displayed above the
progress bar.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.core.ProgressBar.update">
<code class="sig-name descname"><span class="pre">update</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">info</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">remains</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nolog</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.ProgressBar.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the progress bar.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>index</strong> – Index representing the progress of the
process. Must be less than index_max.</p></li>
<li><p><strong>info</strong> – (Optional) Information to be displayed as
comments (default ‘’).</p></li>
<li><p><strong>remains</strong> – (Optional) If True, remaining time is
displayed (default True).</p></li>
<li><p><strong>nolog</strong> – (Optional) No logging of the printed text is
made (default True).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="orb.core.ROParams">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">orb.core.</span></code><code class="sig-name descname"><span class="pre">ROParams</span></code><a class="headerlink" href="#orb.core.ROParams" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#orb.core.Params" title="orb.core.Params"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.core.Params</span></code></a></p>
<p>Special dictionary which elements can be accessed like
attributes.</p>
<p>Attributes are read-only and may be defined only once.</p>
<dl class="py method">
<dt id="orb.core.ROParams.reset">
<code class="sig-name descname"><span class="pre">reset</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.ROParams.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Force parameter reset</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="orb.core.TextColor">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">orb.core.</span></code><code class="sig-name descname"><span class="pre">TextColor</span></code><a class="headerlink" href="#orb.core.TextColor" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Define ANSI Escape sequences to display text with colors.</p>
<dl class="py attribute">
<dt id="orb.core.TextColor.CYAN">
<code class="sig-name descname"><span class="pre">CYAN</span></code><em class="property"> <span class="pre">=</span> <span class="pre">'\x1b[36m'</span></em><a class="headerlink" href="#orb.core.TextColor.CYAN" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="orb.core.TextColor.DEFAULT">
<code class="sig-name descname"><span class="pre">DEFAULT</span></code><em class="property"> <span class="pre">=</span> <span class="pre">'\x1b[0m'</span></em><a class="headerlink" href="#orb.core.TextColor.DEFAULT" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="orb.core.TextColor.END">
<code class="sig-name descname"><span class="pre">END</span></code><em class="property"> <span class="pre">=</span> <span class="pre">'\x1b[0m'</span></em><a class="headerlink" href="#orb.core.TextColor.END" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="orb.core.TextColor.GREEN">
<code class="sig-name descname"><span class="pre">GREEN</span></code><em class="property"> <span class="pre">=</span> <span class="pre">'\x1b[32m'</span></em><a class="headerlink" href="#orb.core.TextColor.GREEN" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="orb.core.TextColor.KORED">
<code class="sig-name descname"><span class="pre">KORED</span></code><em class="property"> <span class="pre">=</span> <span class="pre">'\x1b[91m'</span></em><a class="headerlink" href="#orb.core.TextColor.KORED" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="orb.core.TextColor.OKGREEN">
<code class="sig-name descname"><span class="pre">OKGREEN</span></code><em class="property"> <span class="pre">=</span> <span class="pre">'\x1b[92m'</span></em><a class="headerlink" href="#orb.core.TextColor.OKGREEN" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="orb.core.TextColor.RED">
<code class="sig-name descname"><span class="pre">RED</span></code><em class="property"> <span class="pre">=</span> <span class="pre">'\x1b[31m'</span></em><a class="headerlink" href="#orb.core.TextColor.RED" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="orb.core.TextColor.YELLOW">
<code class="sig-name descname"><span class="pre">YELLOW</span></code><em class="property"> <span class="pre">=</span> <span class="pre">'\x1b[33m'</span></em><a class="headerlink" href="#orb.core.TextColor.YELLOW" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt id="orb.core.Tools">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">orb.core.</span></code><code class="sig-name descname"><span class="pre">Tools</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">instrument</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">config</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_prefix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'./temp/data.'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Tools" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Base parent class for processing classes.</p>
<p>Load instrument config file and give access to orb data files.</p>
<dl class="py attribute">
<dt id="orb.core.Tools.filters">
<code class="sig-name descname"><span class="pre">filters</span></code><em class="property"> <span class="pre">=</span> <span class="pre">['SN1',</span> <span class="pre">'SN2',</span> <span class="pre">'SN3',</span> <span class="pre">'C1',</span> <span class="pre">'C2',</span> <span class="pre">'C3',</span> <span class="pre">'C4',</span> <span class="pre">'FULL',</span> <span class="pre">'PS1_r',</span> <span class="pre">'PS1_i',</span> <span class="pre">'PS1_g',</span> <span class="pre">'PS1_y',</span> <span class="pre">'PS1_z',</span> <span class="pre">'F656N']</span></em><a class="headerlink" href="#orb.core.Tools.filters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="orb.core.Tools.instruments">
<code class="sig-name descname"><span class="pre">instruments</span></code><em class="property"> <span class="pre">=</span> <span class="pre">['sitelle',</span> <span class="pre">'spiomm']</span></em><a class="headerlink" href="#orb.core.Tools.instruments" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="orb.core.Tools.load_sip">
<code class="sig-name descname"><span class="pre">load_sip</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fits_path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Tools.load_sip" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a astropy.wcs.WCS object from a FITS file containing
SIP parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>fits_path</strong> – Path to the FITS file</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.core.Tools.save_sip">
<code class="sig-name descname"><span class="pre">save_sip</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fits_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hdr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">overwrite</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Tools.save_sip" title="Permalink to this definition">¶</a></dt>
<dd><p>Save SIP parameters from a header to a blanck FITS file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fits_path</strong> – Path to the FITS file</p></li>
<li><p><strong>hdr</strong> – header from which SIP parameters must be read</p></li>
<li><p><strong>overwrite</strong> – (Optional) Overwrite the FITS file.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.core.Tools.set_config">
<code class="sig-name descname"><span class="pre">set_config</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cast</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optional</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Tools.set_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Set configuration parameter (from the configuration file)</p>
</dd></dl>

<dl class="py method">
<dt id="orb.core.Tools.update_config">
<code class="sig-name descname"><span class="pre">update_config</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">config</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Tools.update_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Update config values from a dict</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>config</strong> – Configuration dictionary</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="orb.core.Vector1d">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">orb.core.</span></code><code class="sig-name descname"><span class="pre">Vector1d</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Vector1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#orb.core.Data" title="orb.core.Data"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.core.Data</span></code></a></p>
<p>Basic 1d vector management class.</p>
<p>Vector can have a projection axis.</p>
<dl class="py method">
<dt id="orb.core.Vector1d.add">
<code class="sig-name descname"><span class="pre">add</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Vector1d.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Add another vector. Note that, if the axis differs, only the
common part is kept.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>vector</strong> – Must be a Vector1d instance.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.core.Vector1d.crop">
<code class="sig-name descname"><span class="pre">crop</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xmin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xmax</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">returned_class</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Vector1d.crop" title="Permalink to this definition">¶</a></dt>
<dd><p>Crop data. 
:param xmin: xmin
:param xmax: xmax</p>
</dd></dl>

<dl class="py method">
<dt id="orb.core.Vector1d.math">
<code class="sig-name descname"><span class="pre">math</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">opname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Vector1d.math" title="Permalink to this definition">¶</a></dt>
<dd><p>Do math operations with another vector instance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>opname</strong> – math operation, must be a numpy.ufuncs.</p></li>
<li><p><strong>arg</strong> – If None, no argument is supplied. Else, can be a
float or a Vector1d instance.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.core.Vector1d.multiply">
<code class="sig-name descname"><span class="pre">multiply</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Vector1d.multiply" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply by another vector. Note that, if the axis differs, only the
common part is kept.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>vector</strong> – Must be a Cm1Vector1d instance.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.core.Vector1d.plot">
<code class="sig-name descname"><span class="pre">plot</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">plot_real</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Vector1d.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot vector</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>plot_real</strong> – If True, plot only the real part, if False
plot only the imaginary part, if both, plot the real and
imaginary part. Plot only the real part by default.</p></li>
<li><p><strong>kwargs</strong> – All keyword arguments accepted by
matplotlib.plot()</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.core.Vector1d.project">
<code class="sig-name descname"><span class="pre">project</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">new_axis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">returned_class</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">quality</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">timing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Vector1d.project" title="Permalink to this definition">¶</a></dt>
<dd><p>Project vector on a new axis</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>new_axis</strong> – Axis. Must be an orb.core.Axis instance.</p></li>
<li><p><strong>returned_class</strong> – (Optional) If not None, set the
returned class. Must be a subclass of Vector1d.</p></li>
<li><p><strong>quality</strong> – an integer from 2 to infinity which gives the
zero padding factor before interpolation. The more zero
padding, the better will be the interpolation, but the
slower too.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A new Spectrum instance</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Though much (much!) faster than pure resampling, this can
be a little less precise for complex data. For non complex
data, its nothing more than a linear interpolation.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="orb.core.Vector1d.reverse">
<code class="sig-name descname"><span class="pre">reverse</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Vector1d.reverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverse data. Do not reverse the axis.</p>
</dd></dl>

<dl class="py method">
<dt id="orb.core.Vector1d.subtract">
<code class="sig-name descname"><span class="pre">subtract</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Vector1d.subtract" title="Permalink to this definition">¶</a></dt>
<dd><p>Subtract another vector. Note that, if the axis differs, only the
common part is kept.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>vector</strong> – Must be a Cm1Vector1d instance.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.core.Vector1d.sum">
<code class="sig-name descname"><span class="pre">sum</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Vector1d.sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Sum of the data</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="orb.core.WCSData">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">orb.core.</span></code><code class="sig-name descname"><span class="pre">WCSData</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instrument</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">config</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_prefix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'./'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.WCSData" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#orb.core.Tools" title="orb.core.Tools"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.core.Tools</span></code></a>, <a class="reference internal" href="#orb.core.Data" title="orb.core.Data"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.core.Data</span></code></a></p>
<p>Add WCS functionalities to a Data instance.</p>
<dl class="py method">
<dt id="orb.core.WCSData.arc2pix">
<code class="sig-name descname"><span class="pre">arc2pix</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.WCSData.arc2pix" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert pixels to arcseconds</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> – a value or a vector in pixel</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.core.WCSData.assert_dxdymaps">
<code class="sig-name descname"><span class="pre">assert_dxdymaps</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.WCSData.assert_dxdymaps" title="Permalink to this definition">¶</a></dt>
<dd><p>Raise an exception if dxdymaps are not loaded</p>
</dd></dl>

<dl class="py attribute">
<dt id="orb.core.WCSData.convert_params">
<code class="sig-name descname"><span class="pre">convert_params</span></code><em class="property"> <span class="pre">=</span> <span class="pre">{'AIRMASS':</span> <span class="pre">'airmass',</span> <span class="pre">'BINNING':</span> <span class="pre">'binning',</span> <span class="pre">'CAMERA':</span> <span class="pre">'camera',</span> <span class="pre">'EXPTIME':</span> <span class="pre">'exposure_time',</span> <span class="pre">'FILTER':</span> <span class="pre">'filter_name',</span> <span class="pre">'INSTRUME':</span> <span class="pre">'instrument',</span> <span class="pre">'camera_number':</span> <span class="pre">'camera'}</span></em><a class="headerlink" href="#orb.core.WCSData.convert_params" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="orb.core.WCSData.default_params">
<code class="sig-name descname"><span class="pre">default_params</span></code><em class="property"> <span class="pre">=</span> <span class="pre">{'camera':</span> <span class="pre">1,</span> <span class="pre">'target_dec':</span> <span class="pre">0.0,</span> <span class="pre">'target_ra':</span> <span class="pre">0.0,</span> <span class="pre">'target_x':</span> <span class="pre">0,</span> <span class="pre">'target_y':</span> <span class="pre">0}</span></em><a class="headerlink" href="#orb.core.WCSData.default_params" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="orb.core.WCSData.get_initial_alignment_parameters">
<code class="sig-name descname"><span class="pre">get_initial_alignment_parameters</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.WCSData.get_initial_alignment_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Return initial alignemnt coefficients for camera 2 as a core.Params instance</p>
</dd></dl>

<dl class="py method">
<dt id="orb.core.WCSData.get_scale">
<code class="sig-name descname"><span class="pre">get_scale</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.WCSData.get_scale" title="Permalink to this definition">¶</a></dt>
<dd><p>Return mean platescale in arcsec/pixel</p>
</dd></dl>

<dl class="py method">
<dt id="orb.core.WCSData.get_wcs">
<code class="sig-name descname"><span class="pre">get_wcs</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">validate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.WCSData.get_wcs" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the WCS of the cube as an astropy.wcs.WCS instance</p>
</dd></dl>

<dl class="py method">
<dt id="orb.core.WCSData.get_wcs_header">
<code class="sig-name descname"><span class="pre">get_wcs_header</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.WCSData.get_wcs_header" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the WCS of the cube as a astropy.io.fits.Header instance</p>
</dd></dl>

<dl class="py method">
<dt id="orb.core.WCSData.has_dxdymaps">
<code class="sig-name descname"><span class="pre">has_dxdymaps</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.WCSData.has_dxdymaps" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True is self.dxmap and self.dymap exist</p>
</dd></dl>

<dl class="py method">
<dt id="orb.core.WCSData.is_cam1">
<code class="sig-name descname"><span class="pre">is_cam1</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.WCSData.is_cam1" title="Permalink to this definition">¶</a></dt>
<dd><p>Return true is image comes from camera 1 or is a merged frame</p>
</dd></dl>

<dl class="py method">
<dt id="orb.core.WCSData.is_cam2">
<code class="sig-name descname"><span class="pre">is_cam2</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.WCSData.is_cam2" title="Permalink to this definition">¶</a></dt>
<dd><p>Return true is image comes from camera 2</p>
</dd></dl>

<dl class="py method">
<dt id="orb.core.WCSData.pix2arc">
<code class="sig-name descname"><span class="pre">pix2arc</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.WCSData.pix2arc" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert arcseconds to pixels</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> – a value or a vector in arcsec</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.core.WCSData.pix2world">
<code class="sig-name descname"><span class="pre">pix2world</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xy</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">deg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.WCSData.pix2world" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert pixel coordinates to celestial coordinates</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xy</strong> – A tuple (x,y) of pixel coordinates or a list of
tuples ((x0,y0), (x1,y1), …)</p></li>
<li><p><strong>deg</strong> – (Optional) If true, celestial coordinates are
returned in sexagesimal format (default False).</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>it is much more efficient to pass a list of
coordinates than run the function for each couple of
coordinates you want to transform.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="orb.core.WCSData.query_vizier">
<code class="sig-name descname"><span class="pre">query_vizier</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">catalog</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'gaia'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_stars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">as_pandas</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.WCSData.query_vizier" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of star coordinates around an object in a
given radius based on a query to VizieR Services
(<a class="reference external" href="http://vizier.u-strasbg.fr/viz-bin/VizieR">http://vizier.u-strasbg.fr/viz-bin/VizieR</a>)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>catalog</strong> – (Optional) Catalog to ask on the VizieR
database (see notes) (default ‘gaia’)</p></li>
<li><p><strong>max_stars</strong> – (Optional) Maximum number of row to retrieve
(default 100)</p></li>
<li><p><strong>as_pandas</strong> – (Optional) If True, results are returned as a
pandas.DataFrame instance. Else a numpy.ndarray instance is
returned (default False).</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-meth docutils literal notranslate"><span class="pre">orb.orb.utils.web.query_vizier()</span></code></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="orb.core.WCSData.set_dxdymaps">
<code class="sig-name descname"><span class="pre">set_dxdymaps</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dxmap</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dymap</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.WCSData.set_dxdymaps" title="Permalink to this definition">¶</a></dt>
<dd><p>Set dxmap and dymap. Must have the same shape as the image shape.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dxmap</strong> – Path to a dxmap or a numpy.ndarray</p></li>
<li><p><strong>dymap</strong> – Path to a dymap or a numpy.ndarray</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.core.WCSData.set_wcs">
<code class="sig-name descname"><span class="pre">set_wcs</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">wcs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.WCSData.set_wcs" title="Permalink to this definition">¶</a></dt>
<dd><p>Set WCS from a WCS instance or a FITS image</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>wcs</strong> – Must be an astropy.wcs.WCS instance or a path to a FITS image</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.core.WCSData.validate_wcs">
<code class="sig-name descname"><span class="pre">validate_wcs</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.WCSData.validate_wcs" title="Permalink to this definition">¶</a></dt>
<dd><p>Verify the internal coherence between comprehensive wcs parameters
and FITS keywords.</p>
</dd></dl>

<dl class="py method">
<dt id="orb.core.WCSData.world2pix">
<code class="sig-name descname"><span class="pre">world2pix</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radec</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.WCSData.world2pix" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert celestial coordinates to pixel coordinates</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>xy</strong> – A tuple (x,y) of celestial coordinates or a list of
tuples ((x0,y0), (x1,y1), …). Must be in degrees.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>it is much more effficient to pass a list of
coordinates than run the function for each couple of
coordinates you want to transform.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="orb.core.WCSData.writeto">
<code class="sig-name descname"><span class="pre">writeto</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.WCSData.writeto" title="Permalink to this definition">¶</a></dt>
<dd><p>Write data to an hdf file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>path</strong> – hdf file path.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="orb.core.Waves">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">orb.core.</span></code><code class="sig-name descname"><span class="pre">Waves</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">velocity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Waves" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Wave class that keep the best conversions possible from nm to cm1.</p>
<dl class="py method">
<dt id="orb.core.Waves.get_cm1">
<code class="sig-name descname"><span class="pre">get_cm1</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Waves.get_cm1" title="Permalink to this definition">¶</a></dt>
<dd><p>Return wavenumber of waves in cm-1 (taking velocity into account)</p>
</dd></dl>

<dl class="py method">
<dt id="orb.core.Waves.get_cm1_rest">
<code class="sig-name descname"><span class="pre">get_cm1_rest</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Waves.get_cm1_rest" title="Permalink to this definition">¶</a></dt>
<dd><p>Return restframe wavelength of waves in cm-1</p>
</dd></dl>

<dl class="py method">
<dt id="orb.core.Waves.get_nm">
<code class="sig-name descname"><span class="pre">get_nm</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Waves.get_nm" title="Permalink to this definition">¶</a></dt>
<dd><p>Return wavelength of waves in nm (taking velocity into account)</p>
</dd></dl>

<dl class="py method">
<dt id="orb.core.Waves.get_nm_rest">
<code class="sig-name descname"><span class="pre">get_nm_rest</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Waves.get_nm_rest" title="Permalink to this definition">¶</a></dt>
<dd><p>“Return restframe wavelength of waves in nm</p>
</dd></dl>

<dl class="py method">
<dt id="orb.core.Waves.set_velocity">
<code class="sig-name descname"><span class="pre">set_velocity</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">velocity</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.core.Waves.set_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Set waves velocity.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>velocity</strong> – velocity in km/s</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-orb.cube">
<span id="orb-cube-module"></span><h2>orb.cube module<a class="headerlink" href="#module-orb.cube" title="Permalink to this headline">¶</a></h2>
<p>Cube handling module</p>
<dl class="py class">
<dt id="orb.cube.Cube">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">orb.cube.</span></code><code class="sig-name descname"><span class="pre">Cube</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instrument</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.Cube" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#orb.cube.HDFCube" title="orb.cube.HDFCube"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.cube.HDFCube</span></code></a></p>
<p>Provide additional cube methods when observation parameters are known.</p>
<dl class="py method">
<dt id="orb.cube.Cube.get_axis_corr">
<code class="sig-name descname"><span class="pre">get_axis_corr</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.Cube.get_axis_corr" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the reference wavenumber correction</p>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.Cube.get_base_axis">
<code class="sig-name descname"><span class="pre">get_base_axis</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.Cube.get_base_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the spectral axis (in cm-1) at the center of the cube</p>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.Cube.get_uncalibrated_filter_bandpass">
<code class="sig-name descname"><span class="pre">get_uncalibrated_filter_bandpass</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.Cube.get_uncalibrated_filter_bandpass" title="Permalink to this definition">¶</a></dt>
<dd><p>Return filter bandpass as two 2d matrices (min, max) in pixels</p>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.Cube.integrate">
<code class="sig-name descname"><span class="pre">integrate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filter_function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xmin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xmax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ymin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ymax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">split</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mean</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">square_filter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.Cube.integrate" title="Permalink to this definition">¶</a></dt>
<dd><p>Integrate a cube under a filter function and generate an image</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filter_function</strong> – Must be an orb.core.Cm1Vector1d
instance or the name of a filter registered in orb/data/</p></li>
<li><p><strong>xmin</strong> – (Optional) lower boundary of the ROI along x axis (default
None, i.e. min)</p></li>
<li><p><strong>xmax</strong> – (Optional) lower boundary of the ROI along y axis (default
None, i.e. min)</p></li>
<li><p><strong>ymin</strong> – (Optional) upper boundary of the ROI along x axis (default
None, i.e. max)</p></li>
<li><p><strong>ymax</strong> – (Optional) upper boundary of the ROI along y axis (default None, i.e. max)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="orb.cube.Cube.needed_params">
<code class="sig-name descname"><span class="pre">needed_params</span></code><em class="property"> <span class="pre">=</span> <span class="pre">('step',</span> <span class="pre">'order',</span> <span class="pre">'filter_name',</span> <span class="pre">'exposure_time',</span> <span class="pre">'step_nb',</span> <span class="pre">'zpd_index')</span></em><a class="headerlink" href="#orb.cube.Cube.needed_params" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="orb.cube.Cube.validate">
<code class="sig-name descname"><span class="pre">validate</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.Cube.validate" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if this class is valid</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="orb.cube.FDCube">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">orb.cube.</span></code><code class="sig-name descname"><span class="pre">FDCube</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image_list_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">image_mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'classic'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">chip_index</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">no_sort</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">silent_init</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.FDCube" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#orb.core.Tools" title="orb.core.Tools"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.core.Tools</span></code></a></p>
<p>Basic handling class for a set of frames grouped into one virtual
cube.</p>
<p>This is a basic class which is mainly used to export data into an
hdf5 cube.</p>
<dl class="py method">
<dt id="orb.cube.FDCube.export">
<code class="sig-name descname"><span class="pre">export</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">export_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.FDCube.export" title="Permalink to this definition">¶</a></dt>
<dd><p>Export FDCube as an hdf5 cube</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>export_path</strong> – Export path</p></li>
<li><p><strong>mask</strong> – (Optional) A boolean array of shape (self.dimx,
self.dimy) which zeros indicates bad pixels to be replaced
with Nans when reading data (default None).</p></li>
<li><p><strong>params</strong> – (Optional) A dict of parameters that will be
added to the exported cube.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.FDCube.get_cube_header">
<code class="sig-name descname"><span class="pre">get_cube_header</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.FDCube.get_cube_header" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the header of a cube from the header of the first frame
by keeping only the general keywords.</p>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.FDCube.get_frame_header">
<code class="sig-name descname"><span class="pre">get_frame_header</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.FDCube.get_frame_header" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the header of a frame given its index in the list.</p>
<p>The header is returned as an instance of pyfits.Header().</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>index</strong> – Index of the frame</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Please refer to
<a class="reference external" href="http://www.stsci.edu/institute/software_hardware/pyfits/">http://www.stsci.edu/institute/software_hardware/pyfits/</a> for
more information on PyFITS module and
<a class="reference external" href="http://fits.gsfc.nasa.gov/">http://fits.gsfc.nasa.gov/</a> for more information on FITS
files.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="orb.cube.HDFCube">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">orb.cube.</span></code><code class="sig-name descname"><span class="pre">HDFCube</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indexer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instrument</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">config</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_prefix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'./'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.HDFCube" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#orb.core.WCSData" title="orb.core.WCSData"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.core.WCSData</span></code></a></p>
<p>This class implements the use of an HDF5 cube.</p>
<dl class="py method">
<dt id="orb.cube.HDFCube.compute_sum_image">
<code class="sig-name descname"><span class="pre">compute_sum_image</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">step_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.HDFCube.compute_sum_image" title="Permalink to this definition">¶</a></dt>
<dd><p>compute the sum along z axis</p>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.HDFCube.copy">
<code class="sig-name descname"><span class="pre">copy</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.HDFCube.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of the instance</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> – (Optional) can be used to change data</p></li>
<li><p><strong>kwargs</strong> – Addition kwargs (useful to copy child classes
with more kwargs at init)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.HDFCube.crop">
<code class="sig-name descname"><span class="pre">crop</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cy</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.HDFCube.crop" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract a part of the file and write it to a new hdf file</p>
<p>WCS and most datasets will be croped also to try to keep a valid cube</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cx</strong> – X center position</p></li>
<li><p><strong>xy</strong> – Y center position</p></li>
<li><p><strong>size</strong> – Size of the cropped rectangle. A tuple (sz,
sy). Can be single int in which case the cropped data is a
box.</p></li>
</ul>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>size of the returned box is not guaranteed if cx
and cy are on the border of the image.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.HDFCube.detect_fwhm">
<code class="sig-name descname"><span class="pre">detect_fwhm</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">star_list</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.HDFCube.detect_fwhm" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="orb.cube.HDFCube.detect_stars">
<code class="sig-name descname"><span class="pre">detect_stars</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.HDFCube.detect_stars" title="Permalink to this definition">¶</a></dt>
<dd><p>Detect valid stars in the image</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>kwargs</strong> – orb.image.Image.detect_stars kwargs.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.HDFCube.fit_stars_in_cube">
<code class="sig-name descname"><span class="pre">fit_stars_in_cube</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">star_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">correct_alignment</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alignment_vectors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">add_cube</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.HDFCube.fit_stars_in_cube" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit stars in the cube.</p>
<p>Frames must not be too disaligned. Disalignment can be
corrected as the cube is fitted by setting correct_alignment
option to True.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>2 fitting modes are possible:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="n">Individual</span> <span class="n">fit</span> <span class="n">mode</span> <span class="p">[</span><span class="n">multi_fit</span><span class="o">=</span><span class="kc">False</span><span class="p">]</span>
<span class="o">*</span> <span class="n">Multi</span> <span class="n">fit</span> <span class="n">mode</span> <span class="p">[</span><span class="n">multi_fit</span><span class="o">=</span><span class="kc">True</span><span class="p">]</span>
</pre></div>
</div>
<p>see <code class="xref py py-meth docutils literal notranslate"><span class="pre">astrometry.utils.fit_stars_in_frame()</span></code> for more
information.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>path</strong> – (Optional) path where the results are saved to.</p></li>
<li><p><strong>correct_alignment</strong> – (Optional) If True, the initial star
positions from the star list are corrected by their last
recorded deviation. Useful when the cube is smoothly
disaligned from one frame to the next.</p></li>
<li><p><strong>alignment_vectors</strong> – (Optional) If not None, must be a
tuple of 2 vectors (dx, dy), each one having the same length
as the numebr of frames in the cube. It is used as a guess
for the alignement of the stars.</p></li>
<li><p><strong>add_cube</strong> – (Optional) A tuple [Cube instance,
coeff]. This cube is added to the data before the fit so
that the fitted data is self.data[] + coeff * Cube[].</p></li>
<li><p><strong>kwargs</strong> – (Optional) orb.utils.astrometry.fit_stars_in_frame
kwargs.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.HDFCube.fit_stars_in_frame">
<code class="sig-name descname"><span class="pre">fit_stars_in_frame</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">star_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.HDFCube.fit_stars_in_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit stars in frame</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>star_list</strong> – Path to a list of stars</p></li>
<li><p><strong>index</strong> – frame index</p></li>
<li><p><strong>kwargs</strong> – orb.image.Image.fit_stars kwargs.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.HDFCube.get_airmass">
<code class="sig-name descname"><span class="pre">get_airmass</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.HDFCube.get_airmass" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the airmass</p>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.HDFCube.get_alignment_vectors">
<code class="sig-name descname"><span class="pre">get_alignment_vectors</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">star_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alignment_vectors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.HDFCube.get_alignment_vectors" title="Permalink to this definition">¶</a></dt>
<dd><p>Return alignement vectors</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>star_list</strong> – list of stars</p></li>
<li><p><strong>min_coeff</strong> – The minimum proportion of stars correctly
fitted to assume a good enough calculated disalignment
(default 0.2).</p></li>
<li><p><strong>path</strong> – If not None, fit results are written to this path</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>alignment_vector_x, alignment_vector_y, alignment_error</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.HDFCube.get_all_data">
<code class="sig-name descname"><span class="pre">get_all_data</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.HDFCube.get_all_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the whole data cube</p>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.HDFCube.get_axis">
<code class="sig-name descname"><span class="pre">get_axis</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.HDFCube.get_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the axis at x, y</p>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.HDFCube.get_binned_cube">
<code class="sig-name descname"><span class="pre">get_binned_cube</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">binning</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.HDFCube.get_binned_cube" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the binned version of the cube</p>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.HDFCube.get_calibration_coeff_map">
<code class="sig-name descname"><span class="pre">get_calibration_coeff_map</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.HDFCube.get_calibration_coeff_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Return calibration laser map</p>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.HDFCube.get_calibration_laser_map">
<code class="sig-name descname"><span class="pre">get_calibration_laser_map</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.HDFCube.get_calibration_laser_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Return calibration laser map</p>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.HDFCube.get_data">
<code class="sig-name descname"><span class="pre">get_data</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x_min</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_max</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_min</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_max</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z_min</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z_max</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">silent</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.HDFCube.get_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a part of the data cube.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x_min</strong> – minimum index along x axis</p></li>
<li><p><strong>x_max</strong> – maximum index along x axis</p></li>
<li><p><strong>y_min</strong> – minimum index along y axis</p></li>
<li><p><strong>y_max</strong> – maximum index along y axis</p></li>
<li><p><strong>z_min</strong> – minimum index along z axis</p></li>
<li><p><strong>z_max</strong> – maximum index along z axis</p></li>
<li><p><strong>silent</strong> – (Optional) deprecated, only here for old cube
architecture (default False).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.HDFCube.get_data_frame">
<code class="sig-name descname"><span class="pre">get_data_frame</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.HDFCube.get_data_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Return one frame of the cube.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>index</strong> – Index of the frame to be returned</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.HDFCube.get_data_from_region">
<code class="sig-name descname"><span class="pre">get_data_from_region</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">region</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.HDFCube.get_data_from_region" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of vectors extracted along the 3rd axis at the pixel
positions defined by a list of pixels.</p>
<p>Return also a list of corresponding axes if self.get_axis()
returns something else than None.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>pixels do not have to be contiguous but, as the
quadrant containing all the pixels is extracted primarily to
speed up the process, they should be contained in a field
small enough to avoid filling the RAM (a 400x400 pixels box
is generally a good limit).</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>region</strong> – A ds9-like region file or a list of pixels
having the same format as the list returned by np.nonzero(),
i.e. (x_positions_1d_array, y_positions_1d_array).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.HDFCube.get_dataset">
<code class="sig-name descname"><span class="pre">get_dataset</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">protect</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.HDFCube.get_dataset" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a dataset (but not ‘data’, instead use get_data).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>path</strong> – dataset path</p></li>
<li><p><strong>protect</strong> – (Optional) check if dataset is protected
(default True).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.HDFCube.get_dataset_attrs">
<code class="sig-name descname"><span class="pre">get_dataset_attrs</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.HDFCube.get_dataset_attrs" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the attributes attached to a dataset</p>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.HDFCube.get_datasets">
<code class="sig-name descname"><span class="pre">get_datasets</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.HDFCube.get_datasets" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all datasets contained in the cube</p>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.HDFCube.get_deep_frame">
<code class="sig-name descname"><span class="pre">get_deep_frame</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">recompute</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">compute</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.HDFCube.get_deep_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the deep frame of a cube (in counts, i.e. e- x gain).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>compute</strong> – (Optional) If True, deep frame can be computed
if not already present. If False, raise an exception when
deep frame is not already present (default True).</p></li>
<li><p><strong>recompute</strong> – (Optional) Force deep frame computation
even if it is already present in the cube (default False).</p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>… warning:: deep frame computation should only be done on an</dt><dd><p>interferogram cube. Deep frame computed on a spectral cube
is <em>much</em> more noisy by definition.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In this process NaNs are handled correctly</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.HDFCube.get_detection_frame">
<code class="sig-name descname"><span class="pre">get_detection_frame</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.HDFCube.get_detection_frame" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="orb.cube.HDFCube.get_dxdymaps">
<code class="sig-name descname"><span class="pre">get_dxdymaps</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.HDFCube.get_dxdymaps" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dxdymaps.</p>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.HDFCube.get_frame_header">
<code class="sig-name descname"><span class="pre">get_frame_header</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.HDFCube.get_frame_header" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the header of a frame given its index in the list.</p>
<p>The header is returned as an instance of pyfits.Header().</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>index</strong> – Index of the frame</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.HDFCube.get_gain">
<code class="sig-name descname"><span class="pre">get_gain</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.HDFCube.get_gain" title="Permalink to this definition">¶</a></dt>
<dd><p>Return camera gain value</p>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.HDFCube.get_high_order_phase">
<code class="sig-name descname"><span class="pre">get_high_order_phase</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.HDFCube.get_high_order_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return high order phase.</p>
<p>This is just the config high order phase</p>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.HDFCube.get_level">
<code class="sig-name descname"><span class="pre">get_level</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.HDFCube.get_level" title="Permalink to this definition">¶</a></dt>
<dd><p>Return reduction level of the cube.</p>
<ul class="simple">
<li><p>level 1: old hdf5 architecture, real output, unit in
erg/cm2/s/A, deep frame is the mean of the interferogram cube</p></li>
<li><p>level 2: new hdf5 architecture, real output, unit in
erg/cm2/s/A, deep frame is the sum of the interferogram cube</p></li>
<li><p>level 3: new hdf5 architecture, complex output, unit in
counts, data can be calibrated via flambda parameter :
spectrum <a href="#id1"><span class="problematic" id="id2">*</span></a>= cube.params.flambda / cube.dimz /
cube.exposure_time, deep frame is the sum of the
interferogram cube</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.HDFCube.get_master_frame">
<code class="sig-name descname"><span class="pre">get_master_frame</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">combine</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reject</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.HDFCube.get_master_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Combine frames along z to create a master frame.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reject</strong> – (Optional) Rejection operation for master
frames creation. Can be ‘sigclip’, ‘minmax’, ‘avsigclip’ or
None (default ‘avsigclip’). See
<a class="reference internal" href="orb.utils.html#orb.utils.image.create_master_frame" title="orb.utils.image.create_master_frame"><code class="xref py py-meth docutils literal notranslate"><span class="pre">orb.utils.image.create_master_frame()</span></code></a>.</p></li>
<li><p><strong>combine</strong> – (Optional) Combining operation for master
frames creation. Can be ‘average’ or ‘median’ (default
‘average’). See
<a class="reference internal" href="orb.utils.html#orb.utils.image.create_master_frame" title="orb.utils.image.create_master_frame"><code class="xref py py-meth docutils literal notranslate"><span class="pre">orb.utils.image.create_master_frame()</span></code></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.HDFCube.get_phase_maps">
<code class="sig-name descname"><span class="pre">get_phase_maps</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.HDFCube.get_phase_maps" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a PhaseMaps instance if phase maps are set</p>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.HDFCube.get_quadrant_dims">
<code class="sig-name descname"><span class="pre">get_quadrant_dims</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">quad_number</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">div_nb</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.HDFCube.get_quadrant_dims" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the indices of a quadrant along x and y axes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>quad_number</strong> – Quadrant number</p></li>
<li><p><strong>div_nb</strong> – (Optional) Use another number of divisions
along x and y axes. (e.g. if div_nb = 3, the number of
quadrant is 9 ; if div_nb = 4, the number of quadrant is 16)</p></li>
<li><p><strong>dimx</strong> – (Optional) Use another x axis dimension. Other
than the axis dimension of the managed data cube</p></li>
<li><p><strong>dimy</strong> – (Optional) Use another y axis dimension. Other
than the axis dimension of the managed data cube</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.HDFCube.get_raw_alignement_vectors">
<code class="sig-name descname"><span class="pre">get_raw_alignement_vectors</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">star_number</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">60</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">searched_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">80</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.HDFCube.get_raw_alignement_vectors" title="Permalink to this definition">¶</a></dt>
<dd><p>Return raw alignment vectors based on brute force.</p>
<p>Slow but useful when alignment between frames is very bad.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>dx, dy vectors</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.HDFCube.get_region">
<code class="sig-name descname"><span class="pre">get_region</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">region</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">integrate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.HDFCube.get_region" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of valid pixels from a ds9 region file or a ds9-style
region definition</p>
<dl class="simple">
<dt>e.g. for a circle defined in celestial coordinates:</dt><dd><p>“fk5;circle(290.96388,14.019167,843.31194”)”</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>region</strong> – a ds9 region file path or a ds9-style
region definition as a string.</p></li>
<li><p><strong>integrate</strong> – Used when multiple regions are defined. If
True, all regions are integrated. If False, a list of
individual regions is returned.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.HDFCube.get_resized_data">
<code class="sig-name descname"><span class="pre">get_resized_data</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size_y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.HDFCube.get_resized_data" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Resize the data cube and return it using spline</dt><dd><p>interpolation.</p>
</dd>
</dl>
<p>This function is used only to resize a cube of flat or dark
frames. Note that resizing dark or flat frames must be
avoided.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>size_x</strong> – New size of the cube along x axis</p></li>
<li><p><strong>size_y</strong> – New size of the cube along y axis</p></li>
</ul>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This function must not be used to resize images
containing star-like objects (a linear interpolation must
be done in this case).</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.HDFCube.get_theta_map">
<code class="sig-name descname"><span class="pre">get_theta_map</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.HDFCube.get_theta_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the incident angle map from the calibration laser map</p>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.HDFCube.get_zvector">
<code class="sig-name descname"><span class="pre">get_zvector</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_region</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">median</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.HDFCube.get_zvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an orb.fft.Vector1d instance taken at a given position in x, y.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> – x position</p></li>
<li><p><strong>y</strong> – y position</p></li>
<li><p><strong>r</strong> – (Optional) If r &gt; 0, vector is integrated over a
circular aperture of radius r. In this case the number of
pixels is returned as a parameter: pixels</p></li>
<li><p><strong>median</strong> – If True, a median is used instead of a mean to
combine vectors. As the resulting vector is integrated,
the median value of the combined spectra is then scaled to
the number of integrated pixels.</p></li>
<li><p><strong>return_region</strong> – (Optional) If True, region is returned
also (default False)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.HDFCube.get_zvector_from_region">
<code class="sig-name descname"><span class="pre">get_zvector_from_region</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">region</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">median</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.HDFCube.get_zvector_from_region" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an orb.fft.Vector1d instance integrated over a given region</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>region</strong> – A ds9-like region file or a list of pixels
having the same format as the list returned by np.nonzero(),
i.e. (x_positions_1d_array, y_positions_1d_array).</p></li>
<li><p><strong>median</strong> – If True, a median is used instead of a mean to
combine vectors. As the resulting vector is integrated,
the median value of the combined spectra is then scaled to
the number of integrated pixels.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.HDFCube.has_dataset">
<code class="sig-name descname"><span class="pre">has_dataset</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.HDFCube.has_dataset" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if a dataset is present</p>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.HDFCube.has_same_2D_size">
<code class="sig-name descname"><span class="pre">has_same_2D_size</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cube_test</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.HDFCube.has_same_2D_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if another cube has the same dimensions along x and y
axes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>cube_test</strong> – Cube to check</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.HDFCube.is_level1">
<code class="sig-name descname"><span class="pre">is_level1</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.HDFCube.is_level1" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if cube is level 1</p>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.HDFCube.is_level2">
<code class="sig-name descname"><span class="pre">is_level2</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.HDFCube.is_level2" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if cube is level 2</p>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.HDFCube.is_level3">
<code class="sig-name descname"><span class="pre">is_level3</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.HDFCube.is_level3" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if cube is level 3</p>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.HDFCube.open_hdf5">
<code class="sig-name descname"><span class="pre">open_hdf5</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'r'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.HDFCube.open_hdf5" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a handle on the hdf5 file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>mode</strong> – opening mode. can be ‘r’ or ‘a’.</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="orb.cube.HDFCube.optional_params">
<code class="sig-name descname"><span class="pre">optional_params</span></code><em class="property"> <span class="pre">=</span> <span class="pre">('target_ra',</span> <span class="pre">'target_dec',</span> <span class="pre">'target_x',</span> <span class="pre">'target_y',</span> <span class="pre">'dark_time',</span> <span class="pre">'flat_time',</span> <span class="pre">'camera',</span> <span class="pre">'wcs_rotation',</span> <span class="pre">'calibration_laser_map_path')</span></em><a class="headerlink" href="#orb.cube.HDFCube.optional_params" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="orb.cube.HDFCube.protected_datasets">
<code class="sig-name descname"><span class="pre">protected_datasets</span></code><em class="property"> <span class="pre">=</span> <span class="pre">('data',</span> <span class="pre">'mask',</span> <span class="pre">'header',</span> <span class="pre">'deep_frame',</span> <span class="pre">'params',</span> <span class="pre">'axis',</span> <span class="pre">'calib_map',</span> <span class="pre">'phase_map',</span> <span class="pre">'phase_map_err',</span> <span class="pre">'phase_maps_coeff_map',</span> <span class="pre">'phase_maps_cm1_axis',</span> <span class="pre">'standard_image',</span> <span class="pre">'standard_spectrum')</span></em><a class="headerlink" href="#orb.cube.HDFCube.protected_datasets" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="orb.cube.HDFCube.to_fits">
<code class="sig-name descname"><span class="pre">to_fits</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.HDFCube.to_fits" title="Permalink to this definition">¶</a></dt>
<dd><p>write data to a FITS file.</p>
<p>Note that most of the information will be lost in the
process. The only output guaranteed format is hdf5 (usr
writeto() method instead)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>path</strong> – Path to the FITS file</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.HDFCube.validate_x_index">
<code class="sig-name descname"><span class="pre">validate_x_index</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.HDFCube.validate_x_index" title="Permalink to this definition">¶</a></dt>
<dd><p>validate an x index, return an integer inside the boundaries or
raise an exception if it is off boundaries</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> – x index</p></li>
<li><p><strong>clip</strong> – (Optional) If True return an index inside the
boundaries, else: raise an exception (default True).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.HDFCube.validate_y_index">
<code class="sig-name descname"><span class="pre">validate_y_index</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.HDFCube.validate_y_index" title="Permalink to this definition">¶</a></dt>
<dd><p>validate an y index, return an integer inside the boundaries or
raise an exception if it is off boundaries</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>y</strong> – y index (can be an array or a list of indexes)</p></li>
<li><p><strong>clip</strong> – (Optional) If True return an index inside the
boundaries, else: raise an exception (default True).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.HDFCube.writeto">
<code class="sig-name descname"><span class="pre">writeto</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">div_nb</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.HDFCube.writeto" title="Permalink to this definition">¶</a></dt>
<dd><p>Write data to an hdf file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>path</strong> – hdf file path.</p></li>
<li><p><strong>div_nb</strong> – cube is extracted by quadrant to avoid feeling
the RAM. In case of memory error just use a higher number of
divisions.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="orb.cube.InterferogramCube">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">orb.cube.</span></code><code class="sig-name descname"><span class="pre">InterferogramCube</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instrument</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.InterferogramCube" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#orb.cube.Cube" title="orb.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.cube.Cube</span></code></a></p>
<p>Provide additional methods for an interferogram cube when
observation parameters are known.</p>
<dl class="py method">
<dt id="orb.cube.InterferogramCube.get_interferogram">
<code class="sig-name descname"><span class="pre">get_interferogram</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">median</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.InterferogramCube.get_interferogram" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an orb.fft.Interferogram instance.</p>
<p>See Cube.get_zvector for the parameters.</p>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.InterferogramCube.get_mean_interferogram">
<code class="sig-name descname"><span class="pre">get_mean_interferogram</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xmin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xmax</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ymin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ymax</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.InterferogramCube.get_mean_interferogram" title="Permalink to this definition">¶</a></dt>
<dd><p>Return mean interferogram in a box [xmin:xmax, ymin:ymax, :]
along z axis</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xmin</strong> – min boundary along x axis</p></li>
<li><p><strong>xmax</strong> – max boundary along x axis</p></li>
<li><p><strong>ymin</strong> – min boundary along y axis</p></li>
<li><p><strong>ymax</strong> – max boundary along y axis</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.InterferogramCube.get_phase">
<code class="sig-name descname"><span class="pre">get_phase</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.InterferogramCube.get_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>If phase maps are set, return the phase at x, y</p>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.InterferogramCube.get_spectrum">
<code class="sig-name descname"><span class="pre">get_spectrum</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.InterferogramCube.get_spectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an orb.fft.Spectrum instance.</p>
<p>phase_maps must be set to get a reliable spectrum</p>
<p>See Cube.get_zvector for the parameters.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="orb.cube.MockArray">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">orb.cube.</span></code><code class="sig-name descname"><span class="pre">MockArray</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.MockArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
</dd></dl>

<dl class="py class">
<dt id="orb.cube.RWHDFCube">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">orb.cube.</span></code><code class="sig-name descname"><span class="pre">RWHDFCube</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">path</span></em>, <em class="sig-param"><span class="pre">shape=None</span></em>, <em class="sig-param"><span class="pre">instrument=None</span></em>, <em class="sig-param"><span class="pre">reset=False</span></em>, <em class="sig-param"><span class="pre">dtype=&lt;class</span> <span class="pre">'numpy.float32'&gt;</span></em>, <em class="sig-param"><span class="pre">**kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.RWHDFCube" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#orb.cube.HDFCube" title="orb.cube.HDFCube"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.cube.HDFCube</span></code></a></p>
<dl class="py method">
<dt id="orb.cube.RWHDFCube.set_calibration_laser_map">
<code class="sig-name descname"><span class="pre">set_calibration_laser_map</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">calib_map</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.RWHDFCube.set_calibration_laser_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Set calibration map.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>calib_map</strong> – Calibration map</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.RWHDFCube.set_dataset">
<code class="sig-name descname"><span class="pre">set_dataset</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">protect</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.RWHDFCube.set_dataset" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a dataset to the hdf5 file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>path</strong> – dataset path</p></li>
<li><p><strong>data</strong> – data to write.</p></li>
<li><p><strong>protect</strong> – (Optional) check if dataset is protected
(default True).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.RWHDFCube.set_deep_frame">
<code class="sig-name descname"><span class="pre">set_deep_frame</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">deep_frame</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.RWHDFCube.set_deep_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Append a deep frame to the HDF5 cube.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>deep_frame</strong> – Deep frame to append.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.RWHDFCube.set_dxdymaps">
<code class="sig-name descname"><span class="pre">set_dxdymaps</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dxmap</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dymap</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.RWHDFCube.set_dxdymaps" title="Permalink to this definition">¶</a></dt>
<dd><p>Set dxdymaps</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dxmap</strong> – dxmap</p></li>
<li><p><strong>dymap</strong> – dymap</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.RWHDFCube.set_frame_header">
<code class="sig-name descname"><span class="pre">set_frame_header</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">header</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.RWHDFCube.set_frame_header" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the header of a frame.</p>
<p>The header must be an instance of pyfits.Header().</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>index</strong> – Index of the frame</p></li>
<li><p><strong>header</strong> – Header as a pyfits.Header instance.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.RWHDFCube.set_mask">
<code class="sig-name descname"><span class="pre">set_mask</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.RWHDFCube.set_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Set mask</p>
<p>A mask must have the shape of the data but for 3d data which
has a 2d mask (self.dimx, self.dimy). A Zero indicates a pixel
which should be masked (Nans are returned for this pixel).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>data</strong> – mask. Must be a boolean array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.RWHDFCube.set_param">
<code class="sig-name descname"><span class="pre">set_param</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.RWHDFCube.set_param" title="Permalink to this definition">¶</a></dt>
<dd><p>Set class parameter</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>key</strong> – parameter key</p></li>
<li><p><strong>value</strong> – parameter value</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.RWHDFCube.set_params">
<code class="sig-name descname"><span class="pre">set_params</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.RWHDFCube.set_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Set class parameters</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>params</strong> – a dict of parameters</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.RWHDFCube.set_phase_maps">
<code class="sig-name descname"><span class="pre">set_phase_maps</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">phase_maps</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.RWHDFCube.set_phase_maps" title="Permalink to this definition">¶</a></dt>
<dd><p>Set phase maps from a PhaseMaps instance</p>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.RWHDFCube.set_standard_image">
<code class="sig-name descname"><span class="pre">set_standard_image</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">std_im</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.RWHDFCube.set_standard_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Set standard image</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>std_im</strong> – An image.Image instance or a path to an
hdf5 image.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.RWHDFCube.set_standard_spectrum">
<code class="sig-name descname"><span class="pre">set_standard_spectrum</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">std_sp</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.RWHDFCube.set_standard_spectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Set standard spectrum</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>std_sp</strong> – a orb.photometry.StandardSpectrum instance or a
path to an hdf5 spectrum.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.RWHDFCube.write_frame">
<code class="sig-name descname"><span class="pre">write_frame</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">header</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">section</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">record_stats</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.RWHDFCube.write_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a frame.</p>
<p>This function is here for backward compatibility but a simple
self[:,:,index] may be used instead.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>index</strong> – Index of the frame</p></li>
<li><p><strong>data</strong> – (Optional) Frame data (default None).</p></li>
<li><p><strong>header</strong> – (Optional) Frame header (default None).</p></li>
<li><p><strong>section</strong> – (Optional) If not None, must be a 4-tuple
[xmin, xmax, ymin, ymax] giving the section to write instead
of the whole frame. Useful to modify only a part of the
frame (default None).</p></li>
<li><p><strong>record_stats</strong> – (Optional) If True, frame stats are
recorder in its header (default False).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="orb.cube.SpectralCube">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">orb.cube.</span></code><code class="sig-name descname"><span class="pre">SpectralCube</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.SpectralCube" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#orb.cube.Cube" title="orb.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.cube.Cube</span></code></a></p>
<p>Provide additional methods for a spectral cube when observation
parameters are known.</p>
<dl class="py method">
<dt id="orb.cube.SpectralCube.compute_flambda">
<code class="sig-name descname"><span class="pre">compute_flambda</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">deg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">std_im</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">std_sp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.SpectralCube.compute_flambda" title="Permalink to this definition">¶</a></dt>
<dd><p>Return flamba calibration function</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>deg</strong> – Degree of the polynomial used to fit the flux
correction vector (this is only used if std_sp is set to a
standard spectrum.)</p></li>
<li><p><strong>std_im</strong> – Standard image used to correct the absolute calibration.</p></li>
<li><p><strong>std_sp</strong> – Standard spectrum used to compute the
wavelength dependant flux calibration.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.SpectralCube.compute_modulation_ratio">
<code class="sig-name descname"><span class="pre">compute_modulation_ratio</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.SpectralCube.compute_modulation_ratio" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="orb.cube.SpectralCube.get_axis">
<code class="sig-name descname"><span class="pre">get_axis</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.SpectralCube.get_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the spectral axis at x, y</p>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.SpectralCube.get_calibration_coeff_map">
<code class="sig-name descname"><span class="pre">get_calibration_coeff_map</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.SpectralCube.get_calibration_coeff_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the calibration coeff map based on the calibration
laser map and the laser wavelength.</p>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.SpectralCube.get_calibration_coeff_map_orig">
<code class="sig-name descname"><span class="pre">get_calibration_coeff_map_orig</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.SpectralCube.get_calibration_coeff_map_orig" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the original calibration coeff map (not the version
computed by <a class="reference internal" href="#orb.cube.HDFCube.get_calibration_coeff_map" title="orb.cube.HDFCube.get_calibration_coeff_map"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_calibration_coeff_map()</span></code></a>)</p>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.SpectralCube.get_calibration_laser_map">
<code class="sig-name descname"><span class="pre">get_calibration_laser_map</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.SpectralCube.get_calibration_laser_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the calibration laser map of the cube</p>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.SpectralCube.get_calibration_laser_map_orig">
<code class="sig-name descname"><span class="pre">get_calibration_laser_map_orig</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.SpectralCube.get_calibration_laser_map_orig" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the original calibration laser map (not the version
computed by <a class="reference internal" href="#orb.cube.HDFCube.get_calibration_laser_map" title="orb.cube.HDFCube.get_calibration_laser_map"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_calibration_laser_map()</span></code></a>)</p>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.SpectralCube.get_deep_frame">
<code class="sig-name descname"><span class="pre">get_deep_frame</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">recompute</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">compute</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.SpectralCube.get_deep_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the deep frame of a cube (in counts, i.e. e- x gain).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>compute</strong> – (Optional) If True, deep frame can be computed
if not already present. If False, raise an exception when
deep frame is not already present (default True).</p></li>
<li><p><strong>recompute</strong> – (Optional) Force deep frame computation
even if it is already present in the cube (default False).</p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>… warning:: deep frame computation should only be done on an</dt><dd><p>interferogram cube. Deep frame computed on a spectral cube
is <em>much</em> more noisy by definition.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In this process NaNs are handled correctly</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.SpectralCube.get_filter_range">
<code class="sig-name descname"><span class="pre">get_filter_range</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.SpectralCube.get_filter_range" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the range of the filter in the unit of the spectral
cube as a tuple (min, max)</p>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.SpectralCube.get_filter_range_pix">
<code class="sig-name descname"><span class="pre">get_filter_range_pix</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">border_ratio</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.SpectralCube.get_filter_range_pix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the range of the filter in channel index as a tuple
(min, max)</p>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.SpectralCube.get_fwhm_map">
<code class="sig-name descname"><span class="pre">get_fwhm_map</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.SpectralCube.get_fwhm_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the theoretical FWHM map in cm-1 based only on the angle
and the theoretical attained resolution.</p>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.SpectralCube.get_mask_from_ds9_region_file">
<code class="sig-name descname"><span class="pre">get_mask_from_ds9_region_file</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">region</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">integrate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.SpectralCube.get_mask_from_ds9_region_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a mask from a ds9 region file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>region</strong> – Path to a ds9 region file.</p></li>
<li><p><strong>integrate</strong> – (Optional) If True, all pixels are integrated
into one mask, else a list of region masks is returned (default
True)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.SpectralCube.get_sky_lines">
<code class="sig-name descname"><span class="pre">get_sky_lines</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.SpectralCube.get_sky_lines" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the wavenumber of the sky lines in the
filter range</p>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.SpectralCube.get_sky_velocity_map">
<code class="sig-name descname"><span class="pre">get_sky_velocity_map</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.SpectralCube.get_sky_velocity_map" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="orb.cube.SpectralCube.get_spectrum">
<code class="sig-name descname"><span class="pre">get_spectrum</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">median</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mean_flux</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.SpectralCube.get_spectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a orb.fft.RealSpectrum extracted at x, y and integrated
over a circular aperture or radius r.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> – x position</p></li>
<li><p><strong>y</strong> – y position</p></li>
<li><p><strong>r</strong> – (Optional) If r &gt; 0, vector is integrated over a
circular aperture of radius r. In this case the number of
pixels is returned as a parameter: pixels</p></li>
<li><p><strong>median</strong> – If True, a median is used instead of a mean to
combine spectra. As the resulting spectrum is integrated,
the median value of the combined spectra is then scaled to
the number of integrated pixels.</p></li>
<li><p><strong>mean_flux</strong> – If True, the mean spectrum (ie per pixel
flux) is returned.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.SpectralCube.get_spectrum_bin">
<code class="sig-name descname"><span class="pre">get_spectrum_bin</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">median</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mean_flux</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.SpectralCube.get_spectrum_bin" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a spectrum integrated over a binned region.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> – X position of the bottom-left pixel</p></li>
<li><p><strong>y</strong> – Y position of the bottom-left pixel</p></li>
<li><p><strong>b</strong> – Binning. If 1, only the central pixel is extracted</p></li>
<li><p><strong>median</strong> – If True, a median is used instead of a mean to
combine spectra. As the resulting spectrum is integrated,
the median value of the combined spectra is then scaled to
the number of integrated pixels.</p></li>
<li><p><strong>mean_flux</strong> – If True, the mean spectrum (ie per pixel
flux) is returned.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>(axis, spectrum)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.SpectralCube.get_spectrum_from_region">
<code class="sig-name descname"><span class="pre">get_spectrum_from_region</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">region</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">median</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mean_flux</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.SpectralCube.get_spectrum_from_region" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the integrated spectrum of a given region.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>region</strong> – A ds9-like region file or a list of pixels
having the same format as the list returned by np.nonzero(),
i.e. (x_positions_1d_array, y_positions_1d_array).</p></li>
<li><p><strong>median</strong> – If True, a median is used instead of a mean to
combine spectra. As the resulting spectrum is integrated,
the median value of the combined spectra is then scaled to
the number of integrated pixels.</p></li>
<li><p><strong>mean_flux</strong> – If True, the mean spectrum (ie per pixel
flux) is returned.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>the region must not have a size greater than 400x400
pixels. If you really need a larger region, you can split
you region into smaller ones and combine the resulting
spectra.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.SpectralCube.get_spectrum_in_annulus">
<code class="sig-name descname"><span class="pre">get_spectrum_in_annulus</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rmin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rmax</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">median</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mean_flux</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.SpectralCube.get_spectrum_in_annulus" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a. orb.fft.RealSpectrum extracted at x, y and integrated
over a circular annulus of min radius rmin and max radius rmax.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> – x position</p></li>
<li><p><strong>y</strong> – y position</p></li>
<li><p><strong>rmin</strong> – rmin of the annulus</p></li>
<li><p><strong>rmax</strong> – rmax of the annulus</p></li>
<li><p><strong>median</strong> – If True, a median is used instead of a mean to
combine spectra. As the resulting spectrum is integrated,
the median value of the combined spectra is then scaled to
the number of integrated pixels.</p></li>
<li><p><strong>mean_flux</strong> – If True, the mean spectrum (ie per pixel
flux) is returned.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.SpectralCube.get_standard_image">
<code class="sig-name descname"><span class="pre">get_standard_image</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.SpectralCube.get_standard_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Return standard image</p>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.SpectralCube.get_standard_spectrum">
<code class="sig-name descname"><span class="pre">get_standard_spectrum</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.SpectralCube.get_standard_spectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Return standard spectrum</p>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.SpectralCube.get_theta_map">
<code class="sig-name descname"><span class="pre">get_theta_map</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.SpectralCube.get_theta_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the incident angle map (in degree)</p>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.SpectralCube.has_flux_calibration">
<code class="sig-name descname"><span class="pre">has_flux_calibration</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.SpectralCube.has_flux_calibration" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the cube is calibrated in flux</p>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.SpectralCube.has_wavenumber_calibration">
<code class="sig-name descname"><span class="pre">has_wavenumber_calibration</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.SpectralCube.has_wavenumber_calibration" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the cube is calibrated in wavenumber</p>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.SpectralCube.has_wcs_calibration">
<code class="sig-name descname"><span class="pre">has_wcs_calibration</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.SpectralCube.has_wcs_calibration" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the cube has valid wcs</p>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.SpectralCube.reset_calibration_coeff_map">
<code class="sig-name descname"><span class="pre">reset_calibration_coeff_map</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.SpectralCube.reset_calibration_coeff_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset the computed calibration coeff map alone</p>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.SpectralCube.reset_calibration_laser_map">
<code class="sig-name descname"><span class="pre">reset_calibration_laser_map</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.SpectralCube.reset_calibration_laser_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset the compute calibration laser map (and also the
calibration coeff map). Must be called when the wavenumber
calibration has changed</p>
<p>..seealso :: <code class="xref py py-meth docutils literal notranslate"><span class="pre">correct_wavelength()</span></code></p>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.SpectralCube.reset_params">
<code class="sig-name descname"><span class="pre">reset_params</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.SpectralCube.reset_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset parameters</p>
</dd></dl>

<dl class="py method">
<dt id="orb.cube.SpectralCube.set_flambda">
<code class="sig-name descname"><span class="pre">set_flambda</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">flambda</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cube.SpectralCube.set_flambda" title="Permalink to this definition">¶</a></dt>
<dd><p>Set flux calibration.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>flambda</strong> – must be core.Cm1Vector1d instance.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-orb.cutils">
<span id="orb-cutils-module"></span><h2>orb.cutils module<a class="headerlink" href="#module-orb.cutils" title="Permalink to this headline">¶</a></h2>
<p>CUtils is a set of C functions coded in <a class="reference external" href="http://cython.org/">Cython</a> to improve their speed.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This file must be compiled before it can be used:</p>
<p>cython cutils.pyx</p>
<p>gcc -c -fPIC -I/usr/include/python2.7 cutils.c</p>
<p>gcc -shared cutils.o -o cutils.so</p>
</div>
<dl class="py function">
<dt id="orb.cutils.brute_photometry">
<code class="sig-prename descclassname"><span class="pre">orb.cutils.</span></code><code class="sig-name descname"><span class="pre">brute_photometry</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ndarray</span> <span class="pre">im</span></em>, <em class="sig-param"><span class="pre">ndarray</span> <span class="pre">star_list</span></em>, <em class="sig-param"><span class="pre">ndarray</span> <span class="pre">kernel</span></em>, <em class="sig-param"><span class="pre">int</span> <span class="pre">box_size</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.brute_photometry" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="orb.cutils.check_cosmic_rays_neighbourhood">
<code class="sig-prename descclassname"><span class="pre">orb.cutils.</span></code><code class="sig-name descname"><span class="pre">check_cosmic_rays_neighbourhood</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ndarray</span> <span class="pre">frame</span></em>, <em class="sig-param"><span class="pre">ndarray</span> <span class="pre">cr_map</span></em>, <em class="sig-param"><span class="pre">int</span> <span class="pre">box_size</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">detect_coeff</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.check_cosmic_rays_neighbourhood" title="Permalink to this definition">¶</a></dt>
<dd><p>Check the neighbourhood around detected cosmic rays in a frame.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>frame</strong> – Frame to check</p></li>
<li><p><strong>cr_map</strong> – Map of the cosimic-rays positions (boolean map, 1
is a cosmic ray)</p></li>
<li><p><strong>box_size</strong> – Size of the box checked around each cr.</p></li>
<li><p><strong>detect_coeff</strong> – Coefficient of detection (number of sigmas
threshold)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.cutils.complex_dft">
<code class="sig-prename descclassname"><span class="pre">orb.cutils.</span></code><code class="sig-name descname"><span class="pre">complex_dft</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ndarray</span> <span class="pre">a</span></em>, <em class="sig-param"><span class="pre">ndarray</span> <span class="pre">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.complex_dft" title="Permalink to this definition">¶</a></dt>
<dd><p>Discret Fourier Transform.</p>
<p>Compute an irregularly sampled spectrum from a complex regularly
sampled interferogram.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> – complex regularly sampled interferogram.</p></li>
<li><p><strong>x</strong> – positions of the spectrum samples. If x =
range(size(a)), this function is equivalent to an fft. Note that
the fft is of course much faster to compute. This vector may
have any length.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.cutils.create_transform_maps">
<code class="sig-prename descclassname"><span class="pre">orb.cutils.</span></code><code class="sig-name descname"><span class="pre">create_transform_maps</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">int</span> <span class="pre">nx</span></em>, <em class="sig-param"><span class="pre">int</span> <span class="pre">ny</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">dx</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">dy</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">dr</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">da</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">db</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">xrc</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">yrc</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">zx</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">zy</span></em>, <em class="sig-param"><span class="pre">sip_A</span></em>, <em class="sig-param"><span class="pre">sip_B</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.create_transform_maps" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the 2 transformation maps used to compute the
geometrical transformation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nx</strong> – size of the frame along x axis</p></li>
<li><p><strong>ny</strong> – size of the frame along y axis</p></li>
<li><p><strong>dx</strong> – translation along x</p></li>
<li><p><strong>dy</strong> – translation along y</p></li>
<li><p><strong>dr</strong> – rotation in the plane of the image</p></li>
<li><p><strong>da</strong> – tip angle</p></li>
<li><p><strong>db</strong> – tilt angle</p></li>
<li><p><strong>xrc</strong> – x coordinate of the rotation center</p></li>
<li><p><strong>yrc</strong> – y coordinate of the rotation center</p></li>
<li><p><strong>zx</strong> – zoom coefficient along x</p></li>
<li><p><strong>zy</strong> – zoom coefficient along y</p></li>
<li><p><strong>sip_A</strong> – pywcs.WCS() instance containing SIP parameters of
the output image.</p></li>
<li><p><strong>sip_B</strong> – pywcs.WCS() instance containing SIP parameters of
the input image.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.cutils.detect_cosmic_rays">
<code class="sig-prename descclassname"><span class="pre">orb.cutils.</span></code><code class="sig-name descname"><span class="pre">detect_cosmic_rays</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ndarray</span> <span class="pre">frame</span></em>, <em class="sig-param"><span class="pre">crs_list</span></em>, <em class="sig-param"><span class="pre">int</span> <span class="pre">box_size</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">detect_coeff</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.detect_cosmic_rays" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if a given pixel is a cosmic ray (classic detection).</p>
<p>classic detection: pixel value is checked against standard
deviation of values in a box around the pixel.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>frame</strong> – Frame to check</p></li>
<li><p><strong>crs_list</strong> – List of pixels to check</p></li>
<li><p><strong>box_size</strong> – Size of the box in pixels</p></li>
<li><p><strong>detect_coeff</strong> – Coefficient of detection (number of sigmas
threshold)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.cutils.dft">
<code class="sig-prename descclassname"><span class="pre">orb.cutils.</span></code><code class="sig-name descname"><span class="pre">dft</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ndarray</span> <span class="pre">a</span></em>, <em class="sig-param"><span class="pre">ndarray</span> <span class="pre">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.dft" title="Permalink to this definition">¶</a></dt>
<dd><p>Discret Fourier Transform.</p>
<p>Compute an irregularly sampled spectrum from a regularly
sampled interferogram.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> – regularly sampled interferogram.</p></li>
<li><p><strong>x</strong> – positions of the spectrum samples. If x =
range(size(a)), this function is equivalent to an fft. Note that
the fft is of course much faster to compute. This vector may
have any length.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.cutils.fast_gaussian_kernel">
<code class="sig-prename descclassname"><span class="pre">orb.cutils.</span></code><code class="sig-name descname"><span class="pre">fast_gaussian_kernel</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">int</span> <span class="pre">deg</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.fast_gaussian_kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a fast gaussian kernel.</p>
<p>The value of each pixel is just the value of the gaussian at the
center of the pixel.</p>
<p>The degree gives the size of the kernel’s side : size = 2 * deg + 1</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>deg</strong> – The degree of the kernel. Must be an integer &gt;= 0.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.cutils.fast_pix2w">
<code class="sig-prename descclassname"><span class="pre">orb.cutils.</span></code><code class="sig-name descname"><span class="pre">fast_pix2w</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ndarray</span> <span class="pre">pix</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">axis_min</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">axis_step</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.fast_pix2w" title="Permalink to this definition">¶</a></dt>
<dd><p>Fast conversion of pixel to wavelength/wavenumber</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pix</strong> – position along axis in pixels</p></li>
<li><p><strong>axis_min</strong> – min axis wavelength/wavenumber</p></li>
<li><p><strong>axis_step</strong> – axis step size in wavelength/wavenumber</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.cutils.fast_w2pix">
<code class="sig-prename descclassname"><span class="pre">orb.cutils.</span></code><code class="sig-name descname"><span class="pre">fast_w2pix</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ndarray</span> <span class="pre">w</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">axis_min</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">axis_step</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.fast_w2pix" title="Permalink to this definition">¶</a></dt>
<dd><p>Fast conversion of wavelength/wavenumber to pixel</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>w</strong> – wavelength/wavenumber</p></li>
<li><p><strong>axis_min</strong> – min axis wavelength/wavenumber</p></li>
<li><p><strong>axis_step</strong> – axis step size in wavelength/wavenumber</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.cutils.fft_filter">
<code class="sig-prename descclassname"><span class="pre">orb.cutils.</span></code><code class="sig-name descname"><span class="pre">fft_filter</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ndarray</span> <span class="pre">a</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">cutoff</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">width</span></em>, <em class="sig-param"><span class="pre">bool</span> <span class="pre">lowpass</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.fft_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Simple lowpass or highpass FFT filter (high pass or low pass)</p>
<p>Filter shape is a gaussian.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> – a 1D float64 vector</p></li>
<li><p><strong>cutoff_coeff</strong> – Coefficient defining the position of the cutoff
frequency (Cutoff frequency = cutoff_coeff * vector length)</p></li>
<li><p><strong>width_coeff</strong> – Coefficient defining the width of
the smoothed part of the filter (width = width_coeff * vector
length)</p></li>
<li><p><strong>lowpass</strong> – If True filter will be ‘low_pass’ and ‘high_pass’
if False.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.cutils.filter_background">
<code class="sig-prename descclassname"><span class="pre">orb.cutils.</span></code><code class="sig-name descname"><span class="pre">filter_background</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ndarray</span> <span class="pre">frame</span></em>, <em class="sig-param"><span class="pre">int</span> <span class="pre">box_size</span></em>, <em class="sig-param"><span class="pre">int</span> <span class="pre">big_box_coeff</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.filter_background" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace each pixel by the value in a box around it minus the
median of the baclground.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>frame</strong> – Frame to filter</p></li>
<li><p><strong>box_size</strong> – Size of the box</p></li>
<li><p><strong>big_box_coeff</strong> – Coeff by which the bo size is multiplied to
get the background box size.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.cutils.gaussian1d">
<code class="sig-prename descclassname"><span class="pre">orb.cutils.</span></code><code class="sig-name descname"><span class="pre">gaussian1d</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ndarray</span> <span class="pre">x</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">h</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">a</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">dx</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">fwhm</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.gaussian1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a 1D gaussian given a set of parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> – 1D array of float64 giving the positions where the
gaussian is evaluated</p></li>
<li><p><strong>h</strong> – Height</p></li>
<li><p><strong>a</strong> – Amplitude</p></li>
<li><p><strong>dx</strong> – Position of the center</p></li>
<li><p><strong>w</strong> – FWHM, <span class="math notranslate nohighlight">\(\text{FWHM} = \text{Width} \times 2 \sqrt{2 \ln 2}\)</span></p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.cutils.gaussian_array2d">
<code class="sig-prename descclassname"><span class="pre">orb.cutils.</span></code><code class="sig-name descname"><span class="pre">gaussian_array2d</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">double</span> <span class="pre">h</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">a</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">dx</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">dy</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">fwhm</span></em>, <em class="sig-param"><span class="pre">int</span> <span class="pre">nx</span></em>, <em class="sig-param"><span class="pre">int</span> <span class="pre">ny</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.gaussian_array2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the 2D profile of a gaussian</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>h</strong> – Height</p></li>
<li><p><strong>a</strong> – Amplitude</p></li>
<li><p><strong>dx</strong> – X position</p></li>
<li><p><strong>dy</strong> – Y position</p></li>
<li><p><strong>fwhm</strong> – FWHM</p></li>
<li><p><strong>nx</strong> – X dimension of the output array</p></li>
<li><p><strong>ny</strong> – Y dimension of the output array</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.cutils.gaussian_kernel">
<code class="sig-prename descclassname"><span class="pre">orb.cutils.</span></code><code class="sig-name descname"><span class="pre">gaussian_kernel</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">double</span> <span class="pre">deg</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.gaussian_kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a gaussian kernel.</p>
<p>The value of each pixel is the integral of the gaussian over the
whole pixel because the shape of the gaussian is not linear at
all. The estimation is done by subdividing each pixel in 9
sub-pixels.</p>
<p>The degree gives the size of the kernel’s side : size = 2 * deg + 1</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>deg</strong> – The degree of the kernel. Must be an integer &gt;= 0.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.cutils.get_box_coords">
<code class="sig-prename descclassname"><span class="pre">orb.cutils.</span></code><code class="sig-name descname"><span class="pre">get_box_coords</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">int</span> <span class="pre">ix</span></em>, <em class="sig-param"><span class="pre">int</span> <span class="pre">iy</span></em>, <em class="sig-param"><span class="pre">int</span> <span class="pre">box_size</span></em>, <em class="sig-param"><span class="pre">int</span> <span class="pre">x_lim_min</span></em>, <em class="sig-param"><span class="pre">int</span> <span class="pre">x_lim_max</span></em>, <em class="sig-param"><span class="pre">int</span> <span class="pre">y_lim_min</span></em>, <em class="sig-param"><span class="pre">int</span> <span class="pre">y_lim_max</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.get_box_coords" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the coordinates of a box given the center of the box,
its size and the limits of the range along x and y axes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ix</strong> – center of the box along x axis</p></li>
<li><p><strong>iy</strong> – center of the box along y axis</p></li>
<li><p><strong>box_size</strong> – Size of the box. The final size of the box will
generally be the same if box_size is odd. Note that the final
size of the box cannot be guaranteed.</p></li>
<li><p><strong>x_lim_min</strong> – Minimum limit of the range along x.</p></li>
<li><p><strong>x_lim_max</strong> – Maximum limit of the range along x.</p></li>
<li><p><strong>y_lim_min</strong> – Minimum limit of the range along y.</p></li>
<li><p><strong>y_lim_max</strong> – Maximum limit of the range along y.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>x_min, x_max, y_min, y_max</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.cutils.get_cm1_axis_max">
<code class="sig-prename descclassname"><span class="pre">orb.cutils.</span></code><code class="sig-name descname"><span class="pre">get_cm1_axis_max</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">int</span> <span class="pre">n</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">step</span></em>, <em class="sig-param"><span class="pre">int</span> <span class="pre">order</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">corr=1.</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.get_cm1_axis_max" title="Permalink to this definition">¶</a></dt>
<dd><p>Return max wavenumber of a regular wavenumber axis in cm-1.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> – Number of steps on the axis</p></li>
<li><p><strong>step</strong> – Step size in nm</p></li>
<li><p><strong>order</strong> – Folding order</p></li>
<li><p><strong>corr</strong> – (Optional) Coefficient of correction (default 1.)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.cutils.get_cm1_axis_min">
<code class="sig-prename descclassname"><span class="pre">orb.cutils.</span></code><code class="sig-name descname"><span class="pre">get_cm1_axis_min</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">int</span> <span class="pre">n</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">step</span></em>, <em class="sig-param"><span class="pre">int</span> <span class="pre">order</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">corr=1.</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.get_cm1_axis_min" title="Permalink to this definition">¶</a></dt>
<dd><p>Return min wavenumber of a regular wavenumber axis in cm-1.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> – Number of steps on the axis</p></li>
<li><p><strong>step</strong> – Step size in nm</p></li>
<li><p><strong>order</strong> – Folding order</p></li>
<li><p><strong>corr</strong> – (Optional) Coefficient of correction (default 1.)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.cutils.get_cm1_axis_step">
<code class="sig-prename descclassname"><span class="pre">orb.cutils.</span></code><code class="sig-name descname"><span class="pre">get_cm1_axis_step</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">int</span> <span class="pre">n</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">step</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">corr=1.</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.get_cm1_axis_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Return step size of a regular wavenumber axis in cm-1.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> – Number of steps on the axis</p></li>
<li><p><strong>step</strong> – Step size in nm</p></li>
<li><p><strong>corr</strong> – (Optional) Coefficient of correction (default 1.)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.cutils.get_nm_axis_max">
<code class="sig-prename descclassname"><span class="pre">orb.cutils.</span></code><code class="sig-name descname"><span class="pre">get_nm_axis_max</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">int</span> <span class="pre">n</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">step</span></em>, <em class="sig-param"><span class="pre">int</span> <span class="pre">order</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">corr=1.</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.get_nm_axis_max" title="Permalink to this definition">¶</a></dt>
<dd><p>Return max wavelength of regular wavelength axis in nm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> – Number of steps on the axis</p></li>
<li><p><strong>step</strong> – Step size in nm</p></li>
<li><p><strong>order</strong> – Folding order (cannot be 0)</p></li>
<li><p><strong>corr</strong> – (Optional) Coefficient of correction (default 1.)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.cutils.get_nm_axis_min">
<code class="sig-prename descclassname"><span class="pre">orb.cutils.</span></code><code class="sig-name descname"><span class="pre">get_nm_axis_min</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">int</span> <span class="pre">n</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">step</span></em>, <em class="sig-param"><span class="pre">int</span> <span class="pre">order</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">corr=1.</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.get_nm_axis_min" title="Permalink to this definition">¶</a></dt>
<dd><p>Return min wavelength of regular wavelength axis in nm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> – Number of steps on the axis</p></li>
<li><p><strong>step</strong> – Step size in nm</p></li>
<li><p><strong>order</strong> – Folding order (cannot be 0)</p></li>
<li><p><strong>corr</strong> – (Optional) Coefficient of correction (default 1.)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.cutils.get_nm_axis_step">
<code class="sig-prename descclassname"><span class="pre">orb.cutils.</span></code><code class="sig-name descname"><span class="pre">get_nm_axis_step</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">int</span> <span class="pre">n</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">step</span></em>, <em class="sig-param"><span class="pre">int</span> <span class="pre">order</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">corr=1.</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.get_nm_axis_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Return step size of a regular wavelength axis in nm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> – Number of steps on the axis</p></li>
<li><p><strong>step</strong> – Step size in nm</p></li>
<li><p><strong>order</strong> – Folding order (cannot be 0)</p></li>
<li><p><strong>corr</strong> – (Optional) Coefficient of correction (default 1.)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.cutils.im2rgba">
<code class="sig-prename descclassname"><span class="pre">orb.cutils.</span></code><code class="sig-name descname"><span class="pre">im2rgba</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ndarray</span> <span class="pre">im</span></em>, <em class="sig-param"><span class="pre">mpl_colorbar</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">vmin</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">vmax</span></em>, <em class="sig-param"><span class="pre">int</span> <span class="pre">xmin</span></em>, <em class="sig-param"><span class="pre">int</span> <span class="pre">xmax</span></em>, <em class="sig-param"><span class="pre">int</span> <span class="pre">ymin</span></em>, <em class="sig-param"><span class="pre">int</span> <span class="pre">ymax</span></em>, <em class="sig-param"><span class="pre">ndarray</span> <span class="pre">computed_pixels</span></em>, <em class="sig-param"><span class="pre">last_arr8</span></em>, <em class="sig-param"><span class="pre">int</span> <span class="pre">res=1000</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.im2rgba" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute RGBA from image given a matplotlib colorbar instance.</p>
<p>This is a function used by <code class="xref py py-class docutils literal notranslate"><span class="pre">orb.visual.ImageCanvas</span></code>. It
is not a generalist function. It has been written to accelerate
matplotlib function colorbar.to_rgba().</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>im</strong> – Image</p></li>
<li><p><strong>mpl_colorbar</strong> – A matplotlib colorbar instance</p></li>
<li><p><strong>vmin</strong> – min value of the colorbar</p></li>
<li><p><strong>vmax</strong> – max value of the colorbar</p></li>
<li><p><strong>xmin</strong> – min x index of the region to compute</p></li>
<li><p><strong>xmax</strong> – max x index of the region to compute</p></li>
<li><p><strong>ymin</strong> – min y index of the region to compute</p></li>
<li><p><strong>ymax</strong> – max y index of the region to compute</p></li>
<li><p><strong>computed_pixels</strong> – Array giving the already computed pixels</p></li>
<li><p><strong>last_arr8</strong> – If not None, last computed array.</p></li>
<li><p><strong>res</strong> – (Optional) Lookup table resolution (default 1000)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.cutils.indft">
<code class="sig-prename descclassname"><span class="pre">orb.cutils.</span></code><code class="sig-name descname"><span class="pre">indft</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ndarray</span> <span class="pre">a</span></em>, <em class="sig-param"><span class="pre">ndarray</span> <span class="pre">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.indft" title="Permalink to this definition">¶</a></dt>
<dd><p>Inverse Non-uniform Discret Fourier Transform.</p>
<p>Compute the irregularly sampled interferogram from a regularly
sampled spectrum.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> – regularly sampled spectrum.</p></li>
<li><p><strong>x</strong> – positions of the interferogram samples. If x =
range(size(a)), this function is equivalent to an idft or a
ifft. Note that the ifft is of course much faster to
compute. This vector may have any length.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.cutils.interf_mean_energy">
<code class="sig-prename descclassname"><span class="pre">orb.cutils.</span></code><code class="sig-name descname"><span class="pre">interf_mean_energy</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ndarray</span> <span class="pre">interf</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.interf_mean_energy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the mean energy of an interferogram by step.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>interf</strong> – an interferogram</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The mean of the interferogram is substracted to
compute only the modulation energy. This is the modulation
energy which must be conserved in the resulting spectrum. Note
that the interferogram transformation function (see
<code class="xref py py-meth docutils literal notranslate"><span class="pre">utils.transform_interferogram()</span></code>) remove the mean of the
interferogram before computing its FFT.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>NaNs are counted as zeros.</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="orb.cutils.low_pass_image_filter">
<code class="sig-prename descclassname"><span class="pre">orb.cutils.</span></code><code class="sig-name descname"><span class="pre">low_pass_image_filter</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ndarray</span> <span class="pre">im</span></em>, <em class="sig-param"><span class="pre">int</span> <span class="pre">deg</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.low_pass_image_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Low pass image filter by convolution with a gaussian kernel.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>im</strong> – Image to filter</p></li>
<li><p><strong>deg</strong> – Kernel degree</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.cutils.map_me">
<code class="sig-prename descclassname"><span class="pre">orb.cutils.</span></code><code class="sig-name descname"><span class="pre">map_me</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ndarray</span> <span class="pre">frame</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.map_me" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a map of the modulation efficiency from a laser frame.</p>
<p>The more fringes the best are the results.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>frame</strong> – laser frame.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.cutils.master_combine">
<code class="sig-prename descclassname"><span class="pre">orb.cutils.</span></code><code class="sig-name descname"><span class="pre">master_combine</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ndarray</span> <span class="pre">frames</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">sigma</span></em>, <em class="sig-param"><span class="pre">int</span> <span class="pre">nkeep</span></em>, <em class="sig-param"><span class="pre">int</span> <span class="pre">combine_mode</span></em>, <em class="sig-param"><span class="pre">int</span> <span class="pre">reject_mode</span></em>, <em class="sig-param"><span class="pre">return_std_frame=False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.master_combine" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a master frame from a set a frames.</p>
<p>This method has been inspired by the <strong>IRAF</strong> function
combine.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>frames</strong> – Frames to be combined.</p></li>
<li><p><strong>sigma</strong> – Sigma factor for pixel rejection.</p></li>
<li><p><strong>nkeep</strong> – Minimum number of values to keep before
combining operation</p></li>
<li><p><strong>combine_mode</strong> – 0, mean ; 1, median.</p></li>
<li><p><strong>reject_mode</strong> – 0, avsigclip ; 1, sigclip ; 2, minmax.</p></li>
<li><p><strong>return_std</strong> – If True, the std frame is also returned
(default False).</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Rejection operations:</p>
<ul class="simple">
<li><p><strong>sigclip</strong>: A Sigma Clipping algorithm is applied for
each pixel. Min and max values are rejected to estimate
the mean and the standard deviation at each pixel. Then
all values over (median + sigma * std) or below (median -
sigma * std) are rejected. Those steps are repeated (this
time not excluding the extreme values) while no other
value is rejected or the minimum number of values to keep
is reached. Work best with at least 10 frames.</p></li>
<li><p><strong>avsigclip</strong>: Average Sigma Clipping algorithm is the
same as Sigma Clipping algorithm but the standard
deviation at each pixel is estimated using an averaged
value of the std over the lines. This work best than sigma
clipping for a small number of frames. This algorithm is a
little more time consuming than the others. Works best with
at least 5 frames.</p></li>
<li><p><strong>minmax</strong>: Minimum and maximum values at each pixel are
rejected.</p></li>
</ul>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>No rejection operation can be performed with less
than 3 frames.</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="orb.cutils.mean2d">
<code class="sig-prename descclassname"><span class="pre">orb.cutils.</span></code><code class="sig-name descname"><span class="pre">mean2d</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ndarray</span> <span class="pre">box</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.mean2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the mean of a 2d box with no GIL</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>box</strong> – 2d array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.cutils.meansigcut2d">
<code class="sig-prename descclassname"><span class="pre">orb.cutils.</span></code><code class="sig-name descname"><span class="pre">meansigcut2d</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ndarray</span> <span class="pre">x</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">sigma=3</span></em>, <em class="sig-param"><span class="pre">int</span> <span class="pre">min_values=3</span></em>, <em class="sig-param"><span class="pre">int</span> <span class="pre">axis=0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.meansigcut2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sigma cut mean of a 2d array along a given axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> – The 2d array</p></li>
<li><p><strong>sigma</strong> – Number of sigma above which values are considered as
deviant</p></li>
<li><p><strong>min_values</strong> – Minimum number of values to return</p></li>
<li><p><strong>axis</strong> – Axis number. Must be 0 or 1.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.cutils.median2d">
<code class="sig-prename descclassname"><span class="pre">orb.cutils.</span></code><code class="sig-name descname"><span class="pre">median2d</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ndarray</span> <span class="pre">box</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.median2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the median of a 2d box with no GIL</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>box</strong> – 2d array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.cutils.moffat_array2d">
<code class="sig-prename descclassname"><span class="pre">orb.cutils.</span></code><code class="sig-name descname"><span class="pre">moffat_array2d</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">double</span> <span class="pre">h</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">a</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">dx</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">dy</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">fwhm</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">beta</span></em>, <em class="sig-param"><span class="pre">int</span> <span class="pre">nx</span></em>, <em class="sig-param"><span class="pre">int</span> <span class="pre">ny</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.moffat_array2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the 2D profile of a moffat</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>h</strong> – Height</p></li>
<li><p><strong>a</strong> – Amplitude</p></li>
<li><p><strong>dx</strong> – X position</p></li>
<li><p><strong>dy</strong> – Y position</p></li>
<li><p><strong>fwhm</strong> – FWHM</p></li>
<li><p><strong>beta</strong> – Beta</p></li>
<li><p><strong>nx</strong> – X dimension of the output array</p></li>
<li><p><strong>ny</strong> – Y dimension of the output array</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.cutils.multi_fit_stars">
<code class="sig-prename descclassname"><span class="pre">orb.cutils.</span></code><code class="sig-name descname"><span class="pre">multi_fit_stars</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ndarray</span> <span class="pre">frame,</span> <span class="pre">ndarray</span> <span class="pre">pos,</span> <span class="pre">int</span> <span class="pre">box_size,</span> <span class="pre">double</span> <span class="pre">height_guess=np.nan,</span> <span class="pre">ndarray</span> <span class="pre">fwhm_guess=np.array([np.nan],</span> <span class="pre">dtype=float),</span> <span class="pre">bool</span> <span class="pre">cov_height=False,</span> <span class="pre">bool</span> <span class="pre">cov_pos=True,</span> <span class="pre">bool</span> <span class="pre">cov_fwhm=True,</span> <span class="pre">bool</span> <span class="pre">fix_height=False,</span> <span class="pre">bool</span> <span class="pre">fix_pos=False,</span> <span class="pre">bool</span> <span class="pre">fix_fwhm=False,</span> <span class="pre">double</span> <span class="pre">fit_tol=1e-3,</span> <span class="pre">double</span> <span class="pre">ron=np.nan,</span> <span class="pre">double</span> <span class="pre">dcl=np.nan,</span> <span class="pre">bool</span> <span class="pre">enable_zoom=False,</span> <span class="pre">bool</span> <span class="pre">enable_rotation=False,</span> <span class="pre">bool</span> <span class="pre">estimate_local_noise=True,</span> <span class="pre">double</span> <span class="pre">saturation=0,</span> <span class="pre">sip=None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.multi_fit_stars" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit multiple stars at the same time.</p>
<p>Useful if the relative positions of the stars are well known. In
this case the pattern of position can be shifted, zoomed and
rotated in order to be adjusted to the stars in the frame.</p>
<p>Other covarying parameters can be the height and the FWHM.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>frame</strong> – Frame</p></li>
<li><p><strong>pos</strong> – array of stars positions of shape [[x1, y1], [x2, y2] …]</p></li>
<li><p><strong>box_size</strong> – Size of the box around a single star</p></li>
<li><p><strong>height_guess</strong> – (Optional) Initial guess on the height
parameter (default NaN).</p></li>
<li><p><strong>fwhm_guess</strong> – (Optional) Initial guess on the FWHM parameter
must a numpy.ndarray.</p></li>
<li><p><strong>cov_height</strong> – (Optional) If True, height is considered to be
the same for all the stars. It is then a covarying parameter
(default False).</p></li>
<li><p><strong>cov_pos</strong> – (Optional) If True, shift along x and y is
considered as the same for all the stars. dx and dy are thus 2
covarying parameters (default True).</p></li>
<li><p><strong>cov_fwhm</strong> – (Optional) If True, FWHM is considered to be the
same for all the stars. It is then a covarying parameter
(default True).</p></li>
<li><p><strong>fix_height</strong> – (Optional) If True, height is fixed to its
guess (default False).</p></li>
<li><p><strong>fix_pos</strong> – (Optional) If True, x and y are fixed to the position
guess given by pos (default False).</p></li>
<li><p><strong>fix_fwhm</strong> – (Optional) If True, FWHM is fixed to its guess
(default False).</p></li>
<li><p><strong>fit_tol</strong> – (Optional) Tolerance on the fit (default 1e-3).</p></li>
<li><p><strong>ron</strong> – (Optional) Readout noise. If given and if
estimate_local_noise is set to False the readout noise is fixed
to the given value. If not given the ron is guessed from the
background around the stars (default NaN).</p></li>
<li><p><strong>dcl</strong> – (Optional) Dark current level. If given and if
estimate_local_noise is set to False the dark current level is
fixed to the given value. If not given the dark current level is
fixed to 0. (default NaN)</p></li>
<li><p><strong>enable_zoom</strong> – (Optional) If True the position pattern can be
zoomed (default False).</p></li>
<li><p><strong>enable_rotation</strong> – (Optional) If True the position pattern
can be rotated (default False).</p></li>
<li><p><strong>estimate_local_noise</strong> – (Optional) If True, the level of
noise is computed from the background pixels around the
stars. ron and dcl parameters are thus not used (default True).</p></li>
<li><p><strong>saturation</strong> – (Optional) If not 0, all pixels above the
saturation level are removed from the fit (default 0).</p></li>
<li><p><strong>sip</strong> – (Optional) A pywcs.WCS instance containing SIP
distorsion correction (default None).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.cutils.nanbin_image">
<code class="sig-prename descclassname"><span class="pre">orb.cutils.</span></code><code class="sig-name descname"><span class="pre">nanbin_image</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ndarray</span> <span class="pre">im</span></em>, <em class="sig-param"><span class="pre">int</span> <span class="pre">binning</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.nanbin_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Mean image binning robust to NaNs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>im</strong> – Image to bin</p></li>
<li><p><strong>binning</strong> – Binning factor (must be an integer)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.cutils.part_value">
<code class="sig-prename descclassname"><span class="pre">orb.cutils.</span></code><code class="sig-name descname"><span class="pre">part_value</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ndarray</span> <span class="pre">distrib</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">coeff</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.part_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the value lying between two parts of a partition</p>
<p>The partition process is nan robusts. It is made over a
distribution cleaned from nans.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>distrib</strong> – A 1D array of floats.</p></li>
<li><p><strong>coeff</strong> – Partition coefficient (must be &gt;= 0. and &lt;= 1.). If
0 return the min of the distribution and if 1 return the max.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.cutils.point_inside_polygon">
<code class="sig-prename descclassname"><span class="pre">orb.cutils.</span></code><code class="sig-name descname"><span class="pre">point_inside_polygon</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">double</span> <span class="pre">x</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">y</span></em>, <em class="sig-param"><span class="pre">list</span> <span class="pre">poly</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.point_inside_polygon" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if a point is inside a given polygon or not
Polygon is a list of (x,y) pairs.</p>
<p>This function has been taken from
<a class="reference external" href="http://www.ariel.com.au/a/python-point-int-poly.html">http://www.ariel.com.au/a/python-point-int-poly.html</a> and cythonized.</p>
</dd></dl>

<dl class="py function">
<dt id="orb.cutils.radians">
<code class="sig-prename descclassname"><span class="pre">orb.cutils.</span></code><code class="sig-name descname"><span class="pre">radians</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">double</span> <span class="pre">deg</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.radians" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert degrees to radians</p>
</dd></dl>

<dl class="py function">
<dt id="orb.cutils.robust_average">
<code class="sig-prename descclassname"><span class="pre">orb.cutils.</span></code><code class="sig-name descname"><span class="pre">robust_average</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ndarray</span> <span class="pre">x</span></em>, <em class="sig-param"><span class="pre">ndarray</span> <span class="pre">w</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.robust_average" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute robust average of a numpy ndarray (NaNs are skipped)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> – a numpy ndarray</p></li>
<li><p><strong>w</strong> – a numpy ndarray of weigths</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To get a weighted average the MEAN of the weights must
be equal to 1.</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="orb.cutils.robust_mean">
<code class="sig-prename descclassname"><span class="pre">orb.cutils.</span></code><code class="sig-name descname"><span class="pre">robust_mean</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ndarray</span> <span class="pre">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.robust_mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute robust mean of a numpy ndarray (NaNs are skipped)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> – a numpy ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.cutils.robust_median">
<code class="sig-prename descclassname"><span class="pre">orb.cutils.</span></code><code class="sig-name descname"><span class="pre">robust_median</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ndarray</span> <span class="pre">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.robust_median" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute robust median of a numpy ndarray (NaNs are skipped)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> – a numpy ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.cutils.robust_std">
<code class="sig-prename descclassname"><span class="pre">orb.cutils.</span></code><code class="sig-name descname"><span class="pre">robust_std</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ndarray</span> <span class="pre">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.robust_std" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute robust std of a numpy ndarray (NaNs are skipped)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> – a numpy ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.cutils.robust_sum">
<code class="sig-prename descclassname"><span class="pre">orb.cutils.</span></code><code class="sig-name descname"><span class="pre">robust_sum</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ndarray</span> <span class="pre">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.robust_sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute robust sum of a numpy ndarray (NaNs are skipped)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> – a numpy ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.cutils.sigmaclip">
<code class="sig-prename descclassname"><span class="pre">orb.cutils.</span></code><code class="sig-name descname"><span class="pre">sigmaclip</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ndarray</span> <span class="pre">x</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">sigma</span></em>, <em class="sig-param"><span class="pre">int</span> <span class="pre">min_values</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.sigmaclip" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a distribution after a sigma clipping rejection
of the too deviant values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> – The distribution to sigmaclip</p></li>
<li><p><strong>sigma</strong> – Number of sigma above which values are considered as
deviant</p></li>
<li><p><strong>min_values</strong> – Minimum number of values to return</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.cutils.sigmacut">
<code class="sig-prename descclassname"><span class="pre">orb.cutils.</span></code><code class="sig-name descname"><span class="pre">sigmacut</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ndarray</span> <span class="pre">x</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">central_value</span></em>, <em class="sig-param"><span class="pre">int</span> <span class="pre">use_central_value</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">sigma</span></em>, <em class="sig-param"><span class="pre">int</span> <span class="pre">min_values</span></em>, <em class="sig-param"><span class="pre">return_index_list=False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.sigmacut" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a distribution after a sigma cut rejection
of the too deviant values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> – The distribution to cut</p></li>
<li><p><strong>sigma</strong> – Number of sigma above which values are considered as
deviant</p></li>
<li><p><strong>min_values</strong> – Minimum number of values to return</p></li>
<li><p><strong>central_value</strong> – If not none, this value is used as the
central value of the cut. Else the median of the distribution is
used as the central value</p></li>
<li><p><strong>use_central_value</strong> – If True central value is used instead of
the median.</p></li>
<li><p><strong>return_index_list</strong> – (Optional) If True the list of the non
rejected values is returned also (default False).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.cutils.sinc1d">
<code class="sig-prename descclassname"><span class="pre">orb.cutils.</span></code><code class="sig-name descname"><span class="pre">sinc1d</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ndarray</span> <span class="pre">x</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">h</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">a</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">dx</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">fwhm</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.sinc1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a 1D sinc given a set of parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> – 1D array of float64 giving the positions where the
sinc is evaluated</p></li>
<li><p><strong>h</strong> – Height</p></li>
<li><p><strong>a</strong> – Amplitude</p></li>
<li><p><strong>dx</strong> – Position of the center</p></li>
<li><p><strong>w</strong> – FWHM, <span class="math notranslate nohighlight">\(\text{FWHM} = \text{Width} \times 2 \sqrt{2 \ln 2}\)</span></p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.cutils.sip_im2pix">
<code class="sig-prename descclassname"><span class="pre">orb.cutils.</span></code><code class="sig-name descname"><span class="pre">sip_im2pix</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ndarray</span> <span class="pre">im_coords</span></em>, <em class="sig-param"><span class="pre">sip</span></em>, <em class="sig-param"><span class="pre">tolerance=1e-8</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.sip_im2pix" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform perfect pixel positions to distorded pixels positions</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>im_coords</strong> – perfect pixel positions as an Nx2 array of floats.</p></li>
<li><p><strong>sip</strong> – pywcs.WCS() instance containing SIP parameters.</p></li>
<li><p><strong>tolerance</strong> – tolerance on the iterative method.</p></li>
</ul>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>SIP.foc2pix must be used instead</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="orb.cutils.sip_pix2im">
<code class="sig-prename descclassname"><span class="pre">orb.cutils.</span></code><code class="sig-name descname"><span class="pre">sip_pix2im</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ndarray</span> <span class="pre">pix_coords</span></em>, <em class="sig-param"><span class="pre">sip</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.sip_pix2im" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform distorded pixel positions to perfect pixels positions</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pix_coords</strong> – distorded pixel positions as an Nx2 array of floats.</p></li>
<li><p><strong>sip</strong> – pywcs.WCS() instance containing SIP parameters.</p></li>
</ul>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>SIP.pix2foc must be used instead</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="orb.cutils.spectrum_mean_energy">
<code class="sig-prename descclassname"><span class="pre">orb.cutils.</span></code><code class="sig-name descname"><span class="pre">spectrum_mean_energy</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ndarray</span> <span class="pre">spectrum</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.spectrum_mean_energy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the mean energy of a spectrum by channel.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>spectrum</strong> – a 1D spectrum</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>NaNs are counted as zeros.</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="orb.cutils.surface_value">
<code class="sig-prename descclassname"><span class="pre">orb.cutils.</span></code><code class="sig-name descname"><span class="pre">surface_value</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">int</span> <span class="pre">dimx</span></em>, <em class="sig-param"><span class="pre">int</span> <span class="pre">dimy</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">xc</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">yc</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">rmin</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">rmax</span></em>, <em class="sig-param"><span class="pre">long</span> <span class="pre">sub_div</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.surface_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an approximation of the surface value of a pixel given
the min and max radius of an annulus in pixels.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dimx</strong> – dimension of the box along x</p></li>
<li><p><strong>dimy</strong> – dimension of the box along y</p></li>
<li><p><strong>xc</strong> – center of the annulus along x</p></li>
<li><p><strong>yc</strong> – center of the annulus along y</p></li>
<li><p><strong>rmin</strong> – min radius of the annulus</p></li>
<li><p><strong>rmax</strong> – max radius of the annulus</p></li>
<li><p><strong>sub_div</strong> – Number of subdivisions to make (the higher,the
better but the longer too)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.cutils.transform_A_to_B">
<code class="sig-prename descclassname"><span class="pre">orb.cutils.</span></code><code class="sig-name descname"><span class="pre">transform_A_to_B</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">double</span> <span class="pre">x1</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">y1</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">dx</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">dy</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">dr</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">da</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">db</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">xrc</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">yrc</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">zx</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">zy</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">x1_err=0.</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">y1_err=0.</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">dx_err=0.</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">dy_err=0.</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">dr_err=0.</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">zx_err=0.</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">zy_err=0.</span></em>, <em class="sig-param"><span class="pre">bool</span> <span class="pre">return_err=False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.transform_A_to_B" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform star positions in camera A to the same star position
in camera B given the transformation parameters</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x1</strong> – x coordinate to transform</p></li>
<li><p><strong>y1</strong> – y coordinate to transform</p></li>
<li><p><strong>dx</strong> – translation along x</p></li>
<li><p><strong>dy</strong> – translation along y</p></li>
<li><p><strong>dr</strong> – rotation in the plane of the image</p></li>
<li><p><strong>da</strong> – tip angle</p></li>
<li><p><strong>db</strong> – tilt angle</p></li>
<li><p><strong>xrc</strong> – x coordinate of the rotation center</p></li>
<li><p><strong>yrc</strong> – y coordinate of the rotation center</p></li>
<li><p><strong>zx</strong> – zoom coefficient along x</p></li>
<li><p><strong>zy</strong> – zoom coefficient along y</p></li>
<li><p><strong>x1_err</strong> – (Optional) Error on x1 estimate (default 0.)</p></li>
<li><p><strong>y1_err</strong> – (Optional) Error on y1 estimate (default 0.)</p></li>
<li><p><strong>dx_err</strong> – (Optional) Error on dx estimate (default 0.)</p></li>
<li><p><strong>dy_err</strong> – (Optional) Error on dy estimate (default 0.)</p></li>
<li><p><strong>dr_err</strong> – (Optional) Error on dr estimate (default 0.)</p></li>
<li><p><strong>zx_err</strong> – (Optional) Error on zx estimate (default 0.)</p></li>
<li><p><strong>zy_err</strong> – (Optional) Error on zy estimate (default 0.)</p></li>
<li><p><strong>return_err</strong> – (Optional) If True, the error on the estimate
of x2 and y2 is returned.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>(x2, y2) = f(x1, y1). (x2, y2, x2_err, y2_err) if
return_err is True.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.cutils.transform_B_to_A">
<code class="sig-prename descclassname"><span class="pre">orb.cutils.</span></code><code class="sig-name descname"><span class="pre">transform_B_to_A</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">double</span> <span class="pre">x1</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">y1</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">dx</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">dy</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">dr</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">da</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">db</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">xrc</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">yrc</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">zx</span></em>, <em class="sig-param"><span class="pre">double</span> <span class="pre">zy</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.transform_B_to_A" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Transform star positions in camera B to the same star position</dt><dd><p>in camera A given the transformation parameters.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>this function is meant to be the inverse of
transform_A_to_B. Given the output of transform_A_to_B and the
<strong>SAME transformation parameters</strong> the initial positions must be
returned by this function within the numerical error. i.e. if
(Xb, Yb) = A_to_B(Xi,Yi,p) and (Xa, Ya) = B_to_A(Xb, Yb, p) then
Xa - Xi ~ 1e-13 and Ya - Yi ~ 1e-13 (for float64 numbers)</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x1</strong> – x coordinate to transform</p></li>
<li><p><strong>y1</strong> – y coordinate to transform</p></li>
<li><p><strong>dx</strong> – translation along x</p></li>
<li><p><strong>dy</strong> – translation along y</p></li>
<li><p><strong>dr</strong> – rotation in the plane of the image</p></li>
<li><p><strong>da</strong> – tip angle</p></li>
<li><p><strong>db</strong> – tilt angle</p></li>
<li><p><strong>xrc</strong> – x coordinate of the rotation center</p></li>
<li><p><strong>yrc</strong> – y coordinate of the rotation center</p></li>
<li><p><strong>zx</strong> – zoom coefficient along x</p></li>
<li><p><strong>zy</strong> – zoom coefficient along y</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.cutils.unbin_image">
<code class="sig-prename descclassname"><span class="pre">orb.cutils.</span></code><code class="sig-name descname"><span class="pre">unbin_image</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ndarray</span> <span class="pre">im</span></em>, <em class="sig-param"><span class="pre">int</span> <span class="pre">nx</span></em>, <em class="sig-param"><span class="pre">int</span> <span class="pre">ny</span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.cutils.unbin_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Unbin a binned image (restore the image binned with the
function <a class="reference internal" href="#orb.cutils.nanbin_image" title="orb.cutils.nanbin_image"><code class="xref py py-func docutils literal notranslate"><span class="pre">nanbin_image()</span></code></a>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>im</strong> – Image to unbin.</p></li>
<li><p><strong>nx</strong> – X dimension of the unbinned image.</p></li>
<li><p><strong>ny</strong> – Y dimension of the unbinned image.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-orb.fft">
<span id="orb-fft-module"></span><h2>orb.fft module<a class="headerlink" href="#module-orb.fft" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="orb.fft.HighOrderPhaseCube">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">orb.fft.</span></code><code class="sig-name descname"><span class="pre">HighOrderPhaseCube</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fft.HighOrderPhaseCube" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#orb.core.Data" title="orb.core.Data"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.core.Data</span></code></a></p>
<dl class="py method">
<dt id="orb.fft.HighOrderPhaseCube.generate_phase_cube">
<code class="sig-name descname"><span class="pre">generate_phase_cube</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimy</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fft.HighOrderPhaseCube.generate_phase_cube" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="orb.fft.HighOrderPhaseCube.get_map">
<code class="sig-name descname"><span class="pre">get_map</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">order</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fft.HighOrderPhaseCube.get_map" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="orb.fft.HighOrderPhaseCube.get_phase">
<code class="sig-name descname"><span class="pre">get_phase</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">asarr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fft.HighOrderPhaseCube.get_phase" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="orb.fft.HighOrderPhaseCube.get_phase_coeffs">
<code class="sig-name descname"><span class="pre">get_phase_coeffs</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fft.HighOrderPhaseCube.get_phase_coeffs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt id="orb.fft.Interferogram">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">orb.fft.</span></code><code class="sig-name descname"><span class="pre">Interferogram</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">interf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">err</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fft.Interferogram" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#orb.core.Vector1d" title="orb.core.Vector1d"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.core.Vector1d</span></code></a></p>
<p>Interferogram class.</p>
<dl class="py method">
<dt id="orb.fft.Interferogram.apodize">
<code class="sig-name descname"><span class="pre">apodize</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">window_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fft.Interferogram.apodize" title="Permalink to this definition">¶</a></dt>
<dd><p>Apodization of the interferogram</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>window_type</strong> – Name of the apodization function (can be
‘learner95’ or a float &gt; 1.)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.fft.Interferogram.crop">
<code class="sig-name descname"><span class="pre">crop</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xmin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xmax</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fft.Interferogram.crop" title="Permalink to this definition">¶</a></dt>
<dd><p>Crop data. see Vector1d.crop()</p>
</dd></dl>

<dl class="py method">
<dt id="orb.fft.Interferogram.get_phase">
<code class="sig-name descname"><span class="pre">get_phase</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.fft.Interferogram.get_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Classical phase computation method. Returns a Phase instance.</p>
</dd></dl>

<dl class="py method">
<dt id="orb.fft.Interferogram.get_spectrum">
<code class="sig-name descname"><span class="pre">get_spectrum</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mertz</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fft.Interferogram.get_spectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Classical spectrum computation method. Returns a Spectrum instance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>mertz</strong> – If True, multiply by Mertz ramp. Must be used for assymetric interferograms.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.fft.Interferogram.is_right_sided">
<code class="sig-name descname"><span class="pre">is_right_sided</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.fft.Interferogram.is_right_sided" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if interferogram is right sided (left side wrt zpd
shorter than right side)</p>
</dd></dl>

<dl class="py method">
<dt id="orb.fft.Interferogram.multiply_by_mertz_ramp">
<code class="sig-name descname"><span class="pre">multiply_by_mertz_ramp</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fft.Interferogram.multiply_by_mertz_ramp" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply by Mertz (1976) ramp function to avoid counting
symmetric samples twice and reduce emission lines contrast wrt
the background.</p>
</dd></dl>

<dl class="py attribute">
<dt id="orb.fft.Interferogram.needed_params">
<code class="sig-name descname"><span class="pre">needed_params</span></code><em class="property"> <span class="pre">=</span> <span class="pre">('step',</span> <span class="pre">'order',</span> <span class="pre">'zpd_index',</span> <span class="pre">'calib_coeff',</span> <span class="pre">'filter_name',</span> <span class="pre">'exposure_time')</span></em><a class="headerlink" href="#orb.fft.Interferogram.needed_params" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="orb.fft.Interferogram.subtract_low_order_poly">
<code class="sig-name descname"><span class="pre">subtract_low_order_poly</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fft.Interferogram.subtract_low_order_poly" title="Permalink to this definition">¶</a></dt>
<dd><p>low order polynomial substraction to suppress low
frequency noise</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>order</strong> – (Optional) Polynomial order (beware of high
order polynomials, default 3).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.fft.Interferogram.subtract_mean">
<code class="sig-name descname"><span class="pre">subtract_mean</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fft.Interferogram.subtract_mean" title="Permalink to this definition">¶</a></dt>
<dd><p>substraction of the mean of the interferogram where the
interferogram is not nan</p>
</dd></dl>

<dl class="py method">
<dt id="orb.fft.Interferogram.symmetric">
<code class="sig-name descname"><span class="pre">symmetric</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.fft.Interferogram.symmetric" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an interferogram which is symmetric around the zpd</p>
</dd></dl>

<dl class="py method">
<dt id="orb.fft.Interferogram.transform">
<code class="sig-name descname"><span class="pre">transform</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.fft.Interferogram.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>zero padded fft.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A Spectrum instance (or a core.Vector1d instance if
interferogram is full of zeros or nans)</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>no phase correction is made here.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="orb.fft.Phase">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">orb.fft.</span></code><code class="sig-name descname"><span class="pre">Phase</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">spectrum</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fft.Phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#orb.core.Cm1Vector1d" title="orb.core.Cm1Vector1d"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.core.Cm1Vector1d</span></code></a></p>
<p>Phase class</p>
<dl class="py method">
<dt id="orb.fft.Phase.cleaned">
<code class="sig-name descname"><span class="pre">cleaned</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">border_ratio</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fft.Phase.cleaned" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a cleaned phase vector with values out of the filter set to
nan and a median around 0 (modulo pi).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>border_ratio</strong> – (Optional) Relative portion of the phase
in the filter range removed (can be a negative float,
default 0.)</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A Phase instance</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.fft.Phase.polyfit">
<code class="sig-name descname"><span class="pre">polyfit</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">deg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coeffs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_coeffs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">border_ratio</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fft.Phase.polyfit" title="Permalink to this definition">¶</a></dt>
<dd><p>Polynomial fit of the phase</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>deg</strong> – Degree of the fitting polynomial. Must be &gt;= 0.</p></li>
<li><p><strong>coeffs</strong> – (Optional) Used to fix some coefficients to a
given value. If not None, must be a list of length =
deg. set a coeff to a np.nan or a None to let the parameter
free (default None).</p></li>
<li><p><strong>return_coeffs</strong> – (Optional) If True return (fit
coefficients, error on coefficients) else return a Phase
instance representing the fitted phase (default None).</p></li>
<li><p><strong>border_ratio</strong> – (Optional) relative width on the
borders of the filter range removed from the fitted values
(default 0.1)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.fft.Phase.subtract_low_order_poly">
<code class="sig-name descname"><span class="pre">subtract_low_order_poly</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">deg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">border_ratio</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fft.Phase.subtract_low_order_poly" title="Permalink to this definition">¶</a></dt>
<dd><p>low order polynomial substraction to suppress low
frequency noise</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>deg</strong> – Degree of the fitting polynomial. Must be &gt;= 0.</p></li>
<li><p><strong>border_ratio</strong> – (Optional) relative width on the
borders of the filter range removed from the fitted values
(default 0.1)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="orb.fft.PhaseMaps">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">orb.fft.</span></code><code class="sig-name descname"><span class="pre">PhaseMaps</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">phase_maps_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">overwrite</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indexer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fft.PhaseMaps" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#orb.core.Tools" title="orb.core.Tools"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.core.Tools</span></code></a></p>
<dl class="py method">
<dt id="orb.fft.PhaseMaps.generate_phase_cube">
<code class="sig-name descname"><span class="pre">generate_phase_cube</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coeffs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">silent</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fft.PhaseMaps.generate_phase_cube" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a phase cube from the given phase maps.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>coeffs</strong> – Used to set some coefficients to a given
value. If not None, must be a list of length = order. set a
coeff to a np.nan to use the phase map value.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.fft.PhaseMaps.get_coeffs">
<code class="sig-name descname"><span class="pre">get_coeffs</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unbin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fft.PhaseMaps.get_coeffs" title="Permalink to this definition">¶</a></dt>
<dd><p>Return coeffs at position x, y in the maps. x, y are binned
position by default (set unbin to True to get real positions
on the detector)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> – X position (dectector position)</p></li>
<li><p><strong>y</strong> – Y position (dectector position)</p></li>
<li><p><strong>unbin</strong> – If True, positions are unbinned position
(i.e. real positions on the detector) (default False).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.fft.PhaseMaps.get_map">
<code class="sig-name descname"><span class="pre">get_map</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">order</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fft.PhaseMaps.get_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Return map of a given order</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>order</strong> – Polynomial order</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.fft.PhaseMaps.get_map_err">
<code class="sig-name descname"><span class="pre">get_map_err</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">order</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fft.PhaseMaps.get_map_err" title="Permalink to this definition">¶</a></dt>
<dd><p>Return map uncertainty of a given order</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>order</strong> – Polynomial order</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.fft.PhaseMaps.get_mapped_model">
<code class="sig-name descname"><span class="pre">get_mapped_model</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">order</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fft.PhaseMaps.get_mapped_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Return mapped model</p>
</dd></dl>

<dl class="py method">
<dt id="orb.fft.PhaseMaps.get_phase">
<code class="sig-name descname"><span class="pre">get_phase</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unbin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coeffs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fft.PhaseMaps.get_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a phase instance at position x, y in the maps. x, y are
binned position by default (set unbin to True to get real
positions on the detector)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> – X position (dectector position)</p></li>
<li><p><strong>y</strong> – Y position (dectector position)</p></li>
<li><p><strong>unbin</strong> – If True, positions are unbinned position
(i.e. real positions on the detector) (default False).</p></li>
<li><p><strong>coeffs</strong> – Used to set some coefficients to a given
value. If not None, must be a list of length = order. set a
coeff to a np.nan to use the phase map value.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.fft.PhaseMaps.modelize">
<code class="sig-name descname"><span class="pre">modelize</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.fft.PhaseMaps.modelize" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace phase maps by their model inplace</p>
</dd></dl>

<dl class="py attribute">
<dt id="orb.fft.PhaseMaps.phase_maps">
<code class="sig-name descname"><span class="pre">phase_maps</span></code><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#orb.fft.PhaseMaps.phase_maps" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="orb.fft.PhaseMaps.reverse_polarity">
<code class="sig-name descname"><span class="pre">reverse_polarity</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.fft.PhaseMaps.reverse_polarity" title="Permalink to this definition">¶</a></dt>
<dd><p>Add pi to the order 0 phase map to reverse polarity of the
corrected spectrum.</p>
</dd></dl>

<dl class="py method">
<dt id="orb.fft.PhaseMaps.unwrap_phase_map_0">
<code class="sig-name descname"><span class="pre">unwrap_phase_map_0</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.fft.PhaseMaps.unwrap_phase_map_0" title="Permalink to this definition">¶</a></dt>
<dd><p>Unwrap order 0 phase map.</p>
<p>Phase is defined modulo pi/2. The Unwrapping is a
reconstruction of the phase so that the distance between two
neighboor pixels is always less than pi/4. Then the real phase
pattern can be recovered and fitted easily.</p>
<p>The idea is the same as with np.unwrap() but in 2D, on a
possibly very noisy map, where a naive 2d unwrapping cannot be
done.</p>
</dd></dl>

<dl class="py method">
<dt id="orb.fft.PhaseMaps.validate_xy">
<code class="sig-name descname"><span class="pre">validate_xy</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unbin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fft.PhaseMaps.validate_xy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt id="orb.fft.RealInterferogram">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">orb.fft.</span></code><code class="sig-name descname"><span class="pre">RealInterferogram</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fft.RealInterferogram" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#orb.fft.Interferogram" title="orb.fft.Interferogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.fft.Interferogram</span></code></a></p>
<p>Class used for an observed interferogram in counts</p>
<dl class="py method">
<dt id="orb.fft.RealInterferogram.combine">
<code class="sig-name descname"><span class="pre">combine</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">interf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">transmission</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ratio</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fft.RealInterferogram.combine" title="Permalink to this definition">¶</a></dt>
<dd><p>Combine two interferograms (one from each camera) and return the result</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>interf</strong> – Another Interferogram instance coming from the
complementary camera.</p></li>
<li><p><strong>transmission</strong> – (Optional) Must be a Vector1d instance. if None
supplied, transmission is computed from the combined
interferogram which may add some noise (default None).</p></li>
<li><p><strong>ratio</strong> – (Optional) optical transmission ratio self /
interf. As the beamsplitter and the differential gain of the
cameras produce a difference in the number of counts
collected in one camera or the other, the interferograms
must be corrected for this ratio before being combined. If
None, this ratio is computed from the provided
interferograms.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.fft.RealInterferogram.compute_transmission">
<code class="sig-name descname"><span class="pre">compute_transmission</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">interf</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fft.RealInterferogram.compute_transmission" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the transmission vector computed from the combination of two
complementary interferograms.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>interf</strong> – Another Interferogram instance coming from the
complementary camera.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.fft.RealInterferogram.math">
<code class="sig-name descname"><span class="pre">math</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">opname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fft.RealInterferogram.math" title="Permalink to this definition">¶</a></dt>
<dd><p>Do math operations and update the ‘source_counts’ value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>opname</strong> – math operation, must be a numpy.ufuncs.</p></li>
<li><p><strong>arg</strong> – If None, no argument is supplied. Else, can be a
float or a Vector1d instance.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.fft.RealInterferogram.subtract_sky">
<code class="sig-name descname"><span class="pre">subtract_sky</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sky</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fft.RealInterferogram.subtract_sky" title="Permalink to this definition">¶</a></dt>
<dd><p>Subtract sky interferogram (or any background interferogram).</p>
<p>The values of the parameter ‘pixels’ in both this
interferogram and the sky interferogram should be set to the
number of integrated pixels.</p>
</dd></dl>

<dl class="py method">
<dt id="orb.fft.RealInterferogram.transform">
<code class="sig-name descname"><span class="pre">transform</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.fft.RealInterferogram.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Zero padded fft. See Interferogram.transform()</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="orb.fft.RealSpectrum">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">orb.fft.</span></code><code class="sig-name descname"><span class="pre">RealSpectrum</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fft.RealSpectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#orb.fft.Spectrum" title="orb.fft.Spectrum"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.fft.Spectrum</span></code></a></p>
<p>Spectrum class computed from real interferograms (in counts)</p>
<dl class="py method">
<dt id="orb.fft.RealSpectrum.compute_counts_in_spectrum">
<code class="sig-name descname"><span class="pre">compute_counts_in_spectrum</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.fft.RealSpectrum.compute_counts_in_spectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of counts in the spectrum</p>
</dd></dl>

<dl class="py method">
<dt id="orb.fft.RealSpectrum.compute_me">
<code class="sig-name descname"><span class="pre">compute_me</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.fft.RealSpectrum.compute_me" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the modulation efficiency, computed from the ratio between
the number of counts in the original interferogram and the
number of counts in the spectrum.</p>
</dd></dl>

<dl class="py method">
<dt id="orb.fft.RealSpectrum.subtract_sky">
<code class="sig-name descname"><span class="pre">subtract_sky</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sky</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fft.RealSpectrum.subtract_sky" title="Permalink to this definition">¶</a></dt>
<dd><p>Subtract spectrum interferogram (or any background spectrum).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>sky</strong> – A spectrum instance.</p>
</dd>
</dl>
<p>The values of the parameter ‘pixels’ in both this
interferogram and the sky interferogram should be set to the
number of integrated pixels.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="orb.fft.Spectrum">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">orb.fft.</span></code><code class="sig-name descname"><span class="pre">Spectrum</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">spectrum</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">err</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fft.Spectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#orb.core.Cm1Vector1d" title="orb.core.Cm1Vector1d"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.core.Cm1Vector1d</span></code></a></p>
<p>Spectrum class</p>
<dl class="py method">
<dt id="orb.fft.Spectrum.apodize">
<code class="sig-name descname"><span class="pre">apodize</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coeff</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fft.Spectrum.apodize" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an apodized spectrum (works well only if spectrum is complex)</p>
</dd></dl>

<dl class="py method">
<dt id="orb.fft.Spectrum.correct_phase">
<code class="sig-name descname"><span class="pre">correct_phase</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">phase</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fft.Spectrum.correct_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Correct spectrum phase</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>phase</strong> – can be a 1d array or a Phase instance.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.fft.Spectrum.estimate_flux">
<code class="sig-name descname"><span class="pre">estimate_flux</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lines</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vel</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fft.Spectrum.estimate_flux" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="orb.fft.Spectrum.estimate_parameters">
<code class="sig-name descname"><span class="pre">estimate_parameters</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lines</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vel_range</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precision</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fft.Spectrum.estimate_parameters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="orb.fft.Spectrum.estimate_velocity_prepared">
<code class="sig-name descname"><span class="pre">estimate_velocity_prepared</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">combs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_range_pix</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fft.Spectrum.estimate_velocity_prepared" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="orb.fft.Spectrum.fit">
<code class="sig-name descname"><span class="pre">fit</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lines</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fmodel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sinc'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nofilter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nogvar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fft.Spectrum.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit lines in a spectrum</p>
<p>Wrapper around orb.fit.fit_lines_in_spectrum.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lines</strong> – lines to fit.</p></li>
<li><p><strong>max_iter</strong> – (Optional) Maximum number of iterations (default None)</p></li>
<li><p><strong>kwargs</strong> – kwargs used by orb.fit.fit_lines_in_spectrum.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.fft.Spectrum.get_amplitude">
<code class="sig-name descname"><span class="pre">get_amplitude</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.fft.Spectrum.get_amplitude" title="Permalink to this definition">¶</a></dt>
<dd><p>return amplitude</p>
</dd></dl>

<dl class="py method">
<dt id="orb.fft.Spectrum.get_imag">
<code class="sig-name descname"><span class="pre">get_imag</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.fft.Spectrum.get_imag" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the imaginary part</p>
</dd></dl>

<dl class="py method">
<dt id="orb.fft.Spectrum.get_phase">
<code class="sig-name descname"><span class="pre">get_phase</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.fft.Spectrum.get_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>return phase</p>
</dd></dl>

<dl class="py method">
<dt id="orb.fft.Spectrum.get_real">
<code class="sig-name descname"><span class="pre">get_real</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.fft.Spectrum.get_real" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the real part</p>
</dd></dl>

<dl class="py method">
<dt id="orb.fft.Spectrum.interpolate">
<code class="sig-name descname"><span class="pre">interpolate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">axis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">quality</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">timing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fft.Spectrum.interpolate" title="Permalink to this definition">¶</a></dt>
<dd><p>Resample spectrum by interpolation over the given axis</p>
<p>This is a simple wrapper around core.Vector1d.project which
now integrates all the fft interpolation method when data is
complex.</p>
<p>It has been kept for backward compatibility. Please use the
project method.</p>
</dd></dl>

<dl class="py method">
<dt id="orb.fft.Spectrum.inverse_transform">
<code class="sig-name descname"><span class="pre">inverse_transform</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.fft.Spectrum.inverse_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the inverse transform of the spectrum. This should be the
exact inverse transform of Interferogram.transform()</p>
</dd></dl>

<dl class="py method">
<dt id="orb.fft.Spectrum.prepare_fit">
<code class="sig-name descname"><span class="pre">prepare_fit</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lines</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fmodel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sinc'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nofilter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fft.Spectrum.prepare_fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the input parameters, which can be reused to accelerate
similar fits.</p>
</dd></dl>

<dl class="py method">
<dt id="orb.fft.Spectrum.prepare_velocity_estimate">
<code class="sig-name descname"><span class="pre">prepare_velocity_estimate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lines</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vel_range</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precision</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fft.Spectrum.prepare_velocity_estimate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="orb.fft.Spectrum.prepared_fit">
<code class="sig-name descname"><span class="pre">prepared_fit</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inputparams</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nogvar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fft.Spectrum.prepared_fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Run a fit already prepared with prepare_fit() method.</p>
</dd></dl>

<dl class="py method">
<dt id="orb.fft.Spectrum.zpd_shift">
<code class="sig-name descname"><span class="pre">zpd_shift</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shift</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fft.Spectrum.zpd_shift" title="Permalink to this definition">¶</a></dt>
<dd><p>correct spectrum phase from shifted zpd</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="orb.fft.StandardSpectrum">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">orb.fft.</span></code><code class="sig-name descname"><span class="pre">StandardSpectrum</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fft.StandardSpectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#orb.fft.RealSpectrum" title="orb.fft.RealSpectrum"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.fft.RealSpectrum</span></code></a></p>
<p>Spectrum class for standard spectrum computed from real
interferograms (in counts).</p>
<p>Spectrum unit should be in counts.</p>
<dl class="py method">
<dt id="orb.fft.StandardSpectrum.compute_flux_correction_vector">
<code class="sig-name descname"><span class="pre">compute_flux_correction_vector</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">deg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resolution</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_residual</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fft.StandardSpectrum.compute_flux_correction_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute flux correction vector by fitting a simulated model of the
standard star on the observed spectrum.</p>
</dd></dl>

<dl class="py attribute">
<dt id="orb.fft.StandardSpectrum.convert_params">
<code class="sig-name descname"><span class="pre">convert_params</span></code><em class="property"> <span class="pre">=</span> <span class="pre">{'AIRMASS':</span> <span class="pre">'airmass',</span> <span class="pre">'CAMERA':</span> <span class="pre">'camera',</span> <span class="pre">'EXPTIME':</span> <span class="pre">'exposure_time',</span> <span class="pre">'FILTER':</span> <span class="pre">'filter_name',</span> <span class="pre">'INSTRUME':</span> <span class="pre">'instrument'}</span></em><a class="headerlink" href="#orb.fft.StandardSpectrum.convert_params" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="orb.fft.StandardSpectrum.get_standard">
<code class="sig-name descname"><span class="pre">get_standard</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.fft.StandardSpectrum.get_standard" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the standard spectrum</p>
</dd></dl>

<dl class="py method">
<dt id="orb.fft.StandardSpectrum.to_counts_s">
<code class="sig-name descname"><span class="pre">to_counts_s</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.fft.StandardSpectrum.to_counts_s" title="Permalink to this definition">¶</a></dt>
<dd><p>Return spectrum in counts/s</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-orb.fit">
<span id="orb-fit-module"></span><h2>orb.fit module<a class="headerlink" href="#module-orb.fit" title="Permalink to this headline">¶</a></h2>
<p>Fit module of ORB.</p>
<p>Defines the general Fitting classes and the fitting models.</p>
<p>Best accessed through fit_lines_in_*() functions (defined at the end
of the file)</p>
<dl class="py class">
<dt id="orb.fit.Cm1InputParams">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">orb.fit.</span></code><code class="sig-name descname"><span class="pre">Cm1InputParams</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">step</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step_nb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nm_laser</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta_proj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta_orig</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">apodization</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zpd_index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.Cm1InputParams" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#orb.fit.InputParams" title="orb.fit.InputParams"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.fit.InputParams</span></code></a></p>
<p>Manage the input parameters for <a class="reference internal" href="#orb.fit.FitVector" title="orb.fit.FitVector"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.fit.FitVector</span></code></a>
and <a class="reference internal" href="#orb.fit.fit_lines_in_spectrum" title="orb.fit.fit_lines_in_spectrum"><code class="xref py py-meth docutils literal notranslate"><span class="pre">orb.fit.fit_lines_in_spectrum()</span></code></a>.</p>
<dl class="py method">
<dt id="orb.fit.Cm1InputParams.add_filter_model">
<code class="sig-name descname"><span class="pre">add_filter_model</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.Cm1InputParams.add_filter_model" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="orb.fit.Cm1InputParams.add_lines_model">
<code class="sig-name descname"><span class="pre">add_lines_model</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lines</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.Cm1InputParams.add_lines_model" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="orb.fit.Cm1InputParams.check_signal_range">
<code class="sig-name descname"><span class="pre">check_signal_range</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.Cm1InputParams.check_signal_range" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="orb.fit.Cm1InputParams.convert">
<code class="sig-name descname"><span class="pre">convert</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.Cm1InputParams.convert" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert class to a pickable dict object</p>
</dd></dl>

<dl class="py method">
<dt id="orb.fit.Cm1InputParams.set_signal_range">
<code class="sig-name descname"><span class="pre">set_signal_range</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rmin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rmax</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.Cm1InputParams.set_signal_range" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt id="orb.fit.Cm1LinesModel">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">orb.fit.</span></code><code class="sig-name descname"><span class="pre">Cm1LinesModel</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p_dict</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.Cm1LinesModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#orb.fit.LinesModel" title="orb.fit.LinesModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.fit.LinesModel</span></code></a></p>
<p>Emission/absorption lines model with a channel unity in cm-1.</p>
<p>Reimplements <code class="xref py py-class docutils literal notranslate"><span class="pre">fit.LinesModel</span></code> to use more physical units
: channels are translated to cm-1 and velocity to km/s in input
and output.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>For more information please refer to
<code class="xref py py-class docutils literal notranslate"><span class="pre">fit.LinesModel</span></code></p>
</div>
<dl class="py attribute">
<dt id="orb.fit.Cm1LinesModel.accepted_keys">
<code class="sig-name descname"><span class="pre">accepted_keys</span></code><em class="property"> <span class="pre">=</span> <span class="pre">['line_nb',</span> <span class="pre">'fmodel',</span> <span class="pre">'ratio',</span> <span class="pre">'amp_def',</span> <span class="pre">'pos_def',</span> <span class="pre">'fwhm_def',</span> <span class="pre">'sigma_def',</span> <span class="pre">'alpha_def',</span> <span class="pre">'amp_cov',</span> <span class="pre">'pos_cov',</span> <span class="pre">'fwhm_cov',</span> <span class="pre">'sigma_cov',</span> <span class="pre">'alpha_cov',</span> <span class="pre">'amp_guess',</span> <span class="pre">'pos_guess',</span> <span class="pre">'fwhm_guess',</span> <span class="pre">'sigma_guess',</span> <span class="pre">'alpha_guess',</span> <span class="pre">'step_nb',</span> <span class="pre">'step',</span> <span class="pre">'order',</span> <span class="pre">'nm_laser',</span> <span class="pre">'nm_laser_obs']</span></em><a class="headerlink" href="#orb.fit.Cm1LinesModel.accepted_keys" title="Permalink to this definition">¶</a></dt>
<dd><p>Accepted keys of the input dictionary (see
<code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_dict</span></code>)</p>
</dd></dl>

<dl class="py method">
<dt id="orb.fit.Cm1LinesModel.parse_dict">
<code class="sig-name descname"><span class="pre">parse_dict</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.Cm1LinesModel.parse_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse input dictionary <code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_dict</span></code></p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="orb.fit.ContinuumModel">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">orb.fit.</span></code><code class="sig-name descname"><span class="pre">ContinuumModel</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p_dict</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.ContinuumModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#orb.fit.Model" title="orb.fit.Model"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.fit.Model</span></code></a></p>
<p>Polynomial continuum model.</p>
<p>Input dictionary <code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_dict</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="s1">&#39;poly_order&#39;</span><span class="p">:</span>
 <span class="s1">&#39;poly_guess&#39;</span><span class="p">:}</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>poly_order</strong> – Order of the polynomial to fit (be careful
with high order polynomials).</p></li>
<li><p><strong>poly_guess</strong> – Initial guess on the coefficient values :
must be a tuple of length poly_order + 1.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This model must be added to the others.</p>
</div>
<dl class="py attribute">
<dt id="orb.fit.ContinuumModel.accepted_keys">
<code class="sig-name descname"><span class="pre">accepted_keys</span></code><em class="property"> <span class="pre">=</span> <span class="pre">('poly_def',</span> <span class="pre">'poly_order',</span> <span class="pre">'poly_guess')</span></em><a class="headerlink" href="#orb.fit.ContinuumModel.accepted_keys" title="Permalink to this definition">¶</a></dt>
<dd><p>Accepted keys of the input dictionary (see
<code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_dict</span></code>)</p>
</dd></dl>

<dl class="py method">
<dt id="orb.fit.ContinuumModel.check_input">
<code class="sig-name descname"><span class="pre">check_input</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.ContinuumModel.check_input" title="Permalink to this definition">¶</a></dt>
<dd><p>Check input parameters</p>
</dd></dl>

<dl class="py method">
<dt id="orb.fit.ContinuumModel.get_model">
<code class="sig-name descname"><span class="pre">get_model</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_free</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_models</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">multf</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_complex</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.ContinuumModel.get_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Return model M(x, p).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> – Positions where the model M(x, p) is computed.</p></li>
<li><p><strong>p_free</strong> – (Optional) New values of the free parameters
(default None).</p></li>
<li><p><strong>multf</strong> – 1d vector with the same length as x vector which
represent the function by which the model must be multiplied.</p></li>
<li><p><strong>return_models</strong> – (Optional) If True return also
individual models (default False)</p></li>
<li><p><strong>return_complex</strong> – (Optional) If True return a complex
model (default False).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.fit.ContinuumModel.get_p_val_as_array">
<code class="sig-name descname"><span class="pre">get_p_val_as_array</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p_val</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.ContinuumModel.get_p_val_as_array" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="orb.fit.ContinuumModel.make_guess">
<code class="sig-name descname"><span class="pre">make_guess</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.ContinuumModel.make_guess" title="Permalink to this definition">¶</a></dt>
<dd><p>If a parameter value at init is a NaN this value is guessed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> – Data vector from which the guess is made.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.fit.ContinuumModel.parse_dict">
<code class="sig-name descname"><span class="pre">parse_dict</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.ContinuumModel.parse_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse input dictionary <code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_dict</span></code></p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="orb.fit.FilterModel">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">orb.fit.</span></code><code class="sig-name descname"><span class="pre">FilterModel</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p_dict</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.FilterModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#orb.fit.Model" title="orb.fit.Model"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.fit.Model</span></code></a></p>
<p>Simple model of filter based on a real filter shape. The only
possible free parameter is a wavelength/wavenumber shift.</p>
<p>Input dictionary <code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_dict</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="s1">&#39;filter_function&#39;</span><span class="p">:,</span>
 <span class="s1">&#39;shift_guess&#39;</span><span class="p">:,</span>
 <span class="s1">&#39;shift_def&#39;</span><span class="p">:}</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filter_function</strong> – Transmission of the filter over the
fitted spectral range (axis must be exactly the same).</p></li>
<li><p><strong>shift_guess</strong> – Guess on the filter shift in pixels.</p></li>
<li><p><strong>shift_def</strong> – Definition of the shift parameter, can be
‘free’ or ‘fixed’</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This model must be multiplied with the other and used
last.</p>
</div>
<dl class="py attribute">
<dt id="orb.fit.FilterModel.accepted_keys">
<code class="sig-name descname"><span class="pre">accepted_keys</span></code><em class="property"> <span class="pre">=</span> <span class="pre">('filter_function',</span> <span class="pre">'shift_guess',</span> <span class="pre">'shift_def')</span></em><a class="headerlink" href="#orb.fit.FilterModel.accepted_keys" title="Permalink to this definition">¶</a></dt>
<dd><p>Accepted keys of the input dictionary (see
<code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_dict</span></code>)</p>
</dd></dl>

<dl class="py method">
<dt id="orb.fit.FilterModel.check_input">
<code class="sig-name descname"><span class="pre">check_input</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.FilterModel.check_input" title="Permalink to this definition">¶</a></dt>
<dd><p>Check input parameters</p>
</dd></dl>

<dl class="py method">
<dt id="orb.fit.FilterModel.get_model">
<code class="sig-name descname"><span class="pre">get_model</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_free</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_models</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_complex</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.FilterModel.get_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Return model M(x, p).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> – Positions where the model M(x, p) is computed.</p></li>
<li><p><strong>p_free</strong> – (Optional) New values of the free parameters
(default None).</p></li>
<li><p><strong>return_models</strong> – (Optional) If True return also
individual models (default False)</p></li>
<li><p><strong>return_complex</strong> – (Optional) If True return a complex
model (default False).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.fit.FilterModel.make_guess">
<code class="sig-name descname"><span class="pre">make_guess</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.FilterModel.make_guess" title="Permalink to this definition">¶</a></dt>
<dd><p>If a parameter value at init is a NaN this value is guessed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> – Data vector from which the guess is made.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.fit.FilterModel.parse_dict">
<code class="sig-name descname"><span class="pre">parse_dict</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.FilterModel.parse_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse input dictionary <code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_dict</span></code></p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="orb.fit.FitVector">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">orb.fit.</span></code><code class="sig-name descname"><span class="pre">FitVector</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vector</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">models</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">signal_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">docomplex</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nogvar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector_err</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.FitVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>General fitting class for a 1d array of data based on
Levenberg-Marquardt least square fit algorithm.</p>
<p>Accept any combination of models (based on <code class="xref py py-class docutils literal notranslate"><span class="pre">fit.Model</span></code>)</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is a wrapper around
<code class="xref py py-meth docutils literal notranslate"><span class="pre">scipy.optimize.leastsq()</span></code>. Most of its purpose consists
in passing an array of purely free parameters to
<code class="xref py py-meth docutils literal notranslate"><span class="pre">scipy.optimize.leastsq()</span></code> and creating the objective
function from free and fixed parameters by combining the
different models.</p>
</div>
<dl class="py method">
<dt id="orb.fit.FitVector.fit">
<code class="sig-name descname"><span class="pre">fit</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">compute_mcmc_error</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.FitVector.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit data vector.</p>
<p>This is the central function of the class.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>compute_mcmc_error</strong> – (Optional) Compute Markov chain
Monte-Carlo error on the fit parameters (Uncertainty
estimates might be slighly better constrained but computing
time can be orders of magnitude longer) (default False).</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="orb.fit.FitVector.fit_tol">
<code class="sig-name descname"><span class="pre">fit_tol</span></code><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#orb.fit.FitVector.fit_tol" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="orb.fit.FitVector.get_model">
<code class="sig-name descname"><span class="pre">get_model</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">all_p_free</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_models</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.FitVector.get_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the combined model of the vector given a set of free
parameters.</p>
<p>This function is typically called to compute the objective
function. It can also be called to obtain the final model
based on fitted parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>all_p_free</strong> – Vector of free parameters.</p></li>
<li><p><strong>return_models</strong> – (Optional) If True return also
individual models (default False)</p></li>
<li><p><strong>x</strong> – (Optional) array of data points on which model is
computed instead of a typical np.arange(step_nb) (default
None).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="orb.fit.FitVector.max_fev">
<code class="sig-name descname"><span class="pre">max_fev</span></code><em class="property"> <span class="pre">=</span> <span class="pre">5000</span></em><a class="headerlink" href="#orb.fit.FitVector.max_fev" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="orb.fit.FitVector.models">
<code class="sig-name descname"><span class="pre">models</span></code><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#orb.fit.FitVector.models" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="orb.fit.FitVector.models_operation">
<code class="sig-name descname"><span class="pre">models_operation</span></code><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#orb.fit.FitVector.models_operation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="orb.fit.FitVector.models_operations">
<code class="sig-name descname"><span class="pre">models_operations</span></code><em class="property"> <span class="pre">=</span> <span class="pre">['add',</span> <span class="pre">'mult']</span></em><a class="headerlink" href="#orb.fit.FitVector.models_operations" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="orb.fit.FitVector.priors_keys_list">
<code class="sig-name descname"><span class="pre">priors_keys_list</span></code><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#orb.fit.FitVector.priors_keys_list" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="orb.fit.FitVector.priors_list">
<code class="sig-name descname"><span class="pre">priors_list</span></code><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#orb.fit.FitVector.priors_list" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="orb.fit.FitVector.vector">
<code class="sig-name descname"><span class="pre">vector</span></code><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#orb.fit.FitVector.vector" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt id="orb.fit.InputParams">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">orb.fit.</span></code><code class="sig-name descname"><span class="pre">InputParams</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">step_nb</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.InputParams" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py method">
<dt id="orb.fit.InputParams.add_continuum_model">
<code class="sig-name descname"><span class="pre">add_continuum_model</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.InputParams.add_continuum_model" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="orb.fit.InputParams.add_lines_model">
<code class="sig-name descname"><span class="pre">add_lines_model</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lines</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fwhm_guess</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.InputParams.add_lines_model" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="orb.fit.InputParams.append_model">
<code class="sig-name descname"><span class="pre">append_model</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operation</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.InputParams.append_model" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="orb.fit.InputParams.check_signal_range">
<code class="sig-name descname"><span class="pre">check_signal_range</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.InputParams.check_signal_range" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="orb.fit.InputParams.clean_kwargs">
<code class="sig-name descname"><span class="pre">clean_kwargs</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">kwargs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.InputParams.clean_kwargs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="orb.fit.InputParams.convert">
<code class="sig-name descname"><span class="pre">convert</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.InputParams.convert" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert class to a pickable dict object</p>
</dd></dl>

<dl class="py method">
<dt id="orb.fit.InputParams.has_model">
<code class="sig-name descname"><span class="pre">has_model</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.InputParams.has_model" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="orb.fit.InputParams.set_signal_range">
<code class="sig-name descname"><span class="pre">set_signal_range</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rmin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rmax</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.InputParams.set_signal_range" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt id="orb.fit.LinesModel">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">orb.fit.</span></code><code class="sig-name descname"><span class="pre">LinesModel</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p_dict</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.LinesModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#orb.fit.Model" title="orb.fit.Model"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.fit.Model</span></code></a></p>
<p>Emission/absorption lines model with a channel unity in pixels.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is best seen as a basic class implemented
with more physical unities by <code class="xref py py-class docutils literal notranslate"><span class="pre">fit.Cm1LinesModel</span></code> or
<code class="xref py py-class docutils literal notranslate"><span class="pre">fit.NmLinesModel</span></code>.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Each line is built on 3 (or more) parameters : amplitude,
FWHM, position and sigma/alpha (the 4th and 5th parameters are used only for some models – see
below for details on the different models).</p>
<p>Some lines can have one or more covarying parameters: FWHM can
be the same for all the lines (this is True if lines are not
resolved), lines issued from the same ion can have the same
speed (e.g. [NII] doublet, [SII] doublet, [OIII] doublet), and
some fixed transition ratios between lines can also be set
(e.g. [NII]6584/[NII]6548 can be set to 2.89, when [NII]6548 is
likely to be really noisy).</p>
</div>
<p>Input dictionary <code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_dict</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="s1">&#39;line_nb&#39;</span><span class="p">:,</span>
 <span class="s1">&#39;fmodel&#39;</span><span class="p">:,</span>
 <span class="s1">&#39;amp_def&#39;</span><span class="p">:,</span>
 <span class="s1">&#39;pos_def&#39;</span><span class="p">:,</span>
 <span class="s1">&#39;fwhm_def&#39;</span><span class="p">:,</span>
 <span class="s1">&#39;sigma_def&#39;</span><span class="p">:,</span> <span class="c1"># only for sincgauss fmodel</span>
 <span class="s1">&#39;alpha_def&#39;</span><span class="p">:,</span> <span class="c1"># only for sincphased fmode</span>
 <span class="s1">&#39;amp_cov&#39;</span><span class="p">:,</span>
 <span class="s1">&#39;pos_cov&#39;</span><span class="p">:,</span>
 <span class="s1">&#39;fwhm_cov&#39;</span><span class="p">:,</span>
 <span class="s1">&#39;sigma_cov&#39;</span><span class="p">:,</span> <span class="c1"># only for sincgauss fmodel</span>
 <span class="s1">&#39;alpha_cov&#39;</span><span class="p">:,</span> <span class="c1"># only for sincphased fmodel</span>
 <span class="s1">&#39;amp_guess&#39;</span><span class="p">:,</span>
 <span class="s1">&#39;pos_guess&#39;</span><span class="p">:,</span>
 <span class="s1">&#39;fwhm_guess&#39;</span><span class="p">:,</span>
 <span class="s1">&#39;sigma_guess&#39;</span><span class="p">:,</span> <span class="c1"># only for sincgauss fmodel</span>
 <span class="s1">&#39;alpha_guess&#39;</span><span class="p">:}</span> <span class="c1">#  only for sincphased fmodel</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>line_nb</strong> – Number of lines.</p></li>
<li><p><strong>fmodel</strong> – Line shape, can be ‘gaussian’, ‘sinc’, ‘sinc2’ or
‘sincgauss’.</p></li>
<li><p><strong>amp_def</strong> – Definition of the amplitude parameter, can be
‘free’, ‘fixed’ or set to a label that defines its covarying
group.</p></li>
<li><p><strong>pos_def</strong> – Definition of the position parameter in pixels,
can be ‘free’, ‘fixed’ or set to a label that defines its
covarying group.</p></li>
<li><p><strong>fwhm_def</strong> – Definition of the FWHM parameter in pixels, can
be ‘free’, ‘fixed’ or set to a label that defines its covarying
group.</p></li>
<li><p><strong>sigma_def</strong> – Definition of the sigma parameter in pixels,
can be ‘free’, ‘fixed’ or set to a label that defines its
covarying group.</p></li>
<li><p><strong>amp_cov</strong> – Guess on the covariant value of the amplitude
(best set to 0 in general). There must be as many values as
covarying amplitude groups or only one value if it is the same
for all groups.</p></li>
<li><p><strong>pos_cov</strong> – Guess on the covariant value of the velocity (in
pixels). There must be as many values as covarying amplitude
groups or only one value if it is the same
for all groups.</p></li>
<li><p><strong>fwhm_cov</strong> – Guess on the covariant value of the FWHM
(best set to 0 in general). There must be as many values as
covarying amplitude groups or only one value if it is the same
for all groups.</p></li>
<li><p><strong>sigma_cov</strong> – Guess on the covariant value of sigma (best
set to 0 in general). There must be as many values as covarying
amplitude groups or only one value if it is the same for all
groups.</p></li>
<li><p><strong>amp_guess</strong> – Initial guess on the amplitude value of the
lines. Best set to a NaN in general (it can be automatically
guessed with good robusteness). But if lines have a covarying
amplitude the initial guess fixes their ratio.</p></li>
<li><p><strong>pos_guess</strong> – Initial guess on the position of the lines:
the PRECISE rest frame position must be given here, especially
if lines share a covarying position, because their relative
position will be fixed.</p></li>
<li><p><strong>fwhm_guess</strong> – Initial guess on the FWHM of the lines. This
guess must be the MOST PRECISE possible (to a few 10%), it is by
far the most unstable parameter especially for sinc lines.</p></li>
<li><p><strong>sigma_guess</strong> – Initial guess on the value of sigma. Best
set to 0. in general</p></li>
</ul>
</dd>
</dl>
<p>Example: A red spectrum containing [NII]6548, Halpha, [NII]6584,
[SII]6716 and [SII]6731, with a mean velocity of 1500 km/s (which
translates in a pixel shift of 5.5), with a fixed amplitude ratio
netween [NII] lines, the same speed for lines issued from the same
ions and a shared FWHM between everybody but Halpha would be
defined this way:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="s1">&#39;line_nb&#39;</span> <span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
 <span class="s1">&#39;amp_def&#39;</span> <span class="p">:</span> <span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;free&#39;</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;free&#39;</span><span class="p">,</span> <span class="s1">&#39;free&#39;</span><span class="p">),</span>
 <span class="s1">&#39;pos_def&#39;</span> <span class="p">:</span> <span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;3&#39;</span><span class="p">,</span> <span class="s1">&#39;3&#39;</span><span class="p">),</span> 
 <span class="s1">&#39;fwhm_def&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">),</span>
 <span class="s1">&#39;amp_cov&#39;</span><span class="p">:</span> <span class="mf">0.</span><span class="p">,</span>
 <span class="s1">&#39;pos_cov&#39;</span><span class="p">:</span> <span class="mf">5.5</span><span class="p">,</span>
 <span class="s1">&#39;fwhm_cov&#39;</span><span class="p">:</span> <span class="mf">0.</span><span class="p">,</span>
 <span class="s1">&#39;amp_guess&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mf">2.89</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">),</span> <span class="c1"># here the amplitude ratio between covarying [NII] lines is fixed.</span>
 <span class="s1">&#39;pos_guess&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">40</span><span class="p">,</span><span class="mi">60</span><span class="p">,</span><span class="mi">80</span><span class="p">,</span><span class="mi">120</span><span class="p">,</span><span class="mi">140</span><span class="p">),</span> <span class="c1"># positions are given in pixel and are purely arbitrary in this example</span>
 <span class="s1">&#39;fwhm_guess&#39;</span><span class="p">:</span> <span class="mf">2.43</span><span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Line shapes (fmodel keyword):</p>
<ul class="simple">
<li><p><strong>gaussian</strong>: A classical gaussian line shape. See <code class="xref py py-meth docutils literal notranslate"><span class="pre">cutils.gaussian1d()</span></code>.</p></li>
<li><p><strong>sinc</strong>: A pure sinc line shape, True interferometric line shape
if lines are strongly unresolved and if the interferometer has
no assymetry (generally good on SITELLE/SpIOMM low res cubes
–i.e. less than 500 steps– if the line SNR is not too high
–i.e. &lt; 50–). See <code class="xref py py-meth docutils literal notranslate"><span class="pre">cutils.sinc1d()</span></code>.</p></li>
<li><p><strong>sinc2</strong>: sinc2 = sqrt(sinc**2.). Can be used for spectra not
corrected in phase (where the absolute value of the complex
spectrum is taken).</p></li>
<li><p><strong>sincgauss</strong>: Convolution of a Gaussian (of width <strong>sigma</strong>) and
a sinc (FWHM). This line shape has a 4th parameter:
sigma. This is much closer to the true line shape, but it
takes much more time to compute because of the generally very
small value of sigma. This can be used to fit resolved lines,
like e.g. Halpha in absorption or active nucleus with broader
emission. See <code class="xref py py-meth docutils literal notranslate"><span class="pre">cutils.sincgauss1d()</span></code>.</p></li>
</ul>
</div>
<dl class="py attribute">
<dt id="orb.fit.LinesModel.accepted_keys">
<code class="sig-name descname"><span class="pre">accepted_keys</span></code><em class="property"> <span class="pre">=</span> <span class="pre">('line_nb',</span> <span class="pre">'fmodel',</span> <span class="pre">'ratio',</span> <span class="pre">'amp_def',</span> <span class="pre">'pos_def',</span> <span class="pre">'fwhm_def',</span> <span class="pre">'sigma_def',</span> <span class="pre">'alpha_def',</span> <span class="pre">'amp_cov',</span> <span class="pre">'pos_cov',</span> <span class="pre">'fwhm_cov',</span> <span class="pre">'sigma_cov',</span> <span class="pre">'alpha_cov',</span> <span class="pre">'amp_guess',</span> <span class="pre">'pos_guess',</span> <span class="pre">'fwhm_guess',</span> <span class="pre">'sigma_guess',</span> <span class="pre">'alpha_guess')</span></em><a class="headerlink" href="#orb.fit.LinesModel.accepted_keys" title="Permalink to this definition">¶</a></dt>
<dd><p>Accepted keys of the input dictionary (see
<code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_dict</span></code>)</p>
</dd></dl>

<dl class="py method">
<dt id="orb.fit.LinesModel.check_input">
<code class="sig-name descname"><span class="pre">check_input</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.LinesModel.check_input" title="Permalink to this definition">¶</a></dt>
<dd><p>Check input parameters</p>
</dd></dl>

<dl class="py method">
<dt id="orb.fit.LinesModel.get_model">
<code class="sig-name descname"><span class="pre">get_model</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_free</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_models</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">multf</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_complex</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.LinesModel.get_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Return model M(x, p).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> – Positions where the model M(x, p) is computed.</p></li>
<li><p><strong>p_free</strong> – (Optional) New values of the free parameters
(default None).</p></li>
<li><p><strong>multf</strong> – 1d vector with the same length as x vector which
represent the function by which the model must be multiplied.</p></li>
<li><p><strong>return_models</strong> – (Optional) If True return also
individual models (default False)</p></li>
<li><p><strong>return_complex</strong> – (Optional) If True return a complex model.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.fit.LinesModel.get_p_val_as_array">
<code class="sig-name descname"><span class="pre">get_p_val_as_array</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p_val</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.LinesModel.get_p_val_as_array" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="orb.fit.LinesModel.get_priors">
<code class="sig-name descname"><span class="pre">get_priors</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.LinesModel.get_priors" title="Permalink to this definition">¶</a></dt>
<dd><p>Return priors. Replace gaussian distribution by lognormal
distribution for some parameters.</p>
</dd></dl>

<dl class="py attribute">
<dt id="orb.fit.LinesModel.log_param_keys">
<code class="sig-name descname"><span class="pre">log_param_keys</span></code><em class="property"> <span class="pre">=</span> <span class="pre">['fwhm',</span> <span class="pre">'sigma']</span></em><a class="headerlink" href="#orb.fit.LinesModel.log_param_keys" title="Permalink to this definition">¶</a></dt>
<dd><p>Parameter keys that have a lognormal distribution</p>
</dd></dl>

<dl class="py method">
<dt id="orb.fit.LinesModel.make_guess">
<code class="sig-name descname"><span class="pre">make_guess</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.LinesModel.make_guess" title="Permalink to this definition">¶</a></dt>
<dd><p>If a parameter value at init is a NaN this value is guessed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> – Data vector from which the guess is made.</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="orb.fit.LinesModel.p_array">
<code class="sig-name descname"><span class="pre">p_array</span></code><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#orb.fit.LinesModel.p_array" title="Permalink to this definition">¶</a></dt>
<dd><p>equivalent of <code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_val</span></code> but presented as an
array with each row corresponding to a line which is easier to
handle.</p>
</dd></dl>

<dl class="py attribute">
<dt id="orb.fit.LinesModel.param_keys">
<code class="sig-name descname"><span class="pre">param_keys</span></code><em class="property"> <span class="pre">=</span> <span class="pre">['amp',</span> <span class="pre">'pos',</span> <span class="pre">'fwhm',</span> <span class="pre">'sigma',</span> <span class="pre">'alpha']</span></em><a class="headerlink" href="#orb.fit.LinesModel.param_keys" title="Permalink to this definition">¶</a></dt>
<dd><p>Parameter keys</p>
</dd></dl>

<dl class="py method">
<dt id="orb.fit.LinesModel.parse_dict">
<code class="sig-name descname"><span class="pre">parse_dict</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.LinesModel.parse_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse input dictionary <code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_dict</span></code></p>
</dd></dl>

<dl class="py attribute">
<dt id="orb.fit.LinesModel.same_param_keys">
<code class="sig-name descname"><span class="pre">same_param_keys</span></code><em class="property"> <span class="pre">=</span> <span class="pre">['fwhm',</span> <span class="pre">'sigma']</span></em><a class="headerlink" href="#orb.fit.LinesModel.same_param_keys" title="Permalink to this definition">¶</a></dt>
<dd><p>Parameter keys which must be the same if covarying</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="orb.fit.Model">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">orb.fit.</span></code><code class="sig-name descname"><span class="pre">Model</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p_dict</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.Model" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Template class for fit models. This class cannot be used directly.</p>
<p>The main purpose of a Model class is to output a model given a set
of parameters.</p>
<p>Methods that must be implemented by real classes:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">fit.Model.parse_dict()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">fit.Model.check_input()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">fit.Model.make_guess()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">fit.Model.get_model()</span></code></p></li>
</ul>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A model is computed from a given set of parameters
stored in <code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_val</span></code>. From this set some
parameters are <strong>free</strong>, some are <strong>fixed</strong> and some are
<strong>covarying</strong>, i.e. the value of a subset of parameters can be
computed from 1 free parameter.</p>
<p>Taking the definition of the parameters (free, fixed or
covarying, stored in <code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_def</span></code>) into account,
the reduced free parameter set is stored in
<code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_free</span></code>, the reduced set of fixed parameters
is stored in <code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_fixed</span></code>, the set of covarying
parameters is stored in <code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_cov</span></code> and when the
model needs to be computed, the full set of model parameters
(<code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_val</span></code>) is computed again from set.p_free`,
<code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_fixed</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_cov</span></code> and
<code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_def</span></code>.</p>
<p>A group of covarying parameters is defined by the same label. If
<code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_def</span></code> is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="s1">&#39;free&#39;</span><span class="p">,</span> <span class="s1">&#39;fixed&#39;</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="s1">&#39;free&#39;</span><span class="p">,</span> <span class="s1">&#39;fixed&#39;</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="s1">&#39;free&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>It means that we have 3 free parameters, 2 fixed parameters and
2 groups of covarying parameters. The first group contains 2
parameters and the second group contains 3 parameters. In this
case the real number of free parameters will be 3 + 2 (one free
parameter for each group of covarying parameters) = 5 and the
real number of fixed parameters will be 2 + 5 (one fixed
parameter for each covarying parameters) = 7.</p>
<p>A Model class works this way :</p>
<ol class="arabic simple">
<li><p>Init: the dictionary defining the parameters (free, fixed,
covarying) and their values is parsed with
<code class="xref py py-meth docutils literal notranslate"><span class="pre">fit.Model.parse_dict()</span></code>: <code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_def</span></code>,
<code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_val</span></code> and <code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_cov</span></code> are
created. Then <code class="xref py py-meth docutils literal notranslate"><span class="pre">fit.Model.val2free()</span></code> is called to
create <code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_free</span></code> and
<code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_fixed</span></code>.</p></li>
<li><p>the set of free parameters can then be changed with
<code class="xref py py-meth docutils literal notranslate"><span class="pre">fit.Model.set_p_free()</span></code> before calling
<code class="xref py py-meth docutils literal notranslate"><span class="pre">fit.Model.get_model()</span></code>. the updated values of
<code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_val</span></code> are computed before the model is created via
<code class="xref py py-meth docutils literal notranslate"><span class="pre">fit.Model.free2val()</span></code>. A new set of free parameters
can also be passed to <code class="xref py py-meth docutils literal notranslate"><span class="pre">fit.Model.get_model()</span></code>.</p></li>
</ol>
</div>
<dl class="py attribute">
<dt id="orb.fit.Model.accepted_keys">
<code class="sig-name descname"><span class="pre">accepted_keys</span></code><em class="property"> <span class="pre">=</span> <span class="pre">()</span></em><a class="headerlink" href="#orb.fit.Model.accepted_keys" title="Permalink to this definition">¶</a></dt>
<dd><p>Accepted keys of the input dictionary (see
<code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_dict</span></code>)</p>
</dd></dl>

<dl class="py method">
<dt id="orb.fit.Model.check_input">
<code class="sig-name descname"><span class="pre">check_input</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.Model.check_input" title="Permalink to this definition">¶</a></dt>
<dd><p>Check input parameters</p>
</dd></dl>

<dl class="py method">
<dt id="orb.fit.Model.free2val">
<code class="sig-name descname"><span class="pre">free2val</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.Model.free2val" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the array of parameters definition
<code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_def</span></code> and update the parameter values
based on the new set of free parameters
<code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_free</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt id="orb.fit.Model.get_model">
<code class="sig-name descname"><span class="pre">get_model</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_models</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_complex</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.Model.get_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute a model M(x, p) for all passed x positions. p are
the parameter values stored in <code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_val</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> – Positions where the model M(x, p) is computed.</p></li>
<li><p><strong>return_models</strong> – (Optional) If True return also
individual models (default False)</p></li>
<li><p><strong>return_complex</strong> – (Optional) If True return a complex
model (default False).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.fit.Model.get_p_free">
<code class="sig-name descname"><span class="pre">get_p_free</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.Model.get_p_free" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the vector of free parameters <code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_free</span></code></p>
</dd></dl>

<dl class="py method">
<dt id="orb.fit.Model.get_p_val">
<code class="sig-name descname"><span class="pre">get_p_val</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.Model.get_p_val" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_val</span></code></p>
</dd></dl>

<dl class="py method">
<dt id="orb.fit.Model.get_priors">
<code class="sig-name descname"><span class="pre">get_priors</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.Model.get_priors" title="Permalink to this definition">¶</a></dt>
<dd><p>Return priors</p>
</dd></dl>

<dl class="py method">
<dt id="orb.fit.Model.make_guess">
<code class="sig-name descname"><span class="pre">make_guess</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.Model.make_guess" title="Permalink to this definition">¶</a></dt>
<dd><p>If a parameter value at init is a NaN this value is guessed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> – Data vector from which the guess is made.</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="orb.fit.Model.p_cov">
<code class="sig-name descname"><span class="pre">p_cov</span></code><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#orb.fit.Model.p_cov" title="Permalink to this definition">¶</a></dt>
<dd><p>dict that stores the groups of covarying parameters by label
and their associated value and covarying operation (a pointer to a
function), i.e.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{[</span><span class="s1">&#39;cov_label_1&#39;</span><span class="p">:</span> <span class="p">(</span><span class="n">value1</span><span class="p">,</span> <span class="n">cov_operation1</span><span class="p">)],</span>
 <span class="p">[</span><span class="s1">&#39;cov_label_2&#39;</span><span class="p">:</span> <span class="p">(</span><span class="n">value2</span><span class="p">,</span> <span class="n">cov_operation2</span><span class="p">)],</span>
 <span class="o">...</span><span class="p">}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="orb.fit.Model.p_def">
<code class="sig-name descname"><span class="pre">p_def</span></code><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#orb.fit.Model.p_def" title="Permalink to this definition">¶</a></dt>
<dd><p>Definition the full set of parameters (fixed, free or
covarying). This array as the same shape as <code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_val</span></code></p>
</dd></dl>

<dl class="py attribute">
<dt id="orb.fit.Model.p_dict">
<code class="sig-name descname"><span class="pre">p_dict</span></code><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#orb.fit.Model.p_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Input dictionary defining the parameters. Contains the initial
values of the parameters</p>
</dd></dl>

<dl class="py attribute">
<dt id="orb.fit.Model.p_fixed">
<code class="sig-name descname"><span class="pre">p_fixed</span></code><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#orb.fit.Model.p_fixed" title="Permalink to this definition">¶</a></dt>
<dd><p>Array of fixed parameters. Each covarying parameter is stored
as fixed. And one free parameter is added for each group of
covarying parameters.</p>
</dd></dl>

<dl class="py attribute">
<dt id="orb.fit.Model.p_free">
<code class="sig-name descname"><span class="pre">p_free</span></code><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#orb.fit.Model.p_free" title="Permalink to this definition">¶</a></dt>
<dd><p>Up to date value of the free parameters. Its size is always
less or equal to the size of the full set of parameters used
directly to compute the model. It reflects the real number of
fitted parameters. For each group of covarying parameters one free
parameter is added.</p>
</dd></dl>

<dl class="py attribute">
<dt id="orb.fit.Model.p_val">
<code class="sig-name descname"><span class="pre">p_val</span></code><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#orb.fit.Model.p_val" title="Permalink to this definition">¶</a></dt>
<dd><p>Up to date values of the full set of parameters used by the model
(initial guess before fit, fitted value after fit). This array as
the same shape as <code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_def</span></code>. It does not reflect the real number
of fitted parameters.</p>
</dd></dl>

<dl class="py method">
<dt id="orb.fit.Model.parse_dict">
<code class="sig-name descname"><span class="pre">parse_dict</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.Model.parse_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse input dictionary to create <code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_def</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_val</span></code> and
<code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_cov</span></code></p>
</dd></dl>

<dl class="py method">
<dt id="orb.fit.Model.set_p_free">
<code class="sig-name descname"><span class="pre">set_p_free</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p_free</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.Model.set_p_free" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the vector of free parameters <code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_free</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>p_free</strong> – New vector of free parameters</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.fit.Model.set_p_val">
<code class="sig-name descname"><span class="pre">set_p_val</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p_val</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.Model.set_p_val" title="Permalink to this definition">¶</a></dt>
<dd><p>Set <code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_val</span></code></p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This method is used to bypass all the initialized
parameters and reuse an already initialized model with
another full set of parameters. Note that you might want to
call <code class="xref py py-meth docutils literal notranslate"><span class="pre">fit.Model.get_model()</span></code> directly after this
method because any call to <code class="xref py py-meth docutils literal notranslate"><span class="pre">fit.Model.set_p_free()</span></code>
or <code class="xref py py-meth docutils literal notranslate"><span class="pre">fit.Model.free2val()</span></code> will recompute
<code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_val</span></code> from the init values and the
actual <code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_free</span></code>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>p_val</strong> – New full set of parameters.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.fit.Model.val2free">
<code class="sig-name descname"><span class="pre">val2free</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.Model.val2free" title="Permalink to this definition">¶</a></dt>
<dd><p>Recompute the set of free parameters
<code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_free</span></code> with the updated values of
<code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_val</span></code></p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="orb.fit.NmLinesModel">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">orb.fit.</span></code><code class="sig-name descname"><span class="pre">NmLinesModel</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p_dict</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.NmLinesModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#orb.fit.Cm1LinesModel" title="orb.fit.Cm1LinesModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.fit.Cm1LinesModel</span></code></a></p>
<p>Emission/absorption lines model with a channel unity in nm.</p>
<p>Reimplements <code class="xref py py-class docutils literal notranslate"><span class="pre">fit.Cm1LinesModel</span></code> to use nm instead of
cm-1. Channels are translated to cm-1 and velocity to km/s in
input and output.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>For more information please refer to
<code class="xref py py-class docutils literal notranslate"><span class="pre">fit.Cm1LinesModel</span></code> and <code class="xref py py-class docutils literal notranslate"><span class="pre">fit.LinesModel</span></code></p>
</div>
<dl class="py method">
<dt id="orb.fit.NmLinesModel.parse_dict">
<code class="sig-name descname"><span class="pre">parse_dict</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.NmLinesModel.parse_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse input dictionary <code class="xref py py-attr docutils literal notranslate"><span class="pre">fit.Model.p_dict</span></code></p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="orb.fit.OutputParams">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">orb.fit.</span></code><code class="sig-name descname"><span class="pre">OutputParams</span></code><a class="headerlink" href="#orb.fit.OutputParams" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#orb.fit.Params" title="orb.fit.Params"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.fit.Params</span></code></a></p>
<dl class="py method">
<dt id="orb.fit.OutputParams.convert">
<code class="sig-name descname"><span class="pre">convert</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.OutputParams.convert" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert class to a raw pickable format</p>
</dd></dl>

<dl class="py method">
<dt id="orb.fit.OutputParams.get_axis">
<code class="sig-name descname"><span class="pre">get_axis</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.OutputParams.get_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the axis of the fitted spectrum</p>
</dd></dl>

<dl class="py method">
<dt id="orb.fit.OutputParams.get_params">
<code class="sig-name descname"><span class="pre">get_params</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.OutputParams.get_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Return basic parameters of the fitted spectrum</p>
</dd></dl>

<dl class="py method">
<dt id="orb.fit.OutputParams.get_residual">
<code class="sig-name descname"><span class="pre">get_residual</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.OutputParams.get_residual" title="Permalink to this definition">¶</a></dt>
<dd><p>Return fit residual</p>
</dd></dl>

<dl class="py method">
<dt id="orb.fit.OutputParams.get_spectrum">
<code class="sig-name descname"><span class="pre">get_spectrum</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.OutputParams.get_spectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Return fitted spectrum</p>
</dd></dl>

<dl class="py method">
<dt id="orb.fit.OutputParams.plot">
<code class="sig-name descname"><span class="pre">plot</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.OutputParams.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot fitted spectrum. Convenient wrapper around pyplot.plot() function</p>
</dd></dl>

<dl class="py method">
<dt id="orb.fit.OutputParams.plot_residual">
<code class="sig-name descname"><span class="pre">plot_residual</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.OutputParams.plot_residual" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot residual. Convenient wrapper around pyplot.plot() function</p>
</dd></dl>

<dl class="py method">
<dt id="orb.fit.OutputParams.translate">
<code class="sig-name descname"><span class="pre">translate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inputparams</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fitvector</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nogvar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.OutputParams.translate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt id="orb.fit.Params">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">orb.fit.</span></code><code class="sig-name descname"><span class="pre">Params</span></code><a class="headerlink" href="#orb.fit.Params" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#orb.core.Params" title="orb.core.Params"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.core.Params</span></code></a></p>
<p>Manage a set of parameters as a special dictionary which
elements can be accessed like attributes.</p>
</dd></dl>

<dl class="py function">
<dt id="orb.fit.create_cm1_lines_model">
<code class="sig-prename descclassname"><span class="pre">orb.fit.</span></code><code class="sig-name descname"><span class="pre">create_cm1_lines_model</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lines_cm1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">amp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resolution</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fmodel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sincgauss'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ratio</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.25</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.create_cm1_lines_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a simple emission-line spectrum model in cm-1</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lines</strong> – lines in cm-1</p></li>
<li><p><strong>amp</strong> – Amplitude (must have the same size as lines)</p></li>
<li><p><strong>step</strong> – Step size</p></li>
<li><p><strong>order</strong> – Folding order</p></li>
<li><p><strong>resolution</strong> – Resolution of the spectrum</p></li>
<li><p><strong>theta</strong> – Incident angle</p></li>
<li><p><strong>vel</strong> – (Optional) Global velocity shift applied to all the
lines (in km/s, default 0.)</p></li>
<li><p><strong>sigma</strong> – (Optional) Line broadening (in km/s, default 0.)</p></li>
<li><p><strong>alpha</strong> – (Optional) Phase coefficient of the lines (default
0.)</p></li>
<li><p><strong>fmodel</strong> – (Optional) Lines model. Can be ‘gaussian’, ‘sinc’,
‘sincgauss’, ‘sincphased’, ‘sincgaussphased’ (default sincgauss).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.fit.create_cm1_lines_model_raw">
<code class="sig-prename descclassname"><span class="pre">orb.fit.</span></code><code class="sig-name descname"><span class="pre">create_cm1_lines_model_raw</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lines_cm1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">amp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step_nb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">corr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zpd_index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fmodel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sinc'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.create_cm1_lines_model_raw" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a simple emission-line spectrum model in cm-1 from raw
parameters. For more physical parameters use
create_cm1_lines_model().</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lines_cm1</strong> – lines in cm-1</p></li>
<li><p><strong>amp</strong> – Amplitude (must have the same size as lines)</p></li>
<li><p><strong>step</strong> – Step size</p></li>
<li><p><strong>order</strong> – Folding order</p></li>
<li><p><strong>step_nb</strong> – Total numer of steps</p></li>
<li><p><strong>corr</strong> – calibration coeff.</p></li>
<li><p><strong>zpd_index</strong> – ZPD index.</p></li>
<li><p><strong>vel</strong> – (Optional) Global velocity shift applied to all the
lines (in km/s, default 0.)</p></li>
<li><p><strong>sigma</strong> – (Optional) Line broadening (in km/s, default 0.)</p></li>
<li><p><strong>alpha</strong> – (Optional) Phase coefficient of the lines (default
0.)</p></li>
<li><p><strong>fmodel</strong> – (Optional) Lines model. Can be ‘gaussian’, ‘sinc’,
‘sincgauss’, ‘sincphased’, ‘sincgaussphased’ (default sincgauss).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.fit.create_lines_model">
<code class="sig-prename descclassname"><span class="pre">orb.fit.</span></code><code class="sig-name descname"><span class="pre">create_lines_model</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lines</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">amp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fwhm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step_nb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">line_shift</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fmodel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sincgauss'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.create_lines_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a simple emission-line spectrum model with no physical units.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lines</strong> – lines channels.</p></li>
<li><p><strong>amp</strong> – Amplitude (must have the same size as lines).</p></li>
<li><p><strong>fwhm</strong> – lines FWHM (in channels).</p></li>
<li><p><strong>step_nb</strong> – Number of steps of the spectrum.</p></li>
<li><p><strong>line_shift</strong> – (Optional) Global shift applied to all the
lines (in channels, default 0.)</p></li>
<li><p><strong>sigma</strong> – (Optional) Sigma of the lines (in channels, default
0.)</p></li>
<li><p><strong>alpha</strong> – (Optional) Phase coefficient of the lines (default
0.)</p></li>
<li><p><strong>fmodel</strong> – (Optional) Lines model. Can be ‘gaussian’, ‘sinc’,
‘sincgauss’, ‘sincphased’, ‘sincgaussphased’ (default sincgauss).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.fit.fit_lines_in_spectrum">
<code class="sig-prename descclassname"><span class="pre">orb.fit.</span></code><code class="sig-name descname"><span class="pre">fit_lines_in_spectrum</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">spectrum</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lines</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nm_laser</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zpd_index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wavenumber</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">apodization</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">velocity_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">compute_mcmc_error</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.fit_lines_in_spectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit lines in spectrum</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>If spectrum is in wavenumber (option wavenumber set
to True) input and output unit will be in cm-1. If spectrum is
in wavelength (option wavenumber set to False) input and output
unit will be in nm.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>spectrum</strong> – Spectrum to fit</p></li>
<li><p><strong>lines</strong> – Positions of the lines in nm/cm-1</p></li>
<li><p><strong>step</strong> – Step size in nm</p></li>
<li><p><strong>order</strong> – Folding order</p></li>
<li><p><strong>nm_laser</strong> – Calibration laser wavelength in nm.</p></li>
<li><p><strong>theta_proj</strong> – Projected incident angle of the spectrum in
degrees.</p></li>
<li><p><strong>zpd_index</strong> – Index of the ZPD in the interferogram.</p></li>
<li><p><strong>apodization</strong> – (Optional) Apodization level. Permit to separate the
broadening due to the apodization and the real line broadening
(see ‘broadening’ output parameter, default 1.).</p></li>
<li><p><strong>fit_tol</strong> – (Optional) Tolerance on the fit value (default
1e-10).</p></li>
<li><p><strong>filter_name</strong> – (Optional) Filter file path (default
None).</p></li>
<li><p><strong>velocity_range</strong> – (Optional) Range of velocity to check
around the shift_guess value. If not None, a brute force
algorithm is used to find the best velocity value. If more than
one shift_guess is given (e.g. if lines are have different
velocities, the mean velocity will be used as an initial
velocity guess). The quality of this guess depends strongly on
the spectrum noise. Try avoid using it with low a SNR spectrum.</p></li>
<li><p><strong>compute_mcmc_error</strong> – (Optional) If True, uncertainty
estimates are computed from a Markov chain Monte-Carlo
algorithm. If the estimates can be better constrained, the
fitting time is orders of magnitude longer (default False).</p></li>
<li><p><strong>max_iter</strong> – (Optional) Maximum number of iterations (default None)</p></li>
<li><p><strong>kwargs</strong> – (Optional) Fitting parameters of
<code class="xref py py-class docutils literal notranslate"><span class="pre">orb.fit.Cm1LinesInput</span></code> or
<a class="reference internal" href="#orb.fit.FitVector" title="orb.fit.FitVector"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.fit.FitVector</span></code></a>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p>a dictionary containing:</p>
<ul class="simple">
<li><p>all the fit parameters [key: ‘fit_params’]</p></li>
<li><p>lines parameters [key: ‘lines_params’] Lines parameters are
given as an array of shape (lines_nb, 5). The order of the 5
parameters for each lines is [height at the center of the
line, amplitude, position, fwhm, sigma]. Position and FWHM are given
in nm/cm-1 depending on the input unit (i.e. nm if wavenumber
is False and cm-1 if wavenumber is True)</p></li>
<li><p>lines parameters errors [key: ‘lines_params_err’]</p></li>
<li><p>velocity [key: ‘velocity’] Velocity of the lines in km/s</p></li>
<li><p>velocity error [key: ‘velocity_err’] Error on the velocity of
the lines in km/s</p></li>
<li><p>residual [key: ‘residual’]</p></li>
<li><p>chi-square [key: ‘chi2’]</p></li>
<li><p>reduced chi-square [key: ‘rchi2’]</p></li>
<li><p>SNR [key: ‘snr’]</p></li>
<li><p>continuum parameters [key: ‘cont_params’]</p></li>
<li><p>fitted spectrum [key: ‘fitted_vector’]</p></li>
<li><p>log(Gaussian Bayes Factor) [key: ‘logGBF’]</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="orb.fit.fit_lines_in_vector">
<code class="sig-prename descclassname"><span class="pre">orb.fit.</span></code><code class="sig-name descname"><span class="pre">fit_lines_in_vector</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vector</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lines</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fwhm_guess</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">compute_mcmc_error</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.fit.fit_lines_in_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit lines in a vector</p>
<p>Use this function only if little is known about the vector. A
vector resulting from an interferogram FFT is assumed :
i.e. regular axis, symmetrical line shape.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>All position units are in channels</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vector</strong> – vector to fit</p></li>
<li><p><strong>lines</strong> – Positions of the lines in channels</p></li>
<li><p><strong>fwhm_guess</strong> – Initial guess on the lines FWHM (in channels).</p></li>
<li><p><strong>fit_tol</strong> – (Optional) Tolerance on the fit value (default
1e-10).</p></li>
<li><p><strong>compute_mcmc_error</strong> – (Optional) If True, uncertainty
estimates are computed from a Markov chain Monte-Carlo
algorithm. If the estimates can be better constrained, the
fitting time is orders of magnitude longer (default False).</p></li>
<li><p><strong>max_iter</strong> – (Optional) Maximum number of iterations (default None)</p></li>
<li><p><strong>kwargs</strong> – (Optional) Fitting parameters of
<code class="xref py py-class docutils literal notranslate"><span class="pre">orb.fit.LinesInput</span></code> or
<a class="reference internal" href="#orb.fit.FitVector" title="orb.fit.FitVector"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.fit.FitVector</span></code></a>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p>a dictionary containing:</p>
<ul class="simple">
<li><p>all the fit parameters [key: ‘fit_params’]</p></li>
<li><p>lines parameters [key: ‘lines_params’] Lines parameters are
given as an array of shape (lines_nb, 5). The order of the 5
parameters for each lines is [height at the center of the
line, amplitude, position, fwhm, sigma]. Postion and FWHM are given
in channels.</p></li>
<li><p>lines parameters errors [key: ‘lines_params_err’]</p></li>
<li><p>residual [key: ‘residual’]</p></li>
<li><p>chi-square [key: ‘chi2’]</p></li>
<li><p>reduced chi-square [key: ‘rchi2’]</p></li>
<li><p>SNR [key: ‘snr’]</p></li>
<li><p>continuum parameters [key: ‘cont_params’]</p></li>
<li><p>fitted spectrum [key: ‘fitted_vector’]</p></li>
<li><p>log(Gaussian Bayes Factor) [key: ‘logGBF’]</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-orb.image">
<span id="orb-image-module"></span><h2>orb.image module<a class="headerlink" href="#module-orb.image" title="Permalink to this headline">¶</a></h2>
<p>The Image module is aimed to manage image class</p>
<dl class="py class">
<dt id="orb.image.Frame2D">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">orb.image.</span></code><code class="sig-name descname"><span class="pre">Frame2D</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.image.Frame2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#orb.core.WCSData" title="orb.core.WCSData"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.core.WCSData</span></code></a></p>
<dl class="py method">
<dt id="orb.image.Frame2D.crop">
<code class="sig-name descname"><span class="pre">crop</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cy</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_cutout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.image.Frame2D.crop" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a portion of the image as another Frame2D instance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cx</strong> – X center position</p></li>
<li><p><strong>cy</strong> – Y center position</p></li>
<li><p><strong>size</strong> – Size of the cropped rectangle. A tuple (sz,
sy). Can be single int in which case the cropped data is a
box.</p></li>
<li><p><strong>return_cutout</strong> – If True return only the cutout, not a
new image object (default False).</p></li>
</ul>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>size of the returned box is not guaranteed if cx
and cy are on the border of the image.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="orb.image.Frame2D.get_stats">
<code class="sig-name descname"><span class="pre">get_stats</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fast</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.image.Frame2D.get_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>Return image stats</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>fast</strong> – If fast, only a random fraction of the image is
used to make stats.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>mean, median, std</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.image.Frame2D.imshow">
<code class="sig-name descname"><span class="pre">imshow</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">wcs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.image.Frame2D.imshow" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenient image plotting function</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>figsize</strong> – size of the figure (same as pyplot.figure’s figsize keyword)</p></li>
<li><p><strong>wcs</strong> – if True, display wcs coordinates. Else, pixel coordinates are shown.</p></li>
</ul>
</dd>
<dt class="field-even">Params kwargs</dt>
<dd class="field-even"><p>other kwargs of orb.utils.graph.imshow()</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="orb.image.Image">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">orb.image.</span></code><code class="sig-name descname"><span class="pre">Image</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.image.Image" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#orb.image.Frame2D" title="orb.image.Frame2D"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.image.Frame2D</span></code></a></p>
<dl class="py attribute">
<dt id="orb.image.Image.BOX_SIZE_COEFF">
<code class="sig-name descname"><span class="pre">BOX_SIZE_COEFF</span></code><em class="property"> <span class="pre">=</span> <span class="pre">7</span></em><a class="headerlink" href="#orb.image.Image.BOX_SIZE_COEFF" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="orb.image.Image.DETECT_INDEX">
<code class="sig-name descname"><span class="pre">DETECT_INDEX</span></code><em class="property"> <span class="pre">=</span> <span class="pre">0</span></em><a class="headerlink" href="#orb.image.Image.DETECT_INDEX" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="orb.image.Image.FIT_TOL">
<code class="sig-name descname"><span class="pre">FIT_TOL</span></code><em class="property"> <span class="pre">=</span> <span class="pre">0.01</span></em><a class="headerlink" href="#orb.image.Image.FIT_TOL" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="orb.image.Image.REDUCED_CHISQ_LIMIT">
<code class="sig-name descname"><span class="pre">REDUCED_CHISQ_LIMIT</span></code><em class="property"> <span class="pre">=</span> <span class="pre">1.5</span></em><a class="headerlink" href="#orb.image.Image.REDUCED_CHISQ_LIMIT" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="orb.image.Image.aperture_photometry">
<code class="sig-name descname"><span class="pre">aperture_photometry</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">star_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">aper_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">silent</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.image.Image.aperture_photometry" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform aperture photometry.</p>
<p>Based on photutils.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>star_list</strong> – May be an array (n, 2) or a path to a star</p>
</dd>
</dl>
<p>list file created with detect_stars()</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>aper_coeff</strong> – (Optional) Aperture coefficient (default
3.) Aperture = aper_coeff * fwhm.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.image.Image.compute_alignment_parameters">
<code class="sig-name descname"><span class="pre">compute_alignment_parameters</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xy_range</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r_range</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">correct_distortion</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">star_list1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fwhm_arc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">brute_force</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coeffs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">1)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">skip_check</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.image.Image.compute_alignment_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the alignment coefficients that match the stars of this
image to the stars of the image 2.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image2</strong> – Image instance.</p></li>
<li><p><strong>xy_range</strong> – Range of x, y values to brute force around
the initial parameters passed in coeffs. if two ranges are
given (e.g. (np.linspace(-5,5,10), np.linspace(-1,1,10))) a
second brute force pass is done centered on the values of
the first pass.</p></li>
<li><p><strong>r_range</strong> – Range of angles to brute force around the
initial parameters passed in coeffs. if two ranges are given
(e.g. (np.linspace(-5,5,10), np.linspace(-1,1,10))) a second
brute force pass is done centered on the values of the first
pass.</p></li>
<li><p><strong>correct_distortion</strong> – (Optional) If True, a SIP is computed to
match stars from frame 2 onto the stars from frame 1. But it
needs a lot of stars to run correctly (default False).</p></li>
<li><p><strong>star_list1</strong> – (Optional) Path to a list of stars in the
cube. If given the fwhm_arc must also be set (default None).</p></li>
<li><p><strong>fwhm_arc</strong> – (Optional) mean FWHM of the stars in
arcseconds. Must be given if star_list1 is not None
(default None).</p></li>
<li><p><strong>brute_force</strong> – (Optional) If True the first step is a
brute force guess. This is very useful if the initial
parameters are not well known (default True).</p></li>
<li><p><strong>coeffs</strong> – (Optional) initial alignement parameters (dx,
dy, dr, da, db, zoom). If aligning camera 2 on camera 1,
use self.get_initial_alignment_parameters() to set coeffs.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The alignement coefficients are:</p>
<ul class="simple">
<li><p>dx : shift along x axis in pixels</p></li>
<li><p>dy : shift along y axis in pixels</p></li>
<li><p>dr : rotation angle between images (the center of rotation
is the center of the images of the camera 1) in degrees</p></li>
<li><p>da : tip angle between cameras (along x axis) in degrees</p></li>
<li><p>db : tilt angle between cameras (along y axis) in degrees</p></li>
</ul>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The process tries to find the stars detected in the camera A in the frame of the camera B. It goes through 2 steps:</p>
<ol class="arabic simple">
<li><p>Rough alignment (brute force style) only looking over
dx, dy. dr is kept to its initial value (init_angle), da
and db are set to 0.</p></li>
<li><p>Fine alignment pass.</p></li>
</ol>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This alignment process do not work if the initial
parameters are too far from the real value. The angle must
be known within a few degrees. The shift must be known
within 4 % of the frame size (The latter can be changed
using the SIZE_COEFF constant)</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="orb.image.Image.compute_panstarrs_photometry">
<code class="sig-name descname"><span class="pre">compute_panstarrs_photometry</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">star_number</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_xmatch_radius</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_roundness</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">modulated</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">calibrated</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.image.Image.compute_panstarrs_photometry" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="orb.image.Image.copy">
<code class="sig-name descname"><span class="pre">copy</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.image.Image.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of the instance</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>data</strong> – (Optional) can be used to change data</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.image.Image.detect_fwhm">
<code class="sig-name descname"><span class="pre">detect_fwhm</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">star_list</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.image.Image.detect_fwhm" title="Permalink to this definition">¶</a></dt>
<dd><p>Return fwhm of a list of stars (in pixels)</p>
<p>can be converted to arcseconds with self.pix2arc()</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>star_list</strong> – list of stars (can be an np.ndarray or a path
to a star list).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.image.Image.detect_stars">
<code class="sig-name descname"><span class="pre">detect_stars</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">min_star_number</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">30</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_roundness</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_radius_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">saturation_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_background</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.image.Image.detect_stars" title="Permalink to this definition">¶</a></dt>
<dd><p>Detect star positions in data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>min_star_number</strong> – Minimum number of stars to
detect. Must be greater or equal to 4 (minimum star number
for any alignment process). this is also the number of stars
returned (sorted by intensity)</p></li>
<li><p><strong>path</strong> – (Optional) Path to the output star list file. If
None, nothing is written.</p></li>
<li><p><strong>saturation_threshold</strong> – (Optional) reject stars higher
than this threshold. Can be a float, False or None. If
False: saturation_threshold is set to 99.9th percentile. If
None (default) it is set to 0.45 * 99.9th percentile to
avoid selecting stars which will saturate at ZPD.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.image.Image.detrend">
<code class="sig-name descname"><span class="pre">detrend</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bias</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dark</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flat</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cr_map</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.image.Image.detrend" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a detrended image</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bias</strong> – Master bias</p></li>
<li><p><strong>dark</strong> – Master dark (must be in counts/s)</p></li>
<li><p><strong>flat</strong> – Master flat</p></li>
<li><p><strong>shift</strong> – shift correction (dx, dy)</p></li>
<li><p><strong>cr_map</strong> – A map of cosmic rays with boolean type: 1 = CR, 0 = NO_CR</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.image.Image.find_object">
<code class="sig-name descname"><span class="pre">find_object</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">is_standard</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_radec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optimize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.image.Image.find_object" title="Permalink to this definition">¶</a></dt>
<dd><p>Try to find the object given the name in the header</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>is_standard</strong> – if object is a standard, do not try to
resolve the name.</p></li>
<li><p><strong>return_radec</strong> – if true, radec coordinates are retruned
instead of image coordinates (pixel position).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.image.Image.fit_sip">
<code class="sig-name descname"><span class="pre">fit_sip</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">star_list1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">star_list2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_sip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">err</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sip_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">crpix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">crval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.image.Image.fit_sip" title="Permalink to this definition">¶</a></dt>
<dd><p>FIT the distortion correction polynomial to match two lists
of stars (the list of stars 2 is distorded to match the list
of stars 1).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>star_list1</strong> – list of stars 1</p></li>
<li><p><strong>star_list2</strong> – list of stars 2</p></li>
<li><p><strong>params</strong> – (Optional) Transformation parameter to go from
the list of stars 1 to the list of stars 2. Must be a tuple
[dx, dy, dr, da, db, rcx, rcy, zoom_factor] (default None).</p></li>
<li><p><strong>init_sip</strong> – (Optional) Initial SIP (an astropy.wcs.WCS object,
default None)</p></li>
<li><p><strong>err</strong> – (Optional) error on the star positions of the star
list 2 (default None).</p></li>
<li><p><strong>sip_order</strong> – (Optional) SIP order (default 2).</p></li>
<li><p><strong>crpix</strong> – (Optional) If an initial wcs is not given (init_sip
set to None) this header value must be given.</p></li>
<li><p><strong>crval</strong> – (Optional) If an initial wcs is not given (init_sip
set to None) this header value must be given.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.image.Image.fit_stars">
<code class="sig-name descname"><span class="pre">fit_stars</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">star_list</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.image.Image.fit_stars" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit stars in one frame.</p>
<p>This function is basically a wrapper around
<a class="reference internal" href="orb.utils.html#orb.utils.astrometry.fit_stars_in_frame" title="orb.utils.astrometry.fit_stars_in_frame"><code class="xref py py-meth docutils literal notranslate"><span class="pre">orb.utils.astrometry.fit_stars_in_frame()</span></code></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>2 fitting modes are possible:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="n">Individual</span> <span class="n">fit</span> <span class="n">mode</span> <span class="p">[</span><span class="n">multi_fit</span><span class="o">=</span><span class="kc">False</span><span class="p">]</span>
<span class="o">*</span> <span class="n">Multi</span> <span class="n">fit</span> <span class="n">mode</span> <span class="p">[</span><span class="n">multi_fit</span><span class="o">=</span><span class="kc">True</span><span class="p">]</span>
</pre></div>
</div>
<p>see <a class="reference internal" href="orb.utils.html#orb.utils.astrometry.fit_stars_in_frame" title="orb.utils.astrometry.fit_stars_in_frame"><code class="xref py py-meth docutils literal notranslate"><span class="pre">orb.utils.astrometry.fit_stars_in_frame()</span></code></a> for more
information.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>star_list</strong> – Path to a list of stars</p></li>
<li><p><strong>kwargs</strong> – Same optional arguments as for
<a class="reference internal" href="orb.utils.html#orb.utils.astrometry.fit_stars_in_frame" title="orb.utils.astrometry.fit_stars_in_frame"><code class="xref py py-meth docutils literal notranslate"><span class="pre">orb.utils.astrometry.fit_stars_in_frame()</span></code></a>.</p></li>
</ul>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Some optional arguments are taken directly from the
values computed at the init of the Class. The following
optional arguments thus cannot be passed:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="n">profile_name</span>
<span class="o">*</span> <span class="n">scale</span>
<span class="o">*</span> <span class="n">fwhm_pix</span>
<span class="o">*</span> <span class="n">beta</span>
<span class="o">*</span> <span class="n">fit_tol</span>          
</pre></div>
</div>
</div>
</dd></dl>

<dl class="py method">
<dt id="orb.image.Image.get_box_size">
<code class="sig-name descname"><span class="pre">get_box_size</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.image.Image.get_box_size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="orb.image.Image.get_fwhm_pix">
<code class="sig-name descname"><span class="pre">get_fwhm_pix</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.image.Image.get_fwhm_pix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="orb.image.Image.get_stars_from_catalog">
<code class="sig-name descname"><span class="pre">get_stars_from_catalog</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">max_stars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5000</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.image.Image.get_stars_from_catalog" title="Permalink to this definition">¶</a></dt>
<dd><p>Return star positions, corrected for proper motion from Gaia DR2</p>
</dd></dl>

<dl class="py method">
<dt id="orb.image.Image.load_fit_results">
<code class="sig-name descname"><span class="pre">load_fit_results</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fit_results_path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.image.Image.load_fit_results" title="Permalink to this definition">¶</a></dt>
<dd><p>Load a file containing the fit results</p>
</dd></dl>

<dl class="py attribute">
<dt id="orb.image.Image.profiles">
<code class="sig-name descname"><span class="pre">profiles</span></code><em class="property"> <span class="pre">=</span> <span class="pre">['moffat',</span> <span class="pre">'gaussian']</span></em><a class="headerlink" href="#orb.image.Image.profiles" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="orb.image.Image.register">
<code class="sig-name descname"><span class="pre">register</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">max_stars_detect</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">60</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_roundness</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_radius_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">saturation_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sip_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rrange</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xyrange</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nsteps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">7</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_fit_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">skip_registration</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">compute_precision</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">compute_distortion</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_error_maps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_error_spl</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">star_list_query</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fwhm_arc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_background</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.image.Image.register" title="Permalink to this definition">¶</a></dt>
<dd><p>Register data and return a corrected pywcs.WCS
object.</p>
<p>Optionally (if return_error_maps set to True or
return_error_spl set to True) 2 distortion maps used to refine
a calculated SIP distortion model are returned.</p>
<p>Precise RA/DEC positions of the stars in the field are
recorded from a catalog of the VIZIER server.</p>
<p>Using the real position of the same stars in the frame, WCS
transformation parameters are optimized va a SIP model.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>max_stars_detect</strong> – (Optional) Number of detected stars
in the frame for the initial wcs parameters (default 60).</p></li>
<li><p><strong>max_radius_coeff</strong> – (Optional) Maximum radius to detect stars.</p></li>
<li><p><strong>nsteps</strong> – (Optional) Number of refinement steps (default 7).</p></li>
<li><p><strong>sip_order</strong> – (Optional) SIP order (default 3)</p></li>
<li><p><strong>return_fit_params</strong> – (Optional) If True return final fit
parameters instead of wcs (default False).</p></li>
<li><p><strong>compute_distortion</strong> – (Optional) If True, optical
distortion (SIP) are computed. Note that a frame with a lot
of stars is better for this purpose (default False).</p></li>
<li><p><strong>compute_precision</strong> – (Optional) If True, astrometrical
precision is computed (default True).</p></li>
<li><p><strong>return_error_maps</strong> – (Optional) If True, error maps
(200x200 pixels) on the registration are returned (default
False).</p></li>
<li><p><strong>return_error_spl</strong> – (Optional) If True, error maps on the
registration are returned as
scipy.interpolate.RectBivariateSpline instances (default
False).</p></li>
<li><p><strong>star_list_query</strong> – (Optional) A list of star positions in
degree to perform registration. fwhm_arc must also be set.</p></li>
<li><p><strong>fwhm_arc</strong> – (Optional) must be set if star_list_query is
not None.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.image.Image.reset_fwhm_arc">
<code class="sig-name descname"><span class="pre">reset_fwhm_arc</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fwhm_arc</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.image.Image.reset_fwhm_arc" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset FWHM of stars in arcsec</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>fwhm_arc</strong> – FWHM of stars in arcsec</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.image.Image.reset_profile_name">
<code class="sig-name descname"><span class="pre">reset_profile_name</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">profile_name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.image.Image.reset_profile_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset the name of the profile used.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>profile_name</strong> – Name of the PSF profile to use for
fitting. Can be ‘moffat’ or ‘gaussian’.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.image.Image.reset_sip">
<code class="sig-name descname"><span class="pre">reset_sip</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.image.Image.reset_sip" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove sip informations</p>
</dd></dl>

<dl class="py method">
<dt id="orb.image.Image.reset_wcs">
<code class="sig-name descname"><span class="pre">reset_wcs</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target_ra</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_dec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fov</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wcs_rotation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.image.Image.reset_wcs" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset WCS to a raw WCS that can be registered without error with
register().</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>target_ra</strong> – RA at the center of the field</p></li>
<li><p><strong>target_dec</strong> – DEC at the center of the field</p></li>
<li><p><strong>fov</strong> – (Optional) If the instrument is unknown (not
sitelle/spiomm) the field of view must be set in arcminutes
(default None).</p></li>
<li><p><strong>fov</strong> – (Optional) If the instrument is unknown (not
sitelle/spiomm) the wcs_rotation must be set in degrees
(default None).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.image.Image.transform">
<code class="sig-name descname"><span class="pre">transform</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.image.Image.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a transformed image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>params</strong> – A dictionary containing the keys ‘coeffs’=[dx,
dy, dr, da, db], ‘rc’, ‘zoom_factor’. This is exactly the
dictionary returned by self.compute_alignment_coeffs(). may
optionally contain ‘sip1’ and ‘sip2’ where sip1 is the sip
of the image to transform and sip2 is the sip of the image
it is aligned to.</p></li>
<li><p><strong>order</strong> – Interpolation order (default 1)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="orb.image.StandardImage">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">orb.image.</span></code><code class="sig-name descname"><span class="pre">StandardImage</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.image.StandardImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#orb.image.Image" title="orb.image.Image"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.image.Image</span></code></a></p>
<dl class="py method">
<dt id="orb.image.StandardImage.compute_flux_correction_factor">
<code class="sig-name descname"><span class="pre">compute_flux_correction_factor</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.image.StandardImage.compute_flux_correction_factor" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the flux correction factor that can be used by
orb.photometry.Photometry.get_flambda()</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-orb.old">
<span id="orb-old-module"></span><h2>orb.old module<a class="headerlink" href="#module-orb.old" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="orb.old.Cube">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">orb.old.</span></code><code class="sig-name descname"><span class="pre">Cube</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.old.Cube" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#orb.core.Tools" title="orb.core.Tools"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.core.Tools</span></code></a></p>
<p>3d numpy data cube handling. Base class for all Cube classes</p>
<dl class="py method">
<dt id="orb.old.Cube.get_data">
<code class="sig-name descname"><span class="pre">get_data</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x_min</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_max</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_min</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_max</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z_min</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z_max</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">silent</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.old.Cube.get_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a part of the data cube.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x_min</strong> – minimum index along x axis</p></li>
<li><p><strong>x_max</strong> – maximum index along x axis</p></li>
<li><p><strong>y_min</strong> – minimum index along y axis</p></li>
<li><p><strong>y_max</strong> – maximum index along y axis</p></li>
<li><p><strong>z_min</strong> – minimum index along z axis</p></li>
<li><p><strong>z_max</strong> – maximum index along z axis</p></li>
<li><p><strong>silent</strong> – (Optional) if False display a progress bar
during data loading (default False)</p></li>
<li><p><strong>mask</strong> – (Optional) if True return mask (default False).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.old.Cube.get_mean_image">
<code class="sig-name descname"><span class="pre">get_mean_image</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">recompute</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.old.Cube.get_mean_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the mean image of a cube (corresponding to a deep
frame for an interferogram cube or a specral cube).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>recompute</strong> – (Optional) Force to recompute mean image
even if it is already present in the cube (default False).</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In this process NaNs are considered as zeros.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="orb.old.HDFCube">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">orb.old.</span></code><code class="sig-name descname"><span class="pre">HDFCube</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cube_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">silent_init</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">binning</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.old.HDFCube" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#orb.old.Cube" title="orb.old.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.old.Cube</span></code></a></p>
<p>This class implements the use of an HDF5 cube.</p>
<p>An HDF5 cube is similar to the <em>frame-divided cube</em> implemented by
the class <code class="xref py py-class docutils literal notranslate"><span class="pre">orb.core.Cube</span></code> but it makes use of the really
fast data access provided by HDF5 files. The “frame-divided”
concept is keeped but all the frames are grouped into one hdf5
file.</p>
<p>An HDF5 cube must have a certain architecture:</p>
<ul class="simple">
<li><p>Each frame has its own group called ‘frameIIIII’, IIIII being a
integer giving the position of the frame on 5 characters filled
with zeros. e.g. the first frame group is called frame00000</p></li>
<li><p>Each frame group is divided into at least 2 datasets: <strong>data</strong>
and <em>header</em> (e.g. the data of the first frame will be in the
dataset <em>frame00000/data</em>)</p></li>
<li><p>A <strong>mask</strong> dataset can be added to each frame.</p></li>
</ul>
</dd></dl>

</div>
<div class="section" id="module-orb.photometry">
<span id="orb-image-photometry"></span><h2>orb.image photometry<a class="headerlink" href="#module-orb.photometry" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="orb.photometry.Photometry">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">orb.photometry.</span></code><code class="sig-name descname"><span class="pre">Photometry</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filter_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">camera_index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instrument</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sitelle'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">airmass</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.photometry.Photometry" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py attribute">
<dt id="orb.photometry.Photometry.STEP_NB">
<code class="sig-name descname"><span class="pre">STEP_NB</span></code><em class="property"> <span class="pre">=</span> <span class="pre">2000</span></em><a class="headerlink" href="#orb.photometry.Photometry.STEP_NB" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="orb.photometry.Photometry.cameras">
<code class="sig-name descname"><span class="pre">cameras</span></code><em class="property"> <span class="pre">=</span> <span class="pre">[0,</span> <span class="pre">1,</span> <span class="pre">2]</span></em><a class="headerlink" href="#orb.photometry.Photometry.cameras" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="orb.photometry.Photometry.compute_flambda">
<code class="sig-name descname"><span class="pre">compute_flambda</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cm1_axis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">modulated</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.photometry.Photometry.compute_flambda" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the flambda calibration function from the correction vector.</p>
<p>It can be computed with
cube.SpectralCube.compute_flux_calibration() or
image.StandardImage.compute_flux_correction_factor() and
fft.StandardSpectrum.compute_flux_correction_vector().</p>
</dd></dl>

<dl class="py method">
<dt id="orb.photometry.Photometry.flux2counts">
<code class="sig-name descname"><span class="pre">flux2counts</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">flux</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">modulated</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">opd_jitter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wf_error</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.photometry.Photometry.flux2counts" title="Permalink to this definition">¶</a></dt>
<dd><p>convert a flux in erg/cm2/s/A to a flux in counts/s in both cameras</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>flux</strong> – Flux must be in erg/cm2/s/A</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a flux in counts/s</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.photometry.Photometry.get_ccd_gain">
<code class="sig-name descname"><span class="pre">get_ccd_gain</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.photometry.Photometry.get_ccd_gain" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="orb.photometry.Photometry.get_modulated_transmission">
<code class="sig-name descname"><span class="pre">get_modulated_transmission</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">opd_jitter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wf_error</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.photometry.Photometry.get_modulated_transmission" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="orb.photometry.Photometry.get_modulation_efficiency">
<code class="sig-name descname"><span class="pre">get_modulation_efficiency</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">opd_jitter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wf_error</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.photometry.Photometry.get_modulation_efficiency" title="Permalink to this definition">¶</a></dt>
<dd><p>Return modulation efficiency</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>opd_jitter</strong> – OPD jitter in nm (standard deviation)</p></li>
<li><p><strong>wf_error</strong> – wavefront error ratio (e.g. 1/30.)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.photometry.Photometry.get_qe">
<code class="sig-name descname"><span class="pre">get_qe</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.photometry.Photometry.get_qe" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="orb.photometry.Photometry.get_transmission">
<code class="sig-name descname"><span class="pre">get_transmission</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tterm</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.photometry.Photometry.get_transmission" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="orb.photometry.Photometry.get_unmodulated_transmission">
<code class="sig-name descname"><span class="pre">get_unmodulated_transmission</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.photometry.Photometry.get_unmodulated_transmission" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="orb.photometry.Photometry.transmission_terms">
<code class="sig-name descname"><span class="pre">transmission_terms</span></code><em class="property"> <span class="pre">=</span> <span class="pre">['atmosphere',</span> <span class="pre">'mirror',</span> <span class="pre">'optics',</span> <span class="pre">'filter',</span> <span class="pre">'telescope']</span></em><a class="headerlink" href="#orb.photometry.Photometry.transmission_terms" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt id="orb.photometry.Standard">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">orb.photometry.</span></code><code class="sig-name descname"><span class="pre">Standard</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">std_name</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.photometry.Standard" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#orb.core.Tools" title="orb.core.Tools"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.core.Tools</span></code></a></p>
<p>Manage standard files and photometrical calibration</p>
<dl class="py attribute">
<dt id="orb.photometry.Standard.ang">
<code class="sig-name descname"><span class="pre">ang</span></code><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#orb.photometry.Standard.ang" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="orb.photometry.Standard.compute_optimal_texp">
<code class="sig-name descname"><span class="pre">compute_optimal_texp</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">step</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seeing</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">camera_number</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">saturation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">30000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">airmass</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.photometry.Standard.compute_optimal_texp" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the optimal exposition time given the total flux of
the star in ADU/s.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>step</strong> – Step size in nm</p></li>
<li><p><strong>order</strong> – Folding order</p></li>
<li><p><strong>seeing</strong> – Star’s FWHM in arcsec</p></li>
<li><p><strong>filter_name</strong> – Name of the filter</p></li>
<li><p><strong>camera_number</strong> – Number of the camera</p></li>
<li><p><strong>saturation</strong> – (Optional) Saturation value of the detector
(default 30000).</p></li>
<li><p><strong>airmass</strong> – (Optional) Airmass (default 1)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="orb.photometry.Standard.flux">
<code class="sig-name descname"><span class="pre">flux</span></code><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#orb.photometry.Standard.flux" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="orb.photometry.Standard.get_spectrum">
<code class="sig-name descname"><span class="pre">get_spectrum</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filter_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cm1_axis</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.photometry.Standard.get_spectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Return part of the standard spectrum corresponding to the
observation parameters.</p>
<p>Returned spectrum is calibrated in erg/cm^2/s/A</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>cm1_axis</strong> – Axis instance in cm-1</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.photometry.Standard.simulate_measured_flux">
<code class="sig-name descname"><span class="pre">simulate_measured_flux</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filter_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cm1_axis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">airmass</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">camera_index</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">opd_jitter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wf_error</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">modulated</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.photometry.Standard.simulate_measured_flux" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a simulation of the measured flux in counts/s</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filter_name</strong> – Filter name</p></li>
<li><p><strong>n</strong> – Number of steps</p></li>
<li><p><strong>corr</strong> – (Optional) Correction coefficient related to the incident
angle (default None, taken at the center of the field).</p></li>
<li><p><strong>opd_jitter</strong> – OPD jitter in nm (standard deviation)</p></li>
<li><p><strong>wf_error</strong> – wavefront error ratio (e.g. 1/30.)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-orb.sim">
<span id="orb-sim"></span><h2>orb.sim<a class="headerlink" href="#module-orb.sim" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="orb.sim.RawSimulator">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">orb.sim.</span></code><code class="sig-name descname"><span class="pre">RawSimulator</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">step_nb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instrument</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sitelle'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.sim.RawSimulator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py method">
<dt id="orb.sim.RawSimulator.add_background">
<code class="sig-name descname"><span class="pre">add_background</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.sim.RawSimulator.add_background" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="orb.sim.RawSimulator.add_line">
<code class="sig-name descname"><span class="pre">add_line</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">wave</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flux</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">jitter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.sim.RawSimulator.add_line" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>wave</strong> – The name of the line or the line wavenumber in cm-1</p></li>
<li><p><strong>vel</strong> – Velocity in km/s</p></li>
<li><p><strong>jitter</strong> – Std of an OPD jitter. Must be given in nm.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.sim.RawSimulator.add_spectrum">
<code class="sig-name descname"><span class="pre">add_spectrum</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">spectrum</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.sim.RawSimulator.add_spectrum" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>spectrum</strong> – Spectrum instance which must be defined on the filter range.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.sim.RawSimulator.get_interferogram">
<code class="sig-name descname"><span class="pre">get_interferogram</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.sim.RawSimulator.get_interferogram" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt id="orb.sim.SkyModel">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">orb.sim.</span></code><code class="sig-name descname"><span class="pre">SkyModel</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">airmass</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instrument</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sitelle'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.sim.SkyModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Very basic sky model which generate a spectrum of the sky.</p>
<p>It includes continuum brightness, sky lines and moon brightness.</p>
<p>most data comes from <a class="reference external" href="https://www.gemini.edu/observing/telescopes-and-sites/sites">https://www.gemini.edu/observing/telescopes-and-sites/sites</a></p>
<dl class="py method">
<dt id="orb.sim.SkyModel.get_spectrum">
<code class="sig-name descname"><span class="pre">get_spectrum</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cm1_axis</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.sim.SkyModel.get_spectrum" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt id="orb.sim.SourceSpectrum">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">orb.sim.</span></code><code class="sig-name descname"><span class="pre">SourceSpectrum</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">spectrum</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instrument</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sitelle'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_prefix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'./'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.sim.SourceSpectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#orb.core.Vector1d" title="orb.core.Vector1d"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.core.Vector1d</span></code></a>, <a class="reference internal" href="#orb.core.Tools" title="orb.core.Tools"><code class="xref py py-class docutils literal notranslate"><span class="pre">orb.core.Tools</span></code></a></p>
<dl class="py method">
<dt id="orb.sim.SourceSpectrum.add_line">
<code class="sig-name descname"><span class="pre">add_line</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">wave</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flux</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.sim.SourceSpectrum.add_line" title="Permalink to this definition">¶</a></dt>
<dd><p>add a line to the spectrum</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>wave</strong> – Name of the line or its wavenumber in cm-1 (can be a tuple)</p></li>
<li><p><strong>vel</strong> – Velocity in km/s</p></li>
<li><p><strong>flux</strong> – Flux in erg/cm2/s</p></li>
<li><p><strong>sigma</strong> – Broadening in km/s</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.sim.SourceSpectrum.add_spectrum">
<code class="sig-name descname"><span class="pre">add_spectrum</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">spectrum</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.sim.SourceSpectrum.add_spectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Spectrum</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>spectrum</strong> – spectrum vector, must be in erg/cm2/s/A</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="orb.sim.SourceSpectrum.get_interferogram">
<code class="sig-name descname"><span class="pre">get_interferogram</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">camera</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">binning</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">me_factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orb.sim.SourceSpectrum.get_interferogram" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-orb">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-orb" title="Permalink to this headline">¶</a></h2>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="orb.ext.html" class="btn btn-neutral float-right" title="orb.ext package" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="index.html" class="btn btn-neutral float-left" title="ORB Documentation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, Thomas Martin (thomas.martin.1@ulaval.ca).

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>